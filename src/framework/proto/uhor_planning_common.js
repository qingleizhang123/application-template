/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.UIBot = (function() {

    /**
     * Namespace UIBot.
     * @exports UIBot
     * @namespace
     */
    var UIBot = {};

    UIBot.Common = (function() {

        /**
         * Namespace Common.
         * @memberof UIBot
         * @namespace
         */
        var Common = {};

        Common.MessageUpdateSelectedPatientInfo = (function() {

            /**
             * Properties of a MessageUpdateSelectedPatientInfo.
             * @memberof UIBot.Common
             * @interface IMessageUpdateSelectedPatientInfo
             * @property {boolean|null} [IsRefresh] MessageUpdateSelectedPatientInfo IsRefresh
             * @property {string|null} [PatientUID] MessageUpdateSelectedPatientInfo PatientUID
             * @property {Array.<UIBot.Common.IMessageDBTagInfo>|null} [MsgDBTagInfoList] MessageUpdateSelectedPatientInfo MsgDBTagInfoList
             */

            /**
             * Constructs a new MessageUpdateSelectedPatientInfo.
             * @memberof UIBot.Common
             * @classdesc Represents a MessageUpdateSelectedPatientInfo.
             * @implements IMessageUpdateSelectedPatientInfo
             * @constructor
             * @param {UIBot.Common.IMessageUpdateSelectedPatientInfo=} [properties] Properties to set
             */
            function MessageUpdateSelectedPatientInfo(properties) {
                this.MsgDBTagInfoList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageUpdateSelectedPatientInfo IsRefresh.
             * @member {boolean} IsRefresh
             * @memberof UIBot.Common.MessageUpdateSelectedPatientInfo
             * @instance
             */
            MessageUpdateSelectedPatientInfo.prototype.IsRefresh = false;

            /**
             * MessageUpdateSelectedPatientInfo PatientUID.
             * @member {string} PatientUID
             * @memberof UIBot.Common.MessageUpdateSelectedPatientInfo
             * @instance
             */
            MessageUpdateSelectedPatientInfo.prototype.PatientUID = "";

            /**
             * MessageUpdateSelectedPatientInfo MsgDBTagInfoList.
             * @member {Array.<UIBot.Common.IMessageDBTagInfo>} MsgDBTagInfoList
             * @memberof UIBot.Common.MessageUpdateSelectedPatientInfo
             * @instance
             */
            MessageUpdateSelectedPatientInfo.prototype.MsgDBTagInfoList = $util.emptyArray;

            /**
             * Creates a new MessageUpdateSelectedPatientInfo instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MessageUpdateSelectedPatientInfo
             * @static
             * @param {UIBot.Common.IMessageUpdateSelectedPatientInfo=} [properties] Properties to set
             * @returns {UIBot.Common.MessageUpdateSelectedPatientInfo} MessageUpdateSelectedPatientInfo instance
             */
            MessageUpdateSelectedPatientInfo.create = function create(properties) {
                return new MessageUpdateSelectedPatientInfo(properties);
            };

            /**
             * Encodes the specified MessageUpdateSelectedPatientInfo message. Does not implicitly {@link UIBot.Common.MessageUpdateSelectedPatientInfo.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MessageUpdateSelectedPatientInfo
             * @static
             * @param {UIBot.Common.IMessageUpdateSelectedPatientInfo} message MessageUpdateSelectedPatientInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageUpdateSelectedPatientInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.IsRefresh != null && Object.hasOwnProperty.call(message, "IsRefresh"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.IsRefresh);
                if (message.PatientUID != null && Object.hasOwnProperty.call(message, "PatientUID"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.PatientUID);
                if (message.MsgDBTagInfoList != null && message.MsgDBTagInfoList.length)
                    for (var i = 0; i < message.MsgDBTagInfoList.length; ++i)
                        $root.UIBot.Common.MessageDBTagInfo.encode(message.MsgDBTagInfoList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MessageUpdateSelectedPatientInfo message, length delimited. Does not implicitly {@link UIBot.Common.MessageUpdateSelectedPatientInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MessageUpdateSelectedPatientInfo
             * @static
             * @param {UIBot.Common.IMessageUpdateSelectedPatientInfo} message MessageUpdateSelectedPatientInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageUpdateSelectedPatientInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageUpdateSelectedPatientInfo message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MessageUpdateSelectedPatientInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MessageUpdateSelectedPatientInfo} MessageUpdateSelectedPatientInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageUpdateSelectedPatientInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MessageUpdateSelectedPatientInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.IsRefresh = reader.bool();
                            break;
                        }
                    case 2: {
                            message.PatientUID = reader.string();
                            break;
                        }
                    case 3: {
                            if (!(message.MsgDBTagInfoList && message.MsgDBTagInfoList.length))
                                message.MsgDBTagInfoList = [];
                            message.MsgDBTagInfoList.push($root.UIBot.Common.MessageDBTagInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageUpdateSelectedPatientInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MessageUpdateSelectedPatientInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MessageUpdateSelectedPatientInfo} MessageUpdateSelectedPatientInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageUpdateSelectedPatientInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageUpdateSelectedPatientInfo message.
             * @function verify
             * @memberof UIBot.Common.MessageUpdateSelectedPatientInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageUpdateSelectedPatientInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.IsRefresh != null && message.hasOwnProperty("IsRefresh"))
                    if (typeof message.IsRefresh !== "boolean")
                        return "IsRefresh: boolean expected";
                if (message.PatientUID != null && message.hasOwnProperty("PatientUID"))
                    if (!$util.isString(message.PatientUID))
                        return "PatientUID: string expected";
                if (message.MsgDBTagInfoList != null && message.hasOwnProperty("MsgDBTagInfoList")) {
                    if (!Array.isArray(message.MsgDBTagInfoList))
                        return "MsgDBTagInfoList: array expected";
                    for (var i = 0; i < message.MsgDBTagInfoList.length; ++i) {
                        var error = $root.UIBot.Common.MessageDBTagInfo.verify(message.MsgDBTagInfoList[i]);
                        if (error)
                            return "MsgDBTagInfoList." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MessageUpdateSelectedPatientInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MessageUpdateSelectedPatientInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MessageUpdateSelectedPatientInfo} MessageUpdateSelectedPatientInfo
             */
            MessageUpdateSelectedPatientInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MessageUpdateSelectedPatientInfo)
                    return object;
                var message = new $root.UIBot.Common.MessageUpdateSelectedPatientInfo();
                if (object.IsRefresh != null)
                    message.IsRefresh = Boolean(object.IsRefresh);
                if (object.PatientUID != null)
                    message.PatientUID = String(object.PatientUID);
                if (object.MsgDBTagInfoList) {
                    if (!Array.isArray(object.MsgDBTagInfoList))
                        throw TypeError(".UIBot.Common.MessageUpdateSelectedPatientInfo.MsgDBTagInfoList: array expected");
                    message.MsgDBTagInfoList = [];
                    for (var i = 0; i < object.MsgDBTagInfoList.length; ++i) {
                        if (typeof object.MsgDBTagInfoList[i] !== "object")
                            throw TypeError(".UIBot.Common.MessageUpdateSelectedPatientInfo.MsgDBTagInfoList: object expected");
                        message.MsgDBTagInfoList[i] = $root.UIBot.Common.MessageDBTagInfo.fromObject(object.MsgDBTagInfoList[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MessageUpdateSelectedPatientInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MessageUpdateSelectedPatientInfo
             * @static
             * @param {UIBot.Common.MessageUpdateSelectedPatientInfo} message MessageUpdateSelectedPatientInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageUpdateSelectedPatientInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.MsgDBTagInfoList = [];
                if (options.defaults) {
                    object.IsRefresh = false;
                    object.PatientUID = "";
                }
                if (message.IsRefresh != null && message.hasOwnProperty("IsRefresh"))
                    object.IsRefresh = message.IsRefresh;
                if (message.PatientUID != null && message.hasOwnProperty("PatientUID"))
                    object.PatientUID = message.PatientUID;
                if (message.MsgDBTagInfoList && message.MsgDBTagInfoList.length) {
                    object.MsgDBTagInfoList = [];
                    for (var j = 0; j < message.MsgDBTagInfoList.length; ++j)
                        object.MsgDBTagInfoList[j] = $root.UIBot.Common.MessageDBTagInfo.toObject(message.MsgDBTagInfoList[j], options);
                }
                return object;
            };

            /**
             * Converts this MessageUpdateSelectedPatientInfo to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MessageUpdateSelectedPatientInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageUpdateSelectedPatientInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MessageUpdateSelectedPatientInfo
             * @function getTypeUrl
             * @memberof UIBot.Common.MessageUpdateSelectedPatientInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MessageUpdateSelectedPatientInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MessageUpdateSelectedPatientInfo";
            };

            return MessageUpdateSelectedPatientInfo;
        })();

        Common.MessageDBTagInfo = (function() {

            /**
             * Properties of a MessageDBTagInfo.
             * @memberof UIBot.Common
             * @interface IMessageDBTagInfo
             * @property {number|null} [Tag] MessageDBTagInfo Tag
             * @property {string|null} [Value] MessageDBTagInfo Value
             */

            /**
             * Constructs a new MessageDBTagInfo.
             * @memberof UIBot.Common
             * @classdesc Represents a MessageDBTagInfo.
             * @implements IMessageDBTagInfo
             * @constructor
             * @param {UIBot.Common.IMessageDBTagInfo=} [properties] Properties to set
             */
            function MessageDBTagInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageDBTagInfo Tag.
             * @member {number} Tag
             * @memberof UIBot.Common.MessageDBTagInfo
             * @instance
             */
            MessageDBTagInfo.prototype.Tag = 0;

            /**
             * MessageDBTagInfo Value.
             * @member {string} Value
             * @memberof UIBot.Common.MessageDBTagInfo
             * @instance
             */
            MessageDBTagInfo.prototype.Value = "";

            /**
             * Creates a new MessageDBTagInfo instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MessageDBTagInfo
             * @static
             * @param {UIBot.Common.IMessageDBTagInfo=} [properties] Properties to set
             * @returns {UIBot.Common.MessageDBTagInfo} MessageDBTagInfo instance
             */
            MessageDBTagInfo.create = function create(properties) {
                return new MessageDBTagInfo(properties);
            };

            /**
             * Encodes the specified MessageDBTagInfo message. Does not implicitly {@link UIBot.Common.MessageDBTagInfo.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MessageDBTagInfo
             * @static
             * @param {UIBot.Common.IMessageDBTagInfo} message MessageDBTagInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageDBTagInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Tag != null && Object.hasOwnProperty.call(message, "Tag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.Tag);
                if (message.Value != null && Object.hasOwnProperty.call(message, "Value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.Value);
                return writer;
            };

            /**
             * Encodes the specified MessageDBTagInfo message, length delimited. Does not implicitly {@link UIBot.Common.MessageDBTagInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MessageDBTagInfo
             * @static
             * @param {UIBot.Common.IMessageDBTagInfo} message MessageDBTagInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageDBTagInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageDBTagInfo message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MessageDBTagInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MessageDBTagInfo} MessageDBTagInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageDBTagInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MessageDBTagInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.Tag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.Value = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageDBTagInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MessageDBTagInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MessageDBTagInfo} MessageDBTagInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageDBTagInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageDBTagInfo message.
             * @function verify
             * @memberof UIBot.Common.MessageDBTagInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageDBTagInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.Tag != null && message.hasOwnProperty("Tag"))
                    if (!$util.isInteger(message.Tag))
                        return "Tag: integer expected";
                if (message.Value != null && message.hasOwnProperty("Value"))
                    if (!$util.isString(message.Value))
                        return "Value: string expected";
                return null;
            };

            /**
             * Creates a MessageDBTagInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MessageDBTagInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MessageDBTagInfo} MessageDBTagInfo
             */
            MessageDBTagInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MessageDBTagInfo)
                    return object;
                var message = new $root.UIBot.Common.MessageDBTagInfo();
                if (object.Tag != null)
                    message.Tag = object.Tag >>> 0;
                if (object.Value != null)
                    message.Value = String(object.Value);
                return message;
            };

            /**
             * Creates a plain object from a MessageDBTagInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MessageDBTagInfo
             * @static
             * @param {UIBot.Common.MessageDBTagInfo} message MessageDBTagInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageDBTagInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.Tag = 0;
                    object.Value = "";
                }
                if (message.Tag != null && message.hasOwnProperty("Tag"))
                    object.Tag = message.Tag;
                if (message.Value != null && message.hasOwnProperty("Value"))
                    object.Value = message.Value;
                return object;
            };

            /**
             * Converts this MessageDBTagInfo to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MessageDBTagInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageDBTagInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MessageDBTagInfo
             * @function getTypeUrl
             * @memberof UIBot.Common.MessageDBTagInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MessageDBTagInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MessageDBTagInfo";
            };

            return MessageDBTagInfo;
        })();

        Common.CurrentPatientInfo = (function() {

            /**
             * Properties of a CurrentPatientInfo.
             * @memberof UIBot.Common
             * @interface ICurrentPatientInfo
             * @property {string|null} [Name] CurrentPatientInfo Name
             * @property {string|null} [Number] CurrentPatientInfo Number
             * @property {string|null} [Sex] CurrentPatientInfo Sex
             * @property {string|null} [Age] CurrentPatientInfo Age
             */

            /**
             * Constructs a new CurrentPatientInfo.
             * @memberof UIBot.Common
             * @classdesc Represents a CurrentPatientInfo.
             * @implements ICurrentPatientInfo
             * @constructor
             * @param {UIBot.Common.ICurrentPatientInfo=} [properties] Properties to set
             */
            function CurrentPatientInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CurrentPatientInfo Name.
             * @member {string} Name
             * @memberof UIBot.Common.CurrentPatientInfo
             * @instance
             */
            CurrentPatientInfo.prototype.Name = "";

            /**
             * CurrentPatientInfo Number.
             * @member {string} Number
             * @memberof UIBot.Common.CurrentPatientInfo
             * @instance
             */
            CurrentPatientInfo.prototype.Number = "";

            /**
             * CurrentPatientInfo Sex.
             * @member {string} Sex
             * @memberof UIBot.Common.CurrentPatientInfo
             * @instance
             */
            CurrentPatientInfo.prototype.Sex = "";

            /**
             * CurrentPatientInfo Age.
             * @member {string} Age
             * @memberof UIBot.Common.CurrentPatientInfo
             * @instance
             */
            CurrentPatientInfo.prototype.Age = "";

            /**
             * Creates a new CurrentPatientInfo instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.CurrentPatientInfo
             * @static
             * @param {UIBot.Common.ICurrentPatientInfo=} [properties] Properties to set
             * @returns {UIBot.Common.CurrentPatientInfo} CurrentPatientInfo instance
             */
            CurrentPatientInfo.create = function create(properties) {
                return new CurrentPatientInfo(properties);
            };

            /**
             * Encodes the specified CurrentPatientInfo message. Does not implicitly {@link UIBot.Common.CurrentPatientInfo.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.CurrentPatientInfo
             * @static
             * @param {UIBot.Common.ICurrentPatientInfo} message CurrentPatientInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CurrentPatientInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Name != null && Object.hasOwnProperty.call(message, "Name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.Name);
                if (message.Number != null && Object.hasOwnProperty.call(message, "Number"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.Number);
                if (message.Sex != null && Object.hasOwnProperty.call(message, "Sex"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.Sex);
                if (message.Age != null && Object.hasOwnProperty.call(message, "Age"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.Age);
                return writer;
            };

            /**
             * Encodes the specified CurrentPatientInfo message, length delimited. Does not implicitly {@link UIBot.Common.CurrentPatientInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.CurrentPatientInfo
             * @static
             * @param {UIBot.Common.ICurrentPatientInfo} message CurrentPatientInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CurrentPatientInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CurrentPatientInfo message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.CurrentPatientInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.CurrentPatientInfo} CurrentPatientInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CurrentPatientInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.CurrentPatientInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.Name = reader.string();
                            break;
                        }
                    case 2: {
                            message.Number = reader.string();
                            break;
                        }
                    case 3: {
                            message.Sex = reader.string();
                            break;
                        }
                    case 4: {
                            message.Age = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CurrentPatientInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.CurrentPatientInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.CurrentPatientInfo} CurrentPatientInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CurrentPatientInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CurrentPatientInfo message.
             * @function verify
             * @memberof UIBot.Common.CurrentPatientInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CurrentPatientInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.Name != null && message.hasOwnProperty("Name"))
                    if (!$util.isString(message.Name))
                        return "Name: string expected";
                if (message.Number != null && message.hasOwnProperty("Number"))
                    if (!$util.isString(message.Number))
                        return "Number: string expected";
                if (message.Sex != null && message.hasOwnProperty("Sex"))
                    if (!$util.isString(message.Sex))
                        return "Sex: string expected";
                if (message.Age != null && message.hasOwnProperty("Age"))
                    if (!$util.isString(message.Age))
                        return "Age: string expected";
                return null;
            };

            /**
             * Creates a CurrentPatientInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.CurrentPatientInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.CurrentPatientInfo} CurrentPatientInfo
             */
            CurrentPatientInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.CurrentPatientInfo)
                    return object;
                var message = new $root.UIBot.Common.CurrentPatientInfo();
                if (object.Name != null)
                    message.Name = String(object.Name);
                if (object.Number != null)
                    message.Number = String(object.Number);
                if (object.Sex != null)
                    message.Sex = String(object.Sex);
                if (object.Age != null)
                    message.Age = String(object.Age);
                return message;
            };

            /**
             * Creates a plain object from a CurrentPatientInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.CurrentPatientInfo
             * @static
             * @param {UIBot.Common.CurrentPatientInfo} message CurrentPatientInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CurrentPatientInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.Name = "";
                    object.Number = "";
                    object.Sex = "";
                    object.Age = "";
                }
                if (message.Name != null && message.hasOwnProperty("Name"))
                    object.Name = message.Name;
                if (message.Number != null && message.hasOwnProperty("Number"))
                    object.Number = message.Number;
                if (message.Sex != null && message.hasOwnProperty("Sex"))
                    object.Sex = message.Sex;
                if (message.Age != null && message.hasOwnProperty("Age"))
                    object.Age = message.Age;
                return object;
            };

            /**
             * Converts this CurrentPatientInfo to JSON.
             * @function toJSON
             * @memberof UIBot.Common.CurrentPatientInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CurrentPatientInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CurrentPatientInfo
             * @function getTypeUrl
             * @memberof UIBot.Common.CurrentPatientInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CurrentPatientInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.CurrentPatientInfo";
            };

            return CurrentPatientInfo;
        })();

        Common.MsgAccountUser = (function() {

            /**
             * Properties of a MsgAccountUser.
             * @memberof UIBot.Common
             * @interface IMsgAccountUser
             * @property {string} stuid MsgAccountUser stuid
             * @property {string} username MsgAccountUser username
             * @property {string} name MsgAccountUser name
             * @property {string} roleKey MsgAccountUser roleKey
             */

            /**
             * Constructs a new MsgAccountUser.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgAccountUser.
             * @implements IMsgAccountUser
             * @constructor
             * @param {UIBot.Common.IMsgAccountUser=} [properties] Properties to set
             */
            function MsgAccountUser(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgAccountUser stuid.
             * @member {string} stuid
             * @memberof UIBot.Common.MsgAccountUser
             * @instance
             */
            MsgAccountUser.prototype.stuid = "";

            /**
             * MsgAccountUser username.
             * @member {string} username
             * @memberof UIBot.Common.MsgAccountUser
             * @instance
             */
            MsgAccountUser.prototype.username = "";

            /**
             * MsgAccountUser name.
             * @member {string} name
             * @memberof UIBot.Common.MsgAccountUser
             * @instance
             */
            MsgAccountUser.prototype.name = "";

            /**
             * MsgAccountUser roleKey.
             * @member {string} roleKey
             * @memberof UIBot.Common.MsgAccountUser
             * @instance
             */
            MsgAccountUser.prototype.roleKey = "";

            /**
             * Creates a new MsgAccountUser instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgAccountUser
             * @static
             * @param {UIBot.Common.IMsgAccountUser=} [properties] Properties to set
             * @returns {UIBot.Common.MsgAccountUser} MsgAccountUser instance
             */
            MsgAccountUser.create = function create(properties) {
                return new MsgAccountUser(properties);
            };

            /**
             * Encodes the specified MsgAccountUser message. Does not implicitly {@link UIBot.Common.MsgAccountUser.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgAccountUser
             * @static
             * @param {UIBot.Common.IMsgAccountUser} message MsgAccountUser message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgAccountUser.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.stuid);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.roleKey);
                return writer;
            };

            /**
             * Encodes the specified MsgAccountUser message, length delimited. Does not implicitly {@link UIBot.Common.MsgAccountUser.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgAccountUser
             * @static
             * @param {UIBot.Common.IMsgAccountUser} message MsgAccountUser message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgAccountUser.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgAccountUser message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgAccountUser
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgAccountUser} MsgAccountUser
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgAccountUser.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgAccountUser();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.stuid = reader.string();
                            break;
                        }
                    case 2: {
                            message.username = reader.string();
                            break;
                        }
                    case 3: {
                            message.name = reader.string();
                            break;
                        }
                    case 4: {
                            message.roleKey = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("stuid"))
                    throw $util.ProtocolError("missing required 'stuid'", { instance: message });
                if (!message.hasOwnProperty("username"))
                    throw $util.ProtocolError("missing required 'username'", { instance: message });
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                if (!message.hasOwnProperty("roleKey"))
                    throw $util.ProtocolError("missing required 'roleKey'", { instance: message });
                return message;
            };

            /**
             * Decodes a MsgAccountUser message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgAccountUser
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgAccountUser} MsgAccountUser
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgAccountUser.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgAccountUser message.
             * @function verify
             * @memberof UIBot.Common.MsgAccountUser
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgAccountUser.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.stuid))
                    return "stuid: string expected";
                if (!$util.isString(message.username))
                    return "username: string expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (!$util.isString(message.roleKey))
                    return "roleKey: string expected";
                return null;
            };

            /**
             * Creates a MsgAccountUser message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgAccountUser
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgAccountUser} MsgAccountUser
             */
            MsgAccountUser.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgAccountUser)
                    return object;
                var message = new $root.UIBot.Common.MsgAccountUser();
                if (object.stuid != null)
                    message.stuid = String(object.stuid);
                if (object.username != null)
                    message.username = String(object.username);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.roleKey != null)
                    message.roleKey = String(object.roleKey);
                return message;
            };

            /**
             * Creates a plain object from a MsgAccountUser message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgAccountUser
             * @static
             * @param {UIBot.Common.MsgAccountUser} message MsgAccountUser
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgAccountUser.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stuid = "";
                    object.username = "";
                    object.name = "";
                    object.roleKey = "";
                }
                if (message.stuid != null && message.hasOwnProperty("stuid"))
                    object.stuid = message.stuid;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.roleKey != null && message.hasOwnProperty("roleKey"))
                    object.roleKey = message.roleKey;
                return object;
            };

            /**
             * Converts this MsgAccountUser to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgAccountUser
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgAccountUser.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgAccountUser
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgAccountUser
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgAccountUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgAccountUser";
            };

            return MsgAccountUser;
        })();

        Common.MsgAccountUserList = (function() {

            /**
             * Properties of a MsgAccountUserList.
             * @memberof UIBot.Common
             * @interface IMsgAccountUserList
             * @property {Array.<UIBot.Common.IMsgAccountUser>|null} [userList] MsgAccountUserList userList
             */

            /**
             * Constructs a new MsgAccountUserList.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgAccountUserList.
             * @implements IMsgAccountUserList
             * @constructor
             * @param {UIBot.Common.IMsgAccountUserList=} [properties] Properties to set
             */
            function MsgAccountUserList(properties) {
                this.userList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgAccountUserList userList.
             * @member {Array.<UIBot.Common.IMsgAccountUser>} userList
             * @memberof UIBot.Common.MsgAccountUserList
             * @instance
             */
            MsgAccountUserList.prototype.userList = $util.emptyArray;

            /**
             * Creates a new MsgAccountUserList instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgAccountUserList
             * @static
             * @param {UIBot.Common.IMsgAccountUserList=} [properties] Properties to set
             * @returns {UIBot.Common.MsgAccountUserList} MsgAccountUserList instance
             */
            MsgAccountUserList.create = function create(properties) {
                return new MsgAccountUserList(properties);
            };

            /**
             * Encodes the specified MsgAccountUserList message. Does not implicitly {@link UIBot.Common.MsgAccountUserList.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgAccountUserList
             * @static
             * @param {UIBot.Common.IMsgAccountUserList} message MsgAccountUserList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgAccountUserList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userList != null && message.userList.length)
                    for (var i = 0; i < message.userList.length; ++i)
                        $root.UIBot.Common.MsgAccountUser.encode(message.userList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MsgAccountUserList message, length delimited. Does not implicitly {@link UIBot.Common.MsgAccountUserList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgAccountUserList
             * @static
             * @param {UIBot.Common.IMsgAccountUserList} message MsgAccountUserList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgAccountUserList.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgAccountUserList message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgAccountUserList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgAccountUserList} MsgAccountUserList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgAccountUserList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgAccountUserList();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.userList && message.userList.length))
                                message.userList = [];
                            message.userList.push($root.UIBot.Common.MsgAccountUser.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgAccountUserList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgAccountUserList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgAccountUserList} MsgAccountUserList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgAccountUserList.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgAccountUserList message.
             * @function verify
             * @memberof UIBot.Common.MsgAccountUserList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgAccountUserList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userList != null && message.hasOwnProperty("userList")) {
                    if (!Array.isArray(message.userList))
                        return "userList: array expected";
                    for (var i = 0; i < message.userList.length; ++i) {
                        var error = $root.UIBot.Common.MsgAccountUser.verify(message.userList[i]);
                        if (error)
                            return "userList." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MsgAccountUserList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgAccountUserList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgAccountUserList} MsgAccountUserList
             */
            MsgAccountUserList.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgAccountUserList)
                    return object;
                var message = new $root.UIBot.Common.MsgAccountUserList();
                if (object.userList) {
                    if (!Array.isArray(object.userList))
                        throw TypeError(".UIBot.Common.MsgAccountUserList.userList: array expected");
                    message.userList = [];
                    for (var i = 0; i < object.userList.length; ++i) {
                        if (typeof object.userList[i] !== "object")
                            throw TypeError(".UIBot.Common.MsgAccountUserList.userList: object expected");
                        message.userList[i] = $root.UIBot.Common.MsgAccountUser.fromObject(object.userList[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MsgAccountUserList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgAccountUserList
             * @static
             * @param {UIBot.Common.MsgAccountUserList} message MsgAccountUserList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgAccountUserList.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.userList = [];
                if (message.userList && message.userList.length) {
                    object.userList = [];
                    for (var j = 0; j < message.userList.length; ++j)
                        object.userList[j] = $root.UIBot.Common.MsgAccountUser.toObject(message.userList[j], options);
                }
                return object;
            };

            /**
             * Converts this MsgAccountUserList to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgAccountUserList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgAccountUserList.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgAccountUserList
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgAccountUserList
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgAccountUserList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgAccountUserList";
            };

            return MsgAccountUserList;
        })();

        Common.MsgErrorInfo = (function() {

            /**
             * Properties of a MsgErrorInfo.
             * @memberof UIBot.Common
             * @interface IMsgErrorInfo
             * @property {number} errorID MsgErrorInfo errorID
             * @property {string|null} [errorInfo] MsgErrorInfo errorInfo
             */

            /**
             * Constructs a new MsgErrorInfo.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgErrorInfo.
             * @implements IMsgErrorInfo
             * @constructor
             * @param {UIBot.Common.IMsgErrorInfo=} [properties] Properties to set
             */
            function MsgErrorInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgErrorInfo errorID.
             * @member {number} errorID
             * @memberof UIBot.Common.MsgErrorInfo
             * @instance
             */
            MsgErrorInfo.prototype.errorID = 0;

            /**
             * MsgErrorInfo errorInfo.
             * @member {string} errorInfo
             * @memberof UIBot.Common.MsgErrorInfo
             * @instance
             */
            MsgErrorInfo.prototype.errorInfo = "";

            /**
             * Creates a new MsgErrorInfo instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgErrorInfo
             * @static
             * @param {UIBot.Common.IMsgErrorInfo=} [properties] Properties to set
             * @returns {UIBot.Common.MsgErrorInfo} MsgErrorInfo instance
             */
            MsgErrorInfo.create = function create(properties) {
                return new MsgErrorInfo(properties);
            };

            /**
             * Encodes the specified MsgErrorInfo message. Does not implicitly {@link UIBot.Common.MsgErrorInfo.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgErrorInfo
             * @static
             * @param {UIBot.Common.IMsgErrorInfo} message MsgErrorInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgErrorInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errorID);
                if (message.errorInfo != null && Object.hasOwnProperty.call(message, "errorInfo"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorInfo);
                return writer;
            };

            /**
             * Encodes the specified MsgErrorInfo message, length delimited. Does not implicitly {@link UIBot.Common.MsgErrorInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgErrorInfo
             * @static
             * @param {UIBot.Common.IMsgErrorInfo} message MsgErrorInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgErrorInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgErrorInfo message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgErrorInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgErrorInfo} MsgErrorInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgErrorInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgErrorInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.errorID = reader.int32();
                            break;
                        }
                    case 2: {
                            message.errorInfo = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("errorID"))
                    throw $util.ProtocolError("missing required 'errorID'", { instance: message });
                return message;
            };

            /**
             * Decodes a MsgErrorInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgErrorInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgErrorInfo} MsgErrorInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgErrorInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgErrorInfo message.
             * @function verify
             * @memberof UIBot.Common.MsgErrorInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgErrorInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.errorID))
                    return "errorID: integer expected";
                if (message.errorInfo != null && message.hasOwnProperty("errorInfo"))
                    if (!$util.isString(message.errorInfo))
                        return "errorInfo: string expected";
                return null;
            };

            /**
             * Creates a MsgErrorInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgErrorInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgErrorInfo} MsgErrorInfo
             */
            MsgErrorInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgErrorInfo)
                    return object;
                var message = new $root.UIBot.Common.MsgErrorInfo();
                if (object.errorID != null)
                    message.errorID = object.errorID | 0;
                if (object.errorInfo != null)
                    message.errorInfo = String(object.errorInfo);
                return message;
            };

            /**
             * Creates a plain object from a MsgErrorInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgErrorInfo
             * @static
             * @param {UIBot.Common.MsgErrorInfo} message MsgErrorInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgErrorInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.errorID = 0;
                    object.errorInfo = "";
                }
                if (message.errorID != null && message.hasOwnProperty("errorID"))
                    object.errorID = message.errorID;
                if (message.errorInfo != null && message.hasOwnProperty("errorInfo"))
                    object.errorInfo = message.errorInfo;
                return object;
            };

            /**
             * Converts this MsgErrorInfo to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgErrorInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgErrorInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgErrorInfo
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgErrorInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgErrorInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgErrorInfo";
            };

            return MsgErrorInfo;
        })();

        Common.MessageSegResult = (function() {

            /**
             * Properties of a MessageSegResult.
             * @memberof UIBot.Common
             * @interface IMessageSegResult
             * @property {string|null} [seriesuid] MessageSegResult seriesuid
             * @property {number|null} [length] MessageSegResult length
             * @property {number|null} [count] MessageSegResult count
             * @property {Uint8Array|null} [data] MessageSegResult data
             */

            /**
             * Constructs a new MessageSegResult.
             * @memberof UIBot.Common
             * @classdesc Represents a MessageSegResult.
             * @implements IMessageSegResult
             * @constructor
             * @param {UIBot.Common.IMessageSegResult=} [properties] Properties to set
             */
            function MessageSegResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageSegResult seriesuid.
             * @member {string} seriesuid
             * @memberof UIBot.Common.MessageSegResult
             * @instance
             */
            MessageSegResult.prototype.seriesuid = "";

            /**
             * MessageSegResult length.
             * @member {number} length
             * @memberof UIBot.Common.MessageSegResult
             * @instance
             */
            MessageSegResult.prototype.length = 0;

            /**
             * MessageSegResult count.
             * @member {number} count
             * @memberof UIBot.Common.MessageSegResult
             * @instance
             */
            MessageSegResult.prototype.count = 0;

            /**
             * MessageSegResult data.
             * @member {Uint8Array} data
             * @memberof UIBot.Common.MessageSegResult
             * @instance
             */
            MessageSegResult.prototype.data = $util.newBuffer([]);

            /**
             * Creates a new MessageSegResult instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MessageSegResult
             * @static
             * @param {UIBot.Common.IMessageSegResult=} [properties] Properties to set
             * @returns {UIBot.Common.MessageSegResult} MessageSegResult instance
             */
            MessageSegResult.create = function create(properties) {
                return new MessageSegResult(properties);
            };

            /**
             * Encodes the specified MessageSegResult message. Does not implicitly {@link UIBot.Common.MessageSegResult.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MessageSegResult
             * @static
             * @param {UIBot.Common.IMessageSegResult} message MessageSegResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageSegResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seriesuid != null && Object.hasOwnProperty.call(message, "seriesuid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.seriesuid);
                if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.length);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.count);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);
                return writer;
            };

            /**
             * Encodes the specified MessageSegResult message, length delimited. Does not implicitly {@link UIBot.Common.MessageSegResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MessageSegResult
             * @static
             * @param {UIBot.Common.IMessageSegResult} message MessageSegResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageSegResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageSegResult message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MessageSegResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MessageSegResult} MessageSegResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageSegResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MessageSegResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.seriesuid = reader.string();
                            break;
                        }
                    case 2: {
                            message.length = reader.int32();
                            break;
                        }
                    case 3: {
                            message.count = reader.int32();
                            break;
                        }
                    case 4: {
                            message.data = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageSegResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MessageSegResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MessageSegResult} MessageSegResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageSegResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageSegResult message.
             * @function verify
             * @memberof UIBot.Common.MessageSegResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageSegResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seriesuid != null && message.hasOwnProperty("seriesuid"))
                    if (!$util.isString(message.seriesuid))
                        return "seriesuid: string expected";
                if (message.length != null && message.hasOwnProperty("length"))
                    if (!$util.isInteger(message.length))
                        return "length: integer expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                return null;
            };

            /**
             * Creates a MessageSegResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MessageSegResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MessageSegResult} MessageSegResult
             */
            MessageSegResult.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MessageSegResult)
                    return object;
                var message = new $root.UIBot.Common.MessageSegResult();
                if (object.seriesuid != null)
                    message.seriesuid = String(object.seriesuid);
                if (object.length != null)
                    message.length = object.length | 0;
                if (object.count != null)
                    message.count = object.count | 0;
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length >= 0)
                        message.data = object.data;
                return message;
            };

            /**
             * Creates a plain object from a MessageSegResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MessageSegResult
             * @static
             * @param {UIBot.Common.MessageSegResult} message MessageSegResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageSegResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.seriesuid = "";
                    object.length = 0;
                    object.count = 0;
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                }
                if (message.seriesuid != null && message.hasOwnProperty("seriesuid"))
                    object.seriesuid = message.seriesuid;
                if (message.length != null && message.hasOwnProperty("length"))
                    object.length = message.length;
                if (message.count != null && message.hasOwnProperty("count"))
                    object.count = message.count;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                return object;
            };

            /**
             * Converts this MessageSegResult to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MessageSegResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageSegResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MessageSegResult
             * @function getTypeUrl
             * @memberof UIBot.Common.MessageSegResult
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MessageSegResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MessageSegResult";
            };

            return MessageSegResult;
        })();

        Common.MsgMeshData = (function() {

            /**
             * Properties of a MsgMeshData.
             * @memberof UIBot.Common
             * @interface IMsgMeshData
             * @property {Array.<number>|null} [VertexPosition] MsgMeshData VertexPosition
             * @property {Array.<number>|null} [VertexNormal] MsgMeshData VertexNormal
             * @property {number} VertexNum MsgMeshData VertexNum
             * @property {boolean} HasValue MsgMeshData HasValue
             * @property {boolean} DataDirty MsgMeshData DataDirty
             * @property {Array.<number>|null} [VertexValue] MsgMeshData VertexValue
             * @property {Array.<number>|null} [VertexColor] MsgMeshData VertexColor
             * @property {Array.<number>|null} [VertexIndex] MsgMeshData VertexIndex
             * @property {number} VertexIndexNum MsgMeshData VertexIndexNum
             */

            /**
             * Constructs a new MsgMeshData.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgMeshData.
             * @implements IMsgMeshData
             * @constructor
             * @param {UIBot.Common.IMsgMeshData=} [properties] Properties to set
             */
            function MsgMeshData(properties) {
                this.VertexPosition = [];
                this.VertexNormal = [];
                this.VertexValue = [];
                this.VertexColor = [];
                this.VertexIndex = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgMeshData VertexPosition.
             * @member {Array.<number>} VertexPosition
             * @memberof UIBot.Common.MsgMeshData
             * @instance
             */
            MsgMeshData.prototype.VertexPosition = $util.emptyArray;

            /**
             * MsgMeshData VertexNormal.
             * @member {Array.<number>} VertexNormal
             * @memberof UIBot.Common.MsgMeshData
             * @instance
             */
            MsgMeshData.prototype.VertexNormal = $util.emptyArray;

            /**
             * MsgMeshData VertexNum.
             * @member {number} VertexNum
             * @memberof UIBot.Common.MsgMeshData
             * @instance
             */
            MsgMeshData.prototype.VertexNum = 0;

            /**
             * MsgMeshData HasValue.
             * @member {boolean} HasValue
             * @memberof UIBot.Common.MsgMeshData
             * @instance
             */
            MsgMeshData.prototype.HasValue = false;

            /**
             * MsgMeshData DataDirty.
             * @member {boolean} DataDirty
             * @memberof UIBot.Common.MsgMeshData
             * @instance
             */
            MsgMeshData.prototype.DataDirty = false;

            /**
             * MsgMeshData VertexValue.
             * @member {Array.<number>} VertexValue
             * @memberof UIBot.Common.MsgMeshData
             * @instance
             */
            MsgMeshData.prototype.VertexValue = $util.emptyArray;

            /**
             * MsgMeshData VertexColor.
             * @member {Array.<number>} VertexColor
             * @memberof UIBot.Common.MsgMeshData
             * @instance
             */
            MsgMeshData.prototype.VertexColor = $util.emptyArray;

            /**
             * MsgMeshData VertexIndex.
             * @member {Array.<number>} VertexIndex
             * @memberof UIBot.Common.MsgMeshData
             * @instance
             */
            MsgMeshData.prototype.VertexIndex = $util.emptyArray;

            /**
             * MsgMeshData VertexIndexNum.
             * @member {number} VertexIndexNum
             * @memberof UIBot.Common.MsgMeshData
             * @instance
             */
            MsgMeshData.prototype.VertexIndexNum = 0;

            /**
             * Creates a new MsgMeshData instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgMeshData
             * @static
             * @param {UIBot.Common.IMsgMeshData=} [properties] Properties to set
             * @returns {UIBot.Common.MsgMeshData} MsgMeshData instance
             */
            MsgMeshData.create = function create(properties) {
                return new MsgMeshData(properties);
            };

            /**
             * Encodes the specified MsgMeshData message. Does not implicitly {@link UIBot.Common.MsgMeshData.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgMeshData
             * @static
             * @param {UIBot.Common.IMsgMeshData} message MsgMeshData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgMeshData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.VertexPosition != null && message.VertexPosition.length)
                    for (var i = 0; i < message.VertexPosition.length; ++i)
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.VertexPosition[i]);
                if (message.VertexNormal != null && message.VertexNormal.length)
                    for (var i = 0; i < message.VertexNormal.length; ++i)
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.VertexNormal[i]);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.VertexNum);
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.HasValue);
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.DataDirty);
                if (message.VertexValue != null && message.VertexValue.length)
                    for (var i = 0; i < message.VertexValue.length; ++i)
                        writer.uint32(/* id 6, wireType 5 =*/53).float(message.VertexValue[i]);
                if (message.VertexColor != null && message.VertexColor.length)
                    for (var i = 0; i < message.VertexColor.length; ++i)
                        writer.uint32(/* id 7, wireType 5 =*/61).float(message.VertexColor[i]);
                if (message.VertexIndex != null && message.VertexIndex.length)
                    for (var i = 0; i < message.VertexIndex.length; ++i)
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.VertexIndex[i]);
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.VertexIndexNum);
                return writer;
            };

            /**
             * Encodes the specified MsgMeshData message, length delimited. Does not implicitly {@link UIBot.Common.MsgMeshData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgMeshData
             * @static
             * @param {UIBot.Common.IMsgMeshData} message MsgMeshData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgMeshData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgMeshData message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgMeshData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgMeshData} MsgMeshData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgMeshData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgMeshData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.VertexPosition && message.VertexPosition.length))
                                message.VertexPosition = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.VertexPosition.push(reader.float());
                            } else
                                message.VertexPosition.push(reader.float());
                            break;
                        }
                    case 2: {
                            if (!(message.VertexNormal && message.VertexNormal.length))
                                message.VertexNormal = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.VertexNormal.push(reader.float());
                            } else
                                message.VertexNormal.push(reader.float());
                            break;
                        }
                    case 3: {
                            message.VertexNum = reader.int32();
                            break;
                        }
                    case 4: {
                            message.HasValue = reader.bool();
                            break;
                        }
                    case 5: {
                            message.DataDirty = reader.bool();
                            break;
                        }
                    case 6: {
                            if (!(message.VertexValue && message.VertexValue.length))
                                message.VertexValue = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.VertexValue.push(reader.float());
                            } else
                                message.VertexValue.push(reader.float());
                            break;
                        }
                    case 7: {
                            if (!(message.VertexColor && message.VertexColor.length))
                                message.VertexColor = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.VertexColor.push(reader.float());
                            } else
                                message.VertexColor.push(reader.float());
                            break;
                        }
                    case 8: {
                            if (!(message.VertexIndex && message.VertexIndex.length))
                                message.VertexIndex = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.VertexIndex.push(reader.int32());
                            } else
                                message.VertexIndex.push(reader.int32());
                            break;
                        }
                    case 9: {
                            message.VertexIndexNum = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("VertexNum"))
                    throw $util.ProtocolError("missing required 'VertexNum'", { instance: message });
                if (!message.hasOwnProperty("HasValue"))
                    throw $util.ProtocolError("missing required 'HasValue'", { instance: message });
                if (!message.hasOwnProperty("DataDirty"))
                    throw $util.ProtocolError("missing required 'DataDirty'", { instance: message });
                if (!message.hasOwnProperty("VertexIndexNum"))
                    throw $util.ProtocolError("missing required 'VertexIndexNum'", { instance: message });
                return message;
            };

            /**
             * Decodes a MsgMeshData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgMeshData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgMeshData} MsgMeshData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgMeshData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgMeshData message.
             * @function verify
             * @memberof UIBot.Common.MsgMeshData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgMeshData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.VertexPosition != null && message.hasOwnProperty("VertexPosition")) {
                    if (!Array.isArray(message.VertexPosition))
                        return "VertexPosition: array expected";
                    for (var i = 0; i < message.VertexPosition.length; ++i)
                        if (typeof message.VertexPosition[i] !== "number")
                            return "VertexPosition: number[] expected";
                }
                if (message.VertexNormal != null && message.hasOwnProperty("VertexNormal")) {
                    if (!Array.isArray(message.VertexNormal))
                        return "VertexNormal: array expected";
                    for (var i = 0; i < message.VertexNormal.length; ++i)
                        if (typeof message.VertexNormal[i] !== "number")
                            return "VertexNormal: number[] expected";
                }
                if (!$util.isInteger(message.VertexNum))
                    return "VertexNum: integer expected";
                if (typeof message.HasValue !== "boolean")
                    return "HasValue: boolean expected";
                if (typeof message.DataDirty !== "boolean")
                    return "DataDirty: boolean expected";
                if (message.VertexValue != null && message.hasOwnProperty("VertexValue")) {
                    if (!Array.isArray(message.VertexValue))
                        return "VertexValue: array expected";
                    for (var i = 0; i < message.VertexValue.length; ++i)
                        if (typeof message.VertexValue[i] !== "number")
                            return "VertexValue: number[] expected";
                }
                if (message.VertexColor != null && message.hasOwnProperty("VertexColor")) {
                    if (!Array.isArray(message.VertexColor))
                        return "VertexColor: array expected";
                    for (var i = 0; i < message.VertexColor.length; ++i)
                        if (typeof message.VertexColor[i] !== "number")
                            return "VertexColor: number[] expected";
                }
                if (message.VertexIndex != null && message.hasOwnProperty("VertexIndex")) {
                    if (!Array.isArray(message.VertexIndex))
                        return "VertexIndex: array expected";
                    for (var i = 0; i < message.VertexIndex.length; ++i)
                        if (!$util.isInteger(message.VertexIndex[i]))
                            return "VertexIndex: integer[] expected";
                }
                if (!$util.isInteger(message.VertexIndexNum))
                    return "VertexIndexNum: integer expected";
                return null;
            };

            /**
             * Creates a MsgMeshData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgMeshData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgMeshData} MsgMeshData
             */
            MsgMeshData.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgMeshData)
                    return object;
                var message = new $root.UIBot.Common.MsgMeshData();
                if (object.VertexPosition) {
                    if (!Array.isArray(object.VertexPosition))
                        throw TypeError(".UIBot.Common.MsgMeshData.VertexPosition: array expected");
                    message.VertexPosition = [];
                    for (var i = 0; i < object.VertexPosition.length; ++i)
                        message.VertexPosition[i] = Number(object.VertexPosition[i]);
                }
                if (object.VertexNormal) {
                    if (!Array.isArray(object.VertexNormal))
                        throw TypeError(".UIBot.Common.MsgMeshData.VertexNormal: array expected");
                    message.VertexNormal = [];
                    for (var i = 0; i < object.VertexNormal.length; ++i)
                        message.VertexNormal[i] = Number(object.VertexNormal[i]);
                }
                if (object.VertexNum != null)
                    message.VertexNum = object.VertexNum | 0;
                if (object.HasValue != null)
                    message.HasValue = Boolean(object.HasValue);
                if (object.DataDirty != null)
                    message.DataDirty = Boolean(object.DataDirty);
                if (object.VertexValue) {
                    if (!Array.isArray(object.VertexValue))
                        throw TypeError(".UIBot.Common.MsgMeshData.VertexValue: array expected");
                    message.VertexValue = [];
                    for (var i = 0; i < object.VertexValue.length; ++i)
                        message.VertexValue[i] = Number(object.VertexValue[i]);
                }
                if (object.VertexColor) {
                    if (!Array.isArray(object.VertexColor))
                        throw TypeError(".UIBot.Common.MsgMeshData.VertexColor: array expected");
                    message.VertexColor = [];
                    for (var i = 0; i < object.VertexColor.length; ++i)
                        message.VertexColor[i] = Number(object.VertexColor[i]);
                }
                if (object.VertexIndex) {
                    if (!Array.isArray(object.VertexIndex))
                        throw TypeError(".UIBot.Common.MsgMeshData.VertexIndex: array expected");
                    message.VertexIndex = [];
                    for (var i = 0; i < object.VertexIndex.length; ++i)
                        message.VertexIndex[i] = object.VertexIndex[i] | 0;
                }
                if (object.VertexIndexNum != null)
                    message.VertexIndexNum = object.VertexIndexNum | 0;
                return message;
            };

            /**
             * Creates a plain object from a MsgMeshData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgMeshData
             * @static
             * @param {UIBot.Common.MsgMeshData} message MsgMeshData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgMeshData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.VertexPosition = [];
                    object.VertexNormal = [];
                    object.VertexValue = [];
                    object.VertexColor = [];
                    object.VertexIndex = [];
                }
                if (options.defaults) {
                    object.VertexNum = 0;
                    object.HasValue = false;
                    object.DataDirty = false;
                    object.VertexIndexNum = 0;
                }
                if (message.VertexPosition && message.VertexPosition.length) {
                    object.VertexPosition = [];
                    for (var j = 0; j < message.VertexPosition.length; ++j)
                        object.VertexPosition[j] = options.json && !isFinite(message.VertexPosition[j]) ? String(message.VertexPosition[j]) : message.VertexPosition[j];
                }
                if (message.VertexNormal && message.VertexNormal.length) {
                    object.VertexNormal = [];
                    for (var j = 0; j < message.VertexNormal.length; ++j)
                        object.VertexNormal[j] = options.json && !isFinite(message.VertexNormal[j]) ? String(message.VertexNormal[j]) : message.VertexNormal[j];
                }
                if (message.VertexNum != null && message.hasOwnProperty("VertexNum"))
                    object.VertexNum = message.VertexNum;
                if (message.HasValue != null && message.hasOwnProperty("HasValue"))
                    object.HasValue = message.HasValue;
                if (message.DataDirty != null && message.hasOwnProperty("DataDirty"))
                    object.DataDirty = message.DataDirty;
                if (message.VertexValue && message.VertexValue.length) {
                    object.VertexValue = [];
                    for (var j = 0; j < message.VertexValue.length; ++j)
                        object.VertexValue[j] = options.json && !isFinite(message.VertexValue[j]) ? String(message.VertexValue[j]) : message.VertexValue[j];
                }
                if (message.VertexColor && message.VertexColor.length) {
                    object.VertexColor = [];
                    for (var j = 0; j < message.VertexColor.length; ++j)
                        object.VertexColor[j] = options.json && !isFinite(message.VertexColor[j]) ? String(message.VertexColor[j]) : message.VertexColor[j];
                }
                if (message.VertexIndex && message.VertexIndex.length) {
                    object.VertexIndex = [];
                    for (var j = 0; j < message.VertexIndex.length; ++j)
                        object.VertexIndex[j] = message.VertexIndex[j];
                }
                if (message.VertexIndexNum != null && message.hasOwnProperty("VertexIndexNum"))
                    object.VertexIndexNum = message.VertexIndexNum;
                return object;
            };

            /**
             * Converts this MsgMeshData to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgMeshData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgMeshData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgMeshData
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgMeshData
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgMeshData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgMeshData";
            };

            return MsgMeshData;
        })();

        Common.MsgUserCheck = (function() {

            /**
             * Properties of a MsgUserCheck.
             * @memberof UIBot.Common
             * @interface IMsgUserCheck
             * @property {string|null} [userName] MsgUserCheck userName
             * @property {string} password MsgUserCheck password
             */

            /**
             * Constructs a new MsgUserCheck.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgUserCheck.
             * @implements IMsgUserCheck
             * @constructor
             * @param {UIBot.Common.IMsgUserCheck=} [properties] Properties to set
             */
            function MsgUserCheck(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgUserCheck userName.
             * @member {string} userName
             * @memberof UIBot.Common.MsgUserCheck
             * @instance
             */
            MsgUserCheck.prototype.userName = "";

            /**
             * MsgUserCheck password.
             * @member {string} password
             * @memberof UIBot.Common.MsgUserCheck
             * @instance
             */
            MsgUserCheck.prototype.password = "";

            /**
             * Creates a new MsgUserCheck instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgUserCheck
             * @static
             * @param {UIBot.Common.IMsgUserCheck=} [properties] Properties to set
             * @returns {UIBot.Common.MsgUserCheck} MsgUserCheck instance
             */
            MsgUserCheck.create = function create(properties) {
                return new MsgUserCheck(properties);
            };

            /**
             * Encodes the specified MsgUserCheck message. Does not implicitly {@link UIBot.Common.MsgUserCheck.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgUserCheck
             * @static
             * @param {UIBot.Common.IMsgUserCheck} message MsgUserCheck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgUserCheck.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userName != null && Object.hasOwnProperty.call(message, "userName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.userName);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);
                return writer;
            };

            /**
             * Encodes the specified MsgUserCheck message, length delimited. Does not implicitly {@link UIBot.Common.MsgUserCheck.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgUserCheck
             * @static
             * @param {UIBot.Common.IMsgUserCheck} message MsgUserCheck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgUserCheck.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgUserCheck message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgUserCheck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgUserCheck} MsgUserCheck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgUserCheck.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgUserCheck();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.userName = reader.string();
                            break;
                        }
                    case 2: {
                            message.password = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("password"))
                    throw $util.ProtocolError("missing required 'password'", { instance: message });
                return message;
            };

            /**
             * Decodes a MsgUserCheck message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgUserCheck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgUserCheck} MsgUserCheck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgUserCheck.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgUserCheck message.
             * @function verify
             * @memberof UIBot.Common.MsgUserCheck
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgUserCheck.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userName != null && message.hasOwnProperty("userName"))
                    if (!$util.isString(message.userName))
                        return "userName: string expected";
                if (!$util.isString(message.password))
                    return "password: string expected";
                return null;
            };

            /**
             * Creates a MsgUserCheck message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgUserCheck
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgUserCheck} MsgUserCheck
             */
            MsgUserCheck.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgUserCheck)
                    return object;
                var message = new $root.UIBot.Common.MsgUserCheck();
                if (object.userName != null)
                    message.userName = String(object.userName);
                if (object.password != null)
                    message.password = String(object.password);
                return message;
            };

            /**
             * Creates a plain object from a MsgUserCheck message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgUserCheck
             * @static
             * @param {UIBot.Common.MsgUserCheck} message MsgUserCheck
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgUserCheck.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.userName = "";
                    object.password = "";
                }
                if (message.userName != null && message.hasOwnProperty("userName"))
                    object.userName = message.userName;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                return object;
            };

            /**
             * Converts this MsgUserCheck to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgUserCheck
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgUserCheck.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgUserCheck
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgUserCheck
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgUserCheck.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgUserCheck";
            };

            return MsgUserCheck;
        })();

        Common.MsgAcpcParameterInfo = (function() {

            /**
             * Properties of a MsgAcpcParameterInfo.
             * @memberof UIBot.Common
             * @interface IMsgAcpcParameterInfo
             * @property {number|null} [AcpcDistance] MsgAcpcParameterInfo AcpcDistance
             * @property {number|null} [LateralLeftDistance] MsgAcpcParameterInfo LateralLeftDistance
             * @property {number|null} [LateralLeftRatio] MsgAcpcParameterInfo LateralLeftRatio
             * @property {number|null} [AnterioiDistance] MsgAcpcParameterInfo AnterioiDistance
             * @property {number|null} [AnterioiRatio] MsgAcpcParameterInfo AnterioiRatio
             * @property {number|null} [InferiorDistance] MsgAcpcParameterInfo InferiorDistance
             * @property {number|null} [InferiorRatio] MsgAcpcParameterInfo InferiorRatio
             * @property {number|null} [LateralLeftAngle] MsgAcpcParameterInfo LateralLeftAngle
             * @property {number|null} [PosteriorAngle] MsgAcpcParameterInfo PosteriorAngle
             * @property {number|null} [TrajectoryLength] MsgAcpcParameterInfo TrajectoryLength
             * @property {boolean|null} [AcpcPointShowHide] MsgAcpcParameterInfo AcpcPointShowHide
             * @property {boolean|null} [IsLocked] MsgAcpcParameterInfo IsLocked
             */

            /**
             * Constructs a new MsgAcpcParameterInfo.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgAcpcParameterInfo.
             * @implements IMsgAcpcParameterInfo
             * @constructor
             * @param {UIBot.Common.IMsgAcpcParameterInfo=} [properties] Properties to set
             */
            function MsgAcpcParameterInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgAcpcParameterInfo AcpcDistance.
             * @member {number} AcpcDistance
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @instance
             */
            MsgAcpcParameterInfo.prototype.AcpcDistance = 0;

            /**
             * MsgAcpcParameterInfo LateralLeftDistance.
             * @member {number} LateralLeftDistance
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @instance
             */
            MsgAcpcParameterInfo.prototype.LateralLeftDistance = 0;

            /**
             * MsgAcpcParameterInfo LateralLeftRatio.
             * @member {number} LateralLeftRatio
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @instance
             */
            MsgAcpcParameterInfo.prototype.LateralLeftRatio = 0;

            /**
             * MsgAcpcParameterInfo AnterioiDistance.
             * @member {number} AnterioiDistance
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @instance
             */
            MsgAcpcParameterInfo.prototype.AnterioiDistance = 0;

            /**
             * MsgAcpcParameterInfo AnterioiRatio.
             * @member {number} AnterioiRatio
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @instance
             */
            MsgAcpcParameterInfo.prototype.AnterioiRatio = 0;

            /**
             * MsgAcpcParameterInfo InferiorDistance.
             * @member {number} InferiorDistance
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @instance
             */
            MsgAcpcParameterInfo.prototype.InferiorDistance = 0;

            /**
             * MsgAcpcParameterInfo InferiorRatio.
             * @member {number} InferiorRatio
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @instance
             */
            MsgAcpcParameterInfo.prototype.InferiorRatio = 0;

            /**
             * MsgAcpcParameterInfo LateralLeftAngle.
             * @member {number} LateralLeftAngle
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @instance
             */
            MsgAcpcParameterInfo.prototype.LateralLeftAngle = 0;

            /**
             * MsgAcpcParameterInfo PosteriorAngle.
             * @member {number} PosteriorAngle
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @instance
             */
            MsgAcpcParameterInfo.prototype.PosteriorAngle = 0;

            /**
             * MsgAcpcParameterInfo TrajectoryLength.
             * @member {number} TrajectoryLength
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @instance
             */
            MsgAcpcParameterInfo.prototype.TrajectoryLength = 0;

            /**
             * MsgAcpcParameterInfo AcpcPointShowHide.
             * @member {boolean} AcpcPointShowHide
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @instance
             */
            MsgAcpcParameterInfo.prototype.AcpcPointShowHide = false;

            /**
             * MsgAcpcParameterInfo IsLocked.
             * @member {boolean} IsLocked
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @instance
             */
            MsgAcpcParameterInfo.prototype.IsLocked = false;

            /**
             * Creates a new MsgAcpcParameterInfo instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @static
             * @param {UIBot.Common.IMsgAcpcParameterInfo=} [properties] Properties to set
             * @returns {UIBot.Common.MsgAcpcParameterInfo} MsgAcpcParameterInfo instance
             */
            MsgAcpcParameterInfo.create = function create(properties) {
                return new MsgAcpcParameterInfo(properties);
            };

            /**
             * Encodes the specified MsgAcpcParameterInfo message. Does not implicitly {@link UIBot.Common.MsgAcpcParameterInfo.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @static
             * @param {UIBot.Common.IMsgAcpcParameterInfo} message MsgAcpcParameterInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgAcpcParameterInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.AcpcDistance != null && Object.hasOwnProperty.call(message, "AcpcDistance"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.AcpcDistance);
                if (message.LateralLeftDistance != null && Object.hasOwnProperty.call(message, "LateralLeftDistance"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.LateralLeftDistance);
                if (message.LateralLeftRatio != null && Object.hasOwnProperty.call(message, "LateralLeftRatio"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.LateralLeftRatio);
                if (message.AnterioiDistance != null && Object.hasOwnProperty.call(message, "AnterioiDistance"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.AnterioiDistance);
                if (message.AnterioiRatio != null && Object.hasOwnProperty.call(message, "AnterioiRatio"))
                    writer.uint32(/* id 5, wireType 1 =*/41).double(message.AnterioiRatio);
                if (message.InferiorDistance != null && Object.hasOwnProperty.call(message, "InferiorDistance"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.InferiorDistance);
                if (message.InferiorRatio != null && Object.hasOwnProperty.call(message, "InferiorRatio"))
                    writer.uint32(/* id 7, wireType 1 =*/57).double(message.InferiorRatio);
                if (message.LateralLeftAngle != null && Object.hasOwnProperty.call(message, "LateralLeftAngle"))
                    writer.uint32(/* id 8, wireType 1 =*/65).double(message.LateralLeftAngle);
                if (message.PosteriorAngle != null && Object.hasOwnProperty.call(message, "PosteriorAngle"))
                    writer.uint32(/* id 9, wireType 1 =*/73).double(message.PosteriorAngle);
                if (message.TrajectoryLength != null && Object.hasOwnProperty.call(message, "TrajectoryLength"))
                    writer.uint32(/* id 10, wireType 1 =*/81).double(message.TrajectoryLength);
                if (message.AcpcPointShowHide != null && Object.hasOwnProperty.call(message, "AcpcPointShowHide"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.AcpcPointShowHide);
                if (message.IsLocked != null && Object.hasOwnProperty.call(message, "IsLocked"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.IsLocked);
                return writer;
            };

            /**
             * Encodes the specified MsgAcpcParameterInfo message, length delimited. Does not implicitly {@link UIBot.Common.MsgAcpcParameterInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @static
             * @param {UIBot.Common.IMsgAcpcParameterInfo} message MsgAcpcParameterInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgAcpcParameterInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgAcpcParameterInfo message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgAcpcParameterInfo} MsgAcpcParameterInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgAcpcParameterInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgAcpcParameterInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.AcpcDistance = reader.double();
                            break;
                        }
                    case 2: {
                            message.LateralLeftDistance = reader.double();
                            break;
                        }
                    case 3: {
                            message.LateralLeftRatio = reader.double();
                            break;
                        }
                    case 4: {
                            message.AnterioiDistance = reader.double();
                            break;
                        }
                    case 5: {
                            message.AnterioiRatio = reader.double();
                            break;
                        }
                    case 6: {
                            message.InferiorDistance = reader.double();
                            break;
                        }
                    case 7: {
                            message.InferiorRatio = reader.double();
                            break;
                        }
                    case 8: {
                            message.LateralLeftAngle = reader.double();
                            break;
                        }
                    case 9: {
                            message.PosteriorAngle = reader.double();
                            break;
                        }
                    case 10: {
                            message.TrajectoryLength = reader.double();
                            break;
                        }
                    case 11: {
                            message.AcpcPointShowHide = reader.bool();
                            break;
                        }
                    case 12: {
                            message.IsLocked = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgAcpcParameterInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgAcpcParameterInfo} MsgAcpcParameterInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgAcpcParameterInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgAcpcParameterInfo message.
             * @function verify
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgAcpcParameterInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.AcpcDistance != null && message.hasOwnProperty("AcpcDistance"))
                    if (typeof message.AcpcDistance !== "number")
                        return "AcpcDistance: number expected";
                if (message.LateralLeftDistance != null && message.hasOwnProperty("LateralLeftDistance"))
                    if (typeof message.LateralLeftDistance !== "number")
                        return "LateralLeftDistance: number expected";
                if (message.LateralLeftRatio != null && message.hasOwnProperty("LateralLeftRatio"))
                    if (typeof message.LateralLeftRatio !== "number")
                        return "LateralLeftRatio: number expected";
                if (message.AnterioiDistance != null && message.hasOwnProperty("AnterioiDistance"))
                    if (typeof message.AnterioiDistance !== "number")
                        return "AnterioiDistance: number expected";
                if (message.AnterioiRatio != null && message.hasOwnProperty("AnterioiRatio"))
                    if (typeof message.AnterioiRatio !== "number")
                        return "AnterioiRatio: number expected";
                if (message.InferiorDistance != null && message.hasOwnProperty("InferiorDistance"))
                    if (typeof message.InferiorDistance !== "number")
                        return "InferiorDistance: number expected";
                if (message.InferiorRatio != null && message.hasOwnProperty("InferiorRatio"))
                    if (typeof message.InferiorRatio !== "number")
                        return "InferiorRatio: number expected";
                if (message.LateralLeftAngle != null && message.hasOwnProperty("LateralLeftAngle"))
                    if (typeof message.LateralLeftAngle !== "number")
                        return "LateralLeftAngle: number expected";
                if (message.PosteriorAngle != null && message.hasOwnProperty("PosteriorAngle"))
                    if (typeof message.PosteriorAngle !== "number")
                        return "PosteriorAngle: number expected";
                if (message.TrajectoryLength != null && message.hasOwnProperty("TrajectoryLength"))
                    if (typeof message.TrajectoryLength !== "number")
                        return "TrajectoryLength: number expected";
                if (message.AcpcPointShowHide != null && message.hasOwnProperty("AcpcPointShowHide"))
                    if (typeof message.AcpcPointShowHide !== "boolean")
                        return "AcpcPointShowHide: boolean expected";
                if (message.IsLocked != null && message.hasOwnProperty("IsLocked"))
                    if (typeof message.IsLocked !== "boolean")
                        return "IsLocked: boolean expected";
                return null;
            };

            /**
             * Creates a MsgAcpcParameterInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgAcpcParameterInfo} MsgAcpcParameterInfo
             */
            MsgAcpcParameterInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgAcpcParameterInfo)
                    return object;
                var message = new $root.UIBot.Common.MsgAcpcParameterInfo();
                if (object.AcpcDistance != null)
                    message.AcpcDistance = Number(object.AcpcDistance);
                if (object.LateralLeftDistance != null)
                    message.LateralLeftDistance = Number(object.LateralLeftDistance);
                if (object.LateralLeftRatio != null)
                    message.LateralLeftRatio = Number(object.LateralLeftRatio);
                if (object.AnterioiDistance != null)
                    message.AnterioiDistance = Number(object.AnterioiDistance);
                if (object.AnterioiRatio != null)
                    message.AnterioiRatio = Number(object.AnterioiRatio);
                if (object.InferiorDistance != null)
                    message.InferiorDistance = Number(object.InferiorDistance);
                if (object.InferiorRatio != null)
                    message.InferiorRatio = Number(object.InferiorRatio);
                if (object.LateralLeftAngle != null)
                    message.LateralLeftAngle = Number(object.LateralLeftAngle);
                if (object.PosteriorAngle != null)
                    message.PosteriorAngle = Number(object.PosteriorAngle);
                if (object.TrajectoryLength != null)
                    message.TrajectoryLength = Number(object.TrajectoryLength);
                if (object.AcpcPointShowHide != null)
                    message.AcpcPointShowHide = Boolean(object.AcpcPointShowHide);
                if (object.IsLocked != null)
                    message.IsLocked = Boolean(object.IsLocked);
                return message;
            };

            /**
             * Creates a plain object from a MsgAcpcParameterInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @static
             * @param {UIBot.Common.MsgAcpcParameterInfo} message MsgAcpcParameterInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgAcpcParameterInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.AcpcDistance = 0;
                    object.LateralLeftDistance = 0;
                    object.LateralLeftRatio = 0;
                    object.AnterioiDistance = 0;
                    object.AnterioiRatio = 0;
                    object.InferiorDistance = 0;
                    object.InferiorRatio = 0;
                    object.LateralLeftAngle = 0;
                    object.PosteriorAngle = 0;
                    object.TrajectoryLength = 0;
                    object.AcpcPointShowHide = false;
                    object.IsLocked = false;
                }
                if (message.AcpcDistance != null && message.hasOwnProperty("AcpcDistance"))
                    object.AcpcDistance = options.json && !isFinite(message.AcpcDistance) ? String(message.AcpcDistance) : message.AcpcDistance;
                if (message.LateralLeftDistance != null && message.hasOwnProperty("LateralLeftDistance"))
                    object.LateralLeftDistance = options.json && !isFinite(message.LateralLeftDistance) ? String(message.LateralLeftDistance) : message.LateralLeftDistance;
                if (message.LateralLeftRatio != null && message.hasOwnProperty("LateralLeftRatio"))
                    object.LateralLeftRatio = options.json && !isFinite(message.LateralLeftRatio) ? String(message.LateralLeftRatio) : message.LateralLeftRatio;
                if (message.AnterioiDistance != null && message.hasOwnProperty("AnterioiDistance"))
                    object.AnterioiDistance = options.json && !isFinite(message.AnterioiDistance) ? String(message.AnterioiDistance) : message.AnterioiDistance;
                if (message.AnterioiRatio != null && message.hasOwnProperty("AnterioiRatio"))
                    object.AnterioiRatio = options.json && !isFinite(message.AnterioiRatio) ? String(message.AnterioiRatio) : message.AnterioiRatio;
                if (message.InferiorDistance != null && message.hasOwnProperty("InferiorDistance"))
                    object.InferiorDistance = options.json && !isFinite(message.InferiorDistance) ? String(message.InferiorDistance) : message.InferiorDistance;
                if (message.InferiorRatio != null && message.hasOwnProperty("InferiorRatio"))
                    object.InferiorRatio = options.json && !isFinite(message.InferiorRatio) ? String(message.InferiorRatio) : message.InferiorRatio;
                if (message.LateralLeftAngle != null && message.hasOwnProperty("LateralLeftAngle"))
                    object.LateralLeftAngle = options.json && !isFinite(message.LateralLeftAngle) ? String(message.LateralLeftAngle) : message.LateralLeftAngle;
                if (message.PosteriorAngle != null && message.hasOwnProperty("PosteriorAngle"))
                    object.PosteriorAngle = options.json && !isFinite(message.PosteriorAngle) ? String(message.PosteriorAngle) : message.PosteriorAngle;
                if (message.TrajectoryLength != null && message.hasOwnProperty("TrajectoryLength"))
                    object.TrajectoryLength = options.json && !isFinite(message.TrajectoryLength) ? String(message.TrajectoryLength) : message.TrajectoryLength;
                if (message.AcpcPointShowHide != null && message.hasOwnProperty("AcpcPointShowHide"))
                    object.AcpcPointShowHide = message.AcpcPointShowHide;
                if (message.IsLocked != null && message.hasOwnProperty("IsLocked"))
                    object.IsLocked = message.IsLocked;
                return object;
            };

            /**
             * Converts this MsgAcpcParameterInfo to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgAcpcParameterInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgAcpcParameterInfo
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgAcpcParameterInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgAcpcParameterInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgAcpcParameterInfo";
            };

            return MsgAcpcParameterInfo;
        })();

        Common.MsgColor = (function() {

            /**
             * Properties of a MsgColor.
             * @memberof UIBot.Common
             * @interface IMsgColor
             * @property {number} red MsgColor red
             * @property {number} green MsgColor green
             * @property {number} blue MsgColor blue
             * @property {number} alpha MsgColor alpha
             */

            /**
             * Constructs a new MsgColor.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgColor.
             * @implements IMsgColor
             * @constructor
             * @param {UIBot.Common.IMsgColor=} [properties] Properties to set
             */
            function MsgColor(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgColor red.
             * @member {number} red
             * @memberof UIBot.Common.MsgColor
             * @instance
             */
            MsgColor.prototype.red = 0;

            /**
             * MsgColor green.
             * @member {number} green
             * @memberof UIBot.Common.MsgColor
             * @instance
             */
            MsgColor.prototype.green = 0;

            /**
             * MsgColor blue.
             * @member {number} blue
             * @memberof UIBot.Common.MsgColor
             * @instance
             */
            MsgColor.prototype.blue = 0;

            /**
             * MsgColor alpha.
             * @member {number} alpha
             * @memberof UIBot.Common.MsgColor
             * @instance
             */
            MsgColor.prototype.alpha = 0;

            /**
             * Creates a new MsgColor instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgColor
             * @static
             * @param {UIBot.Common.IMsgColor=} [properties] Properties to set
             * @returns {UIBot.Common.MsgColor} MsgColor instance
             */
            MsgColor.create = function create(properties) {
                return new MsgColor(properties);
            };

            /**
             * Encodes the specified MsgColor message. Does not implicitly {@link UIBot.Common.MsgColor.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgColor
             * @static
             * @param {UIBot.Common.IMsgColor} message MsgColor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgColor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.red);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.green);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.blue);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.alpha);
                return writer;
            };

            /**
             * Encodes the specified MsgColor message, length delimited. Does not implicitly {@link UIBot.Common.MsgColor.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgColor
             * @static
             * @param {UIBot.Common.IMsgColor} message MsgColor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgColor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgColor message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgColor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgColor} MsgColor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgColor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgColor();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.red = reader.int32();
                            break;
                        }
                    case 2: {
                            message.green = reader.int32();
                            break;
                        }
                    case 3: {
                            message.blue = reader.int32();
                            break;
                        }
                    case 4: {
                            message.alpha = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("red"))
                    throw $util.ProtocolError("missing required 'red'", { instance: message });
                if (!message.hasOwnProperty("green"))
                    throw $util.ProtocolError("missing required 'green'", { instance: message });
                if (!message.hasOwnProperty("blue"))
                    throw $util.ProtocolError("missing required 'blue'", { instance: message });
                if (!message.hasOwnProperty("alpha"))
                    throw $util.ProtocolError("missing required 'alpha'", { instance: message });
                return message;
            };

            /**
             * Decodes a MsgColor message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgColor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgColor} MsgColor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgColor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgColor message.
             * @function verify
             * @memberof UIBot.Common.MsgColor
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgColor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.red))
                    return "red: integer expected";
                if (!$util.isInteger(message.green))
                    return "green: integer expected";
                if (!$util.isInteger(message.blue))
                    return "blue: integer expected";
                if (!$util.isInteger(message.alpha))
                    return "alpha: integer expected";
                return null;
            };

            /**
             * Creates a MsgColor message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgColor
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgColor} MsgColor
             */
            MsgColor.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgColor)
                    return object;
                var message = new $root.UIBot.Common.MsgColor();
                if (object.red != null)
                    message.red = object.red | 0;
                if (object.green != null)
                    message.green = object.green | 0;
                if (object.blue != null)
                    message.blue = object.blue | 0;
                if (object.alpha != null)
                    message.alpha = object.alpha | 0;
                return message;
            };

            /**
             * Creates a plain object from a MsgColor message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgColor
             * @static
             * @param {UIBot.Common.MsgColor} message MsgColor
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgColor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.red = 0;
                    object.green = 0;
                    object.blue = 0;
                    object.alpha = 0;
                }
                if (message.red != null && message.hasOwnProperty("red"))
                    object.red = message.red;
                if (message.green != null && message.hasOwnProperty("green"))
                    object.green = message.green;
                if (message.blue != null && message.hasOwnProperty("blue"))
                    object.blue = message.blue;
                if (message.alpha != null && message.hasOwnProperty("alpha"))
                    object.alpha = message.alpha;
                return object;
            };

            /**
             * Converts this MsgColor to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgColor
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgColor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgColor
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgColor
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgColor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgColor";
            };

            return MsgColor;
        })();

        Common.Msg3DPoint = (function() {

            /**
             * Properties of a Msg3DPoint.
             * @memberof UIBot.Common
             * @interface IMsg3DPoint
             * @property {number} x Msg3DPoint x
             * @property {number} y Msg3DPoint y
             * @property {number} z Msg3DPoint z
             */

            /**
             * Constructs a new Msg3DPoint.
             * @memberof UIBot.Common
             * @classdesc Represents a Msg3DPoint.
             * @implements IMsg3DPoint
             * @constructor
             * @param {UIBot.Common.IMsg3DPoint=} [properties] Properties to set
             */
            function Msg3DPoint(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Msg3DPoint x.
             * @member {number} x
             * @memberof UIBot.Common.Msg3DPoint
             * @instance
             */
            Msg3DPoint.prototype.x = 0;

            /**
             * Msg3DPoint y.
             * @member {number} y
             * @memberof UIBot.Common.Msg3DPoint
             * @instance
             */
            Msg3DPoint.prototype.y = 0;

            /**
             * Msg3DPoint z.
             * @member {number} z
             * @memberof UIBot.Common.Msg3DPoint
             * @instance
             */
            Msg3DPoint.prototype.z = 0;

            /**
             * Creates a new Msg3DPoint instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.Msg3DPoint
             * @static
             * @param {UIBot.Common.IMsg3DPoint=} [properties] Properties to set
             * @returns {UIBot.Common.Msg3DPoint} Msg3DPoint instance
             */
            Msg3DPoint.create = function create(properties) {
                return new Msg3DPoint(properties);
            };

            /**
             * Encodes the specified Msg3DPoint message. Does not implicitly {@link UIBot.Common.Msg3DPoint.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.Msg3DPoint
             * @static
             * @param {UIBot.Common.IMsg3DPoint} message Msg3DPoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Msg3DPoint.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.x);
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.y);
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.z);
                return writer;
            };

            /**
             * Encodes the specified Msg3DPoint message, length delimited. Does not implicitly {@link UIBot.Common.Msg3DPoint.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.Msg3DPoint
             * @static
             * @param {UIBot.Common.IMsg3DPoint} message Msg3DPoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Msg3DPoint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Msg3DPoint message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.Msg3DPoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.Msg3DPoint} Msg3DPoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Msg3DPoint.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.Msg3DPoint();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.x = reader.double();
                            break;
                        }
                    case 2: {
                            message.y = reader.double();
                            break;
                        }
                    case 3: {
                            message.z = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("x"))
                    throw $util.ProtocolError("missing required 'x'", { instance: message });
                if (!message.hasOwnProperty("y"))
                    throw $util.ProtocolError("missing required 'y'", { instance: message });
                if (!message.hasOwnProperty("z"))
                    throw $util.ProtocolError("missing required 'z'", { instance: message });
                return message;
            };

            /**
             * Decodes a Msg3DPoint message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.Msg3DPoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.Msg3DPoint} Msg3DPoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Msg3DPoint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Msg3DPoint message.
             * @function verify
             * @memberof UIBot.Common.Msg3DPoint
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Msg3DPoint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (typeof message.x !== "number")
                    return "x: number expected";
                if (typeof message.y !== "number")
                    return "y: number expected";
                if (typeof message.z !== "number")
                    return "z: number expected";
                return null;
            };

            /**
             * Creates a Msg3DPoint message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.Msg3DPoint
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.Msg3DPoint} Msg3DPoint
             */
            Msg3DPoint.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.Msg3DPoint)
                    return object;
                var message = new $root.UIBot.Common.Msg3DPoint();
                if (object.x != null)
                    message.x = Number(object.x);
                if (object.y != null)
                    message.y = Number(object.y);
                if (object.z != null)
                    message.z = Number(object.z);
                return message;
            };

            /**
             * Creates a plain object from a Msg3DPoint message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.Msg3DPoint
             * @static
             * @param {UIBot.Common.Msg3DPoint} message Msg3DPoint
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Msg3DPoint.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.x = 0;
                    object.y = 0;
                    object.z = 0;
                }
                if (message.x != null && message.hasOwnProperty("x"))
                    object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
                if (message.y != null && message.hasOwnProperty("y"))
                    object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
                if (message.z != null && message.hasOwnProperty("z"))
                    object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
                return object;
            };

            /**
             * Converts this Msg3DPoint to JSON.
             * @function toJSON
             * @memberof UIBot.Common.Msg3DPoint
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Msg3DPoint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Msg3DPoint
             * @function getTypeUrl
             * @memberof UIBot.Common.Msg3DPoint
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Msg3DPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.Msg3DPoint";
            };

            return Msg3DPoint;
        })();

        Common.MsgLineStrip = (function() {

            /**
             * Properties of a MsgLineStrip.
             * @memberof UIBot.Common
             * @interface IMsgLineStrip
             * @property {Array.<UIBot.Common.IMsg3DPoint>|null} [LineStrip] MsgLineStrip LineStrip
             */

            /**
             * Constructs a new MsgLineStrip.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgLineStrip.
             * @implements IMsgLineStrip
             * @constructor
             * @param {UIBot.Common.IMsgLineStrip=} [properties] Properties to set
             */
            function MsgLineStrip(properties) {
                this.LineStrip = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgLineStrip LineStrip.
             * @member {Array.<UIBot.Common.IMsg3DPoint>} LineStrip
             * @memberof UIBot.Common.MsgLineStrip
             * @instance
             */
            MsgLineStrip.prototype.LineStrip = $util.emptyArray;

            /**
             * Creates a new MsgLineStrip instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgLineStrip
             * @static
             * @param {UIBot.Common.IMsgLineStrip=} [properties] Properties to set
             * @returns {UIBot.Common.MsgLineStrip} MsgLineStrip instance
             */
            MsgLineStrip.create = function create(properties) {
                return new MsgLineStrip(properties);
            };

            /**
             * Encodes the specified MsgLineStrip message. Does not implicitly {@link UIBot.Common.MsgLineStrip.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgLineStrip
             * @static
             * @param {UIBot.Common.IMsgLineStrip} message MsgLineStrip message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgLineStrip.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.LineStrip != null && message.LineStrip.length)
                    for (var i = 0; i < message.LineStrip.length; ++i)
                        $root.UIBot.Common.Msg3DPoint.encode(message.LineStrip[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MsgLineStrip message, length delimited. Does not implicitly {@link UIBot.Common.MsgLineStrip.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgLineStrip
             * @static
             * @param {UIBot.Common.IMsgLineStrip} message MsgLineStrip message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgLineStrip.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgLineStrip message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgLineStrip
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgLineStrip} MsgLineStrip
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgLineStrip.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgLineStrip();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.LineStrip && message.LineStrip.length))
                                message.LineStrip = [];
                            message.LineStrip.push($root.UIBot.Common.Msg3DPoint.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgLineStrip message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgLineStrip
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgLineStrip} MsgLineStrip
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgLineStrip.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgLineStrip message.
             * @function verify
             * @memberof UIBot.Common.MsgLineStrip
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgLineStrip.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.LineStrip != null && message.hasOwnProperty("LineStrip")) {
                    if (!Array.isArray(message.LineStrip))
                        return "LineStrip: array expected";
                    for (var i = 0; i < message.LineStrip.length; ++i) {
                        var error = $root.UIBot.Common.Msg3DPoint.verify(message.LineStrip[i]);
                        if (error)
                            return "LineStrip." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MsgLineStrip message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgLineStrip
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgLineStrip} MsgLineStrip
             */
            MsgLineStrip.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgLineStrip)
                    return object;
                var message = new $root.UIBot.Common.MsgLineStrip();
                if (object.LineStrip) {
                    if (!Array.isArray(object.LineStrip))
                        throw TypeError(".UIBot.Common.MsgLineStrip.LineStrip: array expected");
                    message.LineStrip = [];
                    for (var i = 0; i < object.LineStrip.length; ++i) {
                        if (typeof object.LineStrip[i] !== "object")
                            throw TypeError(".UIBot.Common.MsgLineStrip.LineStrip: object expected");
                        message.LineStrip[i] = $root.UIBot.Common.Msg3DPoint.fromObject(object.LineStrip[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MsgLineStrip message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgLineStrip
             * @static
             * @param {UIBot.Common.MsgLineStrip} message MsgLineStrip
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgLineStrip.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.LineStrip = [];
                if (message.LineStrip && message.LineStrip.length) {
                    object.LineStrip = [];
                    for (var j = 0; j < message.LineStrip.length; ++j)
                        object.LineStrip[j] = $root.UIBot.Common.Msg3DPoint.toObject(message.LineStrip[j], options);
                }
                return object;
            };

            /**
             * Converts this MsgLineStrip to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgLineStrip
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgLineStrip.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgLineStrip
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgLineStrip
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgLineStrip.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgLineStrip";
            };

            return MsgLineStrip;
        })();

        Common.MsgFiberItem = (function() {

            /**
             * Properties of a MsgFiberItem.
             * @memberof UIBot.Common
             * @interface IMsgFiberItem
             * @property {number} index MsgFiberItem index
             * @property {string|null} [name] MsgFiberItem name
             * @property {string|null} [refVolUid] MsgFiberItem refVolUid
             * @property {boolean|null} [isVisible] MsgFiberItem isVisible
             * @property {boolean|null} [isSelected] MsgFiberItem isSelected
             * @property {boolean|null} [isUseFacolor] MsgFiberItem isUseFacolor
             * @property {UIBot.Common.IMsgColor|null} [pureColor] MsgFiberItem pureColor
             * @property {Array.<UIBot.Common.IMsgLineStrip>|null} [fiberValue] MsgFiberItem fiberValue
             * @property {UIBot.Common.IMsgFiberPara|null} [fiberPara] MsgFiberItem fiberPara
             */

            /**
             * Constructs a new MsgFiberItem.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgFiberItem.
             * @implements IMsgFiberItem
             * @constructor
             * @param {UIBot.Common.IMsgFiberItem=} [properties] Properties to set
             */
            function MsgFiberItem(properties) {
                this.fiberValue = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgFiberItem index.
             * @member {number} index
             * @memberof UIBot.Common.MsgFiberItem
             * @instance
             */
            MsgFiberItem.prototype.index = 0;

            /**
             * MsgFiberItem name.
             * @member {string} name
             * @memberof UIBot.Common.MsgFiberItem
             * @instance
             */
            MsgFiberItem.prototype.name = "";

            /**
             * MsgFiberItem refVolUid.
             * @member {string} refVolUid
             * @memberof UIBot.Common.MsgFiberItem
             * @instance
             */
            MsgFiberItem.prototype.refVolUid = "";

            /**
             * MsgFiberItem isVisible.
             * @member {boolean} isVisible
             * @memberof UIBot.Common.MsgFiberItem
             * @instance
             */
            MsgFiberItem.prototype.isVisible = false;

            /**
             * MsgFiberItem isSelected.
             * @member {boolean} isSelected
             * @memberof UIBot.Common.MsgFiberItem
             * @instance
             */
            MsgFiberItem.prototype.isSelected = false;

            /**
             * MsgFiberItem isUseFacolor.
             * @member {boolean} isUseFacolor
             * @memberof UIBot.Common.MsgFiberItem
             * @instance
             */
            MsgFiberItem.prototype.isUseFacolor = false;

            /**
             * MsgFiberItem pureColor.
             * @member {UIBot.Common.IMsgColor|null|undefined} pureColor
             * @memberof UIBot.Common.MsgFiberItem
             * @instance
             */
            MsgFiberItem.prototype.pureColor = null;

            /**
             * MsgFiberItem fiberValue.
             * @member {Array.<UIBot.Common.IMsgLineStrip>} fiberValue
             * @memberof UIBot.Common.MsgFiberItem
             * @instance
             */
            MsgFiberItem.prototype.fiberValue = $util.emptyArray;

            /**
             * MsgFiberItem fiberPara.
             * @member {UIBot.Common.IMsgFiberPara|null|undefined} fiberPara
             * @memberof UIBot.Common.MsgFiberItem
             * @instance
             */
            MsgFiberItem.prototype.fiberPara = null;

            /**
             * Creates a new MsgFiberItem instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgFiberItem
             * @static
             * @param {UIBot.Common.IMsgFiberItem=} [properties] Properties to set
             * @returns {UIBot.Common.MsgFiberItem} MsgFiberItem instance
             */
            MsgFiberItem.create = function create(properties) {
                return new MsgFiberItem(properties);
            };

            /**
             * Encodes the specified MsgFiberItem message. Does not implicitly {@link UIBot.Common.MsgFiberItem.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgFiberItem
             * @static
             * @param {UIBot.Common.IMsgFiberItem} message MsgFiberItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgFiberItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.refVolUid != null && Object.hasOwnProperty.call(message, "refVolUid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.refVolUid);
                if (message.isVisible != null && Object.hasOwnProperty.call(message, "isVisible"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isVisible);
                if (message.isSelected != null && Object.hasOwnProperty.call(message, "isSelected"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isSelected);
                if (message.isUseFacolor != null && Object.hasOwnProperty.call(message, "isUseFacolor"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isUseFacolor);
                if (message.pureColor != null && Object.hasOwnProperty.call(message, "pureColor"))
                    $root.UIBot.Common.MsgColor.encode(message.pureColor, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.fiberValue != null && message.fiberValue.length)
                    for (var i = 0; i < message.fiberValue.length; ++i)
                        $root.UIBot.Common.MsgLineStrip.encode(message.fiberValue[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.fiberPara != null && Object.hasOwnProperty.call(message, "fiberPara"))
                    $root.UIBot.Common.MsgFiberPara.encode(message.fiberPara, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MsgFiberItem message, length delimited. Does not implicitly {@link UIBot.Common.MsgFiberItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgFiberItem
             * @static
             * @param {UIBot.Common.IMsgFiberItem} message MsgFiberItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgFiberItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgFiberItem message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgFiberItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgFiberItem} MsgFiberItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgFiberItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgFiberItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.index = reader.int32();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            message.refVolUid = reader.string();
                            break;
                        }
                    case 4: {
                            message.isVisible = reader.bool();
                            break;
                        }
                    case 5: {
                            message.isSelected = reader.bool();
                            break;
                        }
                    case 6: {
                            message.isUseFacolor = reader.bool();
                            break;
                        }
                    case 7: {
                            message.pureColor = $root.UIBot.Common.MsgColor.decode(reader, reader.uint32());
                            break;
                        }
                    case 8: {
                            if (!(message.fiberValue && message.fiberValue.length))
                                message.fiberValue = [];
                            message.fiberValue.push($root.UIBot.Common.MsgLineStrip.decode(reader, reader.uint32()));
                            break;
                        }
                    case 9: {
                            message.fiberPara = $root.UIBot.Common.MsgFiberPara.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("index"))
                    throw $util.ProtocolError("missing required 'index'", { instance: message });
                return message;
            };

            /**
             * Decodes a MsgFiberItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgFiberItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgFiberItem} MsgFiberItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgFiberItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgFiberItem message.
             * @function verify
             * @memberof UIBot.Common.MsgFiberItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgFiberItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.refVolUid != null && message.hasOwnProperty("refVolUid"))
                    if (!$util.isString(message.refVolUid))
                        return "refVolUid: string expected";
                if (message.isVisible != null && message.hasOwnProperty("isVisible"))
                    if (typeof message.isVisible !== "boolean")
                        return "isVisible: boolean expected";
                if (message.isSelected != null && message.hasOwnProperty("isSelected"))
                    if (typeof message.isSelected !== "boolean")
                        return "isSelected: boolean expected";
                if (message.isUseFacolor != null && message.hasOwnProperty("isUseFacolor"))
                    if (typeof message.isUseFacolor !== "boolean")
                        return "isUseFacolor: boolean expected";
                if (message.pureColor != null && message.hasOwnProperty("pureColor")) {
                    var error = $root.UIBot.Common.MsgColor.verify(message.pureColor);
                    if (error)
                        return "pureColor." + error;
                }
                if (message.fiberValue != null && message.hasOwnProperty("fiberValue")) {
                    if (!Array.isArray(message.fiberValue))
                        return "fiberValue: array expected";
                    for (var i = 0; i < message.fiberValue.length; ++i) {
                        var error = $root.UIBot.Common.MsgLineStrip.verify(message.fiberValue[i]);
                        if (error)
                            return "fiberValue." + error;
                    }
                }
                if (message.fiberPara != null && message.hasOwnProperty("fiberPara")) {
                    var error = $root.UIBot.Common.MsgFiberPara.verify(message.fiberPara);
                    if (error)
                        return "fiberPara." + error;
                }
                return null;
            };

            /**
             * Creates a MsgFiberItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgFiberItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgFiberItem} MsgFiberItem
             */
            MsgFiberItem.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgFiberItem)
                    return object;
                var message = new $root.UIBot.Common.MsgFiberItem();
                if (object.index != null)
                    message.index = object.index | 0;
                if (object.name != null)
                    message.name = String(object.name);
                if (object.refVolUid != null)
                    message.refVolUid = String(object.refVolUid);
                if (object.isVisible != null)
                    message.isVisible = Boolean(object.isVisible);
                if (object.isSelected != null)
                    message.isSelected = Boolean(object.isSelected);
                if (object.isUseFacolor != null)
                    message.isUseFacolor = Boolean(object.isUseFacolor);
                if (object.pureColor != null) {
                    if (typeof object.pureColor !== "object")
                        throw TypeError(".UIBot.Common.MsgFiberItem.pureColor: object expected");
                    message.pureColor = $root.UIBot.Common.MsgColor.fromObject(object.pureColor);
                }
                if (object.fiberValue) {
                    if (!Array.isArray(object.fiberValue))
                        throw TypeError(".UIBot.Common.MsgFiberItem.fiberValue: array expected");
                    message.fiberValue = [];
                    for (var i = 0; i < object.fiberValue.length; ++i) {
                        if (typeof object.fiberValue[i] !== "object")
                            throw TypeError(".UIBot.Common.MsgFiberItem.fiberValue: object expected");
                        message.fiberValue[i] = $root.UIBot.Common.MsgLineStrip.fromObject(object.fiberValue[i]);
                    }
                }
                if (object.fiberPara != null) {
                    if (typeof object.fiberPara !== "object")
                        throw TypeError(".UIBot.Common.MsgFiberItem.fiberPara: object expected");
                    message.fiberPara = $root.UIBot.Common.MsgFiberPara.fromObject(object.fiberPara);
                }
                return message;
            };

            /**
             * Creates a plain object from a MsgFiberItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgFiberItem
             * @static
             * @param {UIBot.Common.MsgFiberItem} message MsgFiberItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgFiberItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.fiberValue = [];
                if (options.defaults) {
                    object.index = 0;
                    object.name = "";
                    object.refVolUid = "";
                    object.isVisible = false;
                    object.isSelected = false;
                    object.isUseFacolor = false;
                    object.pureColor = null;
                    object.fiberPara = null;
                }
                if (message.index != null && message.hasOwnProperty("index"))
                    object.index = message.index;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.refVolUid != null && message.hasOwnProperty("refVolUid"))
                    object.refVolUid = message.refVolUid;
                if (message.isVisible != null && message.hasOwnProperty("isVisible"))
                    object.isVisible = message.isVisible;
                if (message.isSelected != null && message.hasOwnProperty("isSelected"))
                    object.isSelected = message.isSelected;
                if (message.isUseFacolor != null && message.hasOwnProperty("isUseFacolor"))
                    object.isUseFacolor = message.isUseFacolor;
                if (message.pureColor != null && message.hasOwnProperty("pureColor"))
                    object.pureColor = $root.UIBot.Common.MsgColor.toObject(message.pureColor, options);
                if (message.fiberValue && message.fiberValue.length) {
                    object.fiberValue = [];
                    for (var j = 0; j < message.fiberValue.length; ++j)
                        object.fiberValue[j] = $root.UIBot.Common.MsgLineStrip.toObject(message.fiberValue[j], options);
                }
                if (message.fiberPara != null && message.hasOwnProperty("fiberPara"))
                    object.fiberPara = $root.UIBot.Common.MsgFiberPara.toObject(message.fiberPara, options);
                return object;
            };

            /**
             * Converts this MsgFiberItem to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgFiberItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgFiberItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgFiberItem
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgFiberItem
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgFiberItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgFiberItem";
            };

            return MsgFiberItem;
        })();

        Common.MsgFiberPara = (function() {

            /**
             * Properties of a MsgFiberPara.
             * @memberof UIBot.Common
             * @interface IMsgFiberPara
             * @property {number|null} [renderLengthLimit] MsgFiberPara renderLengthLimit
             * @property {number|null} [tubeRadius] MsgFiberPara tubeRadius
             * @property {number|null} [renderStrategy] MsgFiberPara renderStrategy
             * @property {number|null} [colorStrategy] MsgFiberPara colorStrategy
             * @property {string|null} [lutName] MsgFiberPara lutName
             * @property {UIBot.Common.IMsgColor|null} [pureColor] MsgFiberPara pureColor
             * @property {Array.<UIBot.Common.IMsgColor>|null} [colorList] MsgFiberPara colorList
             */

            /**
             * Constructs a new MsgFiberPara.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgFiberPara.
             * @implements IMsgFiberPara
             * @constructor
             * @param {UIBot.Common.IMsgFiberPara=} [properties] Properties to set
             */
            function MsgFiberPara(properties) {
                this.colorList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgFiberPara renderLengthLimit.
             * @member {number} renderLengthLimit
             * @memberof UIBot.Common.MsgFiberPara
             * @instance
             */
            MsgFiberPara.prototype.renderLengthLimit = 0;

            /**
             * MsgFiberPara tubeRadius.
             * @member {number} tubeRadius
             * @memberof UIBot.Common.MsgFiberPara
             * @instance
             */
            MsgFiberPara.prototype.tubeRadius = 0;

            /**
             * MsgFiberPara renderStrategy.
             * @member {number} renderStrategy
             * @memberof UIBot.Common.MsgFiberPara
             * @instance
             */
            MsgFiberPara.prototype.renderStrategy = 0;

            /**
             * MsgFiberPara colorStrategy.
             * @member {number} colorStrategy
             * @memberof UIBot.Common.MsgFiberPara
             * @instance
             */
            MsgFiberPara.prototype.colorStrategy = 0;

            /**
             * MsgFiberPara lutName.
             * @member {string} lutName
             * @memberof UIBot.Common.MsgFiberPara
             * @instance
             */
            MsgFiberPara.prototype.lutName = "";

            /**
             * MsgFiberPara pureColor.
             * @member {UIBot.Common.IMsgColor|null|undefined} pureColor
             * @memberof UIBot.Common.MsgFiberPara
             * @instance
             */
            MsgFiberPara.prototype.pureColor = null;

            /**
             * MsgFiberPara colorList.
             * @member {Array.<UIBot.Common.IMsgColor>} colorList
             * @memberof UIBot.Common.MsgFiberPara
             * @instance
             */
            MsgFiberPara.prototype.colorList = $util.emptyArray;

            /**
             * Creates a new MsgFiberPara instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgFiberPara
             * @static
             * @param {UIBot.Common.IMsgFiberPara=} [properties] Properties to set
             * @returns {UIBot.Common.MsgFiberPara} MsgFiberPara instance
             */
            MsgFiberPara.create = function create(properties) {
                return new MsgFiberPara(properties);
            };

            /**
             * Encodes the specified MsgFiberPara message. Does not implicitly {@link UIBot.Common.MsgFiberPara.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgFiberPara
             * @static
             * @param {UIBot.Common.IMsgFiberPara} message MsgFiberPara message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgFiberPara.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.renderLengthLimit != null && Object.hasOwnProperty.call(message, "renderLengthLimit"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.renderLengthLimit);
                if (message.tubeRadius != null && Object.hasOwnProperty.call(message, "tubeRadius"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.tubeRadius);
                if (message.renderStrategy != null && Object.hasOwnProperty.call(message, "renderStrategy"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.renderStrategy);
                if (message.colorStrategy != null && Object.hasOwnProperty.call(message, "colorStrategy"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.colorStrategy);
                if (message.lutName != null && Object.hasOwnProperty.call(message, "lutName"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.lutName);
                if (message.pureColor != null && Object.hasOwnProperty.call(message, "pureColor"))
                    $root.UIBot.Common.MsgColor.encode(message.pureColor, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.colorList != null && message.colorList.length)
                    for (var i = 0; i < message.colorList.length; ++i)
                        $root.UIBot.Common.MsgColor.encode(message.colorList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MsgFiberPara message, length delimited. Does not implicitly {@link UIBot.Common.MsgFiberPara.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgFiberPara
             * @static
             * @param {UIBot.Common.IMsgFiberPara} message MsgFiberPara message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgFiberPara.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgFiberPara message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgFiberPara
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgFiberPara} MsgFiberPara
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgFiberPara.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgFiberPara();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.renderLengthLimit = reader.double();
                            break;
                        }
                    case 2: {
                            message.tubeRadius = reader.double();
                            break;
                        }
                    case 3: {
                            message.renderStrategy = reader.int32();
                            break;
                        }
                    case 4: {
                            message.colorStrategy = reader.int32();
                            break;
                        }
                    case 5: {
                            message.lutName = reader.string();
                            break;
                        }
                    case 6: {
                            message.pureColor = $root.UIBot.Common.MsgColor.decode(reader, reader.uint32());
                            break;
                        }
                    case 7: {
                            if (!(message.colorList && message.colorList.length))
                                message.colorList = [];
                            message.colorList.push($root.UIBot.Common.MsgColor.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgFiberPara message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgFiberPara
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgFiberPara} MsgFiberPara
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgFiberPara.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgFiberPara message.
             * @function verify
             * @memberof UIBot.Common.MsgFiberPara
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgFiberPara.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.renderLengthLimit != null && message.hasOwnProperty("renderLengthLimit"))
                    if (typeof message.renderLengthLimit !== "number")
                        return "renderLengthLimit: number expected";
                if (message.tubeRadius != null && message.hasOwnProperty("tubeRadius"))
                    if (typeof message.tubeRadius !== "number")
                        return "tubeRadius: number expected";
                if (message.renderStrategy != null && message.hasOwnProperty("renderStrategy"))
                    if (!$util.isInteger(message.renderStrategy))
                        return "renderStrategy: integer expected";
                if (message.colorStrategy != null && message.hasOwnProperty("colorStrategy"))
                    if (!$util.isInteger(message.colorStrategy))
                        return "colorStrategy: integer expected";
                if (message.lutName != null && message.hasOwnProperty("lutName"))
                    if (!$util.isString(message.lutName))
                        return "lutName: string expected";
                if (message.pureColor != null && message.hasOwnProperty("pureColor")) {
                    var error = $root.UIBot.Common.MsgColor.verify(message.pureColor);
                    if (error)
                        return "pureColor." + error;
                }
                if (message.colorList != null && message.hasOwnProperty("colorList")) {
                    if (!Array.isArray(message.colorList))
                        return "colorList: array expected";
                    for (var i = 0; i < message.colorList.length; ++i) {
                        var error = $root.UIBot.Common.MsgColor.verify(message.colorList[i]);
                        if (error)
                            return "colorList." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MsgFiberPara message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgFiberPara
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgFiberPara} MsgFiberPara
             */
            MsgFiberPara.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgFiberPara)
                    return object;
                var message = new $root.UIBot.Common.MsgFiberPara();
                if (object.renderLengthLimit != null)
                    message.renderLengthLimit = Number(object.renderLengthLimit);
                if (object.tubeRadius != null)
                    message.tubeRadius = Number(object.tubeRadius);
                if (object.renderStrategy != null)
                    message.renderStrategy = object.renderStrategy | 0;
                if (object.colorStrategy != null)
                    message.colorStrategy = object.colorStrategy | 0;
                if (object.lutName != null)
                    message.lutName = String(object.lutName);
                if (object.pureColor != null) {
                    if (typeof object.pureColor !== "object")
                        throw TypeError(".UIBot.Common.MsgFiberPara.pureColor: object expected");
                    message.pureColor = $root.UIBot.Common.MsgColor.fromObject(object.pureColor);
                }
                if (object.colorList) {
                    if (!Array.isArray(object.colorList))
                        throw TypeError(".UIBot.Common.MsgFiberPara.colorList: array expected");
                    message.colorList = [];
                    for (var i = 0; i < object.colorList.length; ++i) {
                        if (typeof object.colorList[i] !== "object")
                            throw TypeError(".UIBot.Common.MsgFiberPara.colorList: object expected");
                        message.colorList[i] = $root.UIBot.Common.MsgColor.fromObject(object.colorList[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MsgFiberPara message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgFiberPara
             * @static
             * @param {UIBot.Common.MsgFiberPara} message MsgFiberPara
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgFiberPara.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.colorList = [];
                if (options.defaults) {
                    object.renderLengthLimit = 0;
                    object.tubeRadius = 0;
                    object.renderStrategy = 0;
                    object.colorStrategy = 0;
                    object.lutName = "";
                    object.pureColor = null;
                }
                if (message.renderLengthLimit != null && message.hasOwnProperty("renderLengthLimit"))
                    object.renderLengthLimit = options.json && !isFinite(message.renderLengthLimit) ? String(message.renderLengthLimit) : message.renderLengthLimit;
                if (message.tubeRadius != null && message.hasOwnProperty("tubeRadius"))
                    object.tubeRadius = options.json && !isFinite(message.tubeRadius) ? String(message.tubeRadius) : message.tubeRadius;
                if (message.renderStrategy != null && message.hasOwnProperty("renderStrategy"))
                    object.renderStrategy = message.renderStrategy;
                if (message.colorStrategy != null && message.hasOwnProperty("colorStrategy"))
                    object.colorStrategy = message.colorStrategy;
                if (message.lutName != null && message.hasOwnProperty("lutName"))
                    object.lutName = message.lutName;
                if (message.pureColor != null && message.hasOwnProperty("pureColor"))
                    object.pureColor = $root.UIBot.Common.MsgColor.toObject(message.pureColor, options);
                if (message.colorList && message.colorList.length) {
                    object.colorList = [];
                    for (var j = 0; j < message.colorList.length; ++j)
                        object.colorList[j] = $root.UIBot.Common.MsgColor.toObject(message.colorList[j], options);
                }
                return object;
            };

            /**
             * Converts this MsgFiberPara to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgFiberPara
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgFiberPara.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgFiberPara
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgFiberPara
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgFiberPara.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgFiberPara";
            };

            return MsgFiberPara;
        })();

        Common.MsgFiberList = (function() {

            /**
             * Properties of a MsgFiberList.
             * @memberof UIBot.Common
             * @interface IMsgFiberList
             * @property {Array.<UIBot.Common.IMsgFiberItem>|null} [fibers] MsgFiberList fibers
             */

            /**
             * Constructs a new MsgFiberList.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgFiberList.
             * @implements IMsgFiberList
             * @constructor
             * @param {UIBot.Common.IMsgFiberList=} [properties] Properties to set
             */
            function MsgFiberList(properties) {
                this.fibers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgFiberList fibers.
             * @member {Array.<UIBot.Common.IMsgFiberItem>} fibers
             * @memberof UIBot.Common.MsgFiberList
             * @instance
             */
            MsgFiberList.prototype.fibers = $util.emptyArray;

            /**
             * Creates a new MsgFiberList instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgFiberList
             * @static
             * @param {UIBot.Common.IMsgFiberList=} [properties] Properties to set
             * @returns {UIBot.Common.MsgFiberList} MsgFiberList instance
             */
            MsgFiberList.create = function create(properties) {
                return new MsgFiberList(properties);
            };

            /**
             * Encodes the specified MsgFiberList message. Does not implicitly {@link UIBot.Common.MsgFiberList.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgFiberList
             * @static
             * @param {UIBot.Common.IMsgFiberList} message MsgFiberList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgFiberList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fibers != null && message.fibers.length)
                    for (var i = 0; i < message.fibers.length; ++i)
                        $root.UIBot.Common.MsgFiberItem.encode(message.fibers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MsgFiberList message, length delimited. Does not implicitly {@link UIBot.Common.MsgFiberList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgFiberList
             * @static
             * @param {UIBot.Common.IMsgFiberList} message MsgFiberList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgFiberList.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgFiberList message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgFiberList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgFiberList} MsgFiberList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgFiberList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgFiberList();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.fibers && message.fibers.length))
                                message.fibers = [];
                            message.fibers.push($root.UIBot.Common.MsgFiberItem.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgFiberList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgFiberList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgFiberList} MsgFiberList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgFiberList.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgFiberList message.
             * @function verify
             * @memberof UIBot.Common.MsgFiberList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgFiberList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fibers != null && message.hasOwnProperty("fibers")) {
                    if (!Array.isArray(message.fibers))
                        return "fibers: array expected";
                    for (var i = 0; i < message.fibers.length; ++i) {
                        var error = $root.UIBot.Common.MsgFiberItem.verify(message.fibers[i]);
                        if (error)
                            return "fibers." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MsgFiberList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgFiberList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgFiberList} MsgFiberList
             */
            MsgFiberList.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgFiberList)
                    return object;
                var message = new $root.UIBot.Common.MsgFiberList();
                if (object.fibers) {
                    if (!Array.isArray(object.fibers))
                        throw TypeError(".UIBot.Common.MsgFiberList.fibers: array expected");
                    message.fibers = [];
                    for (var i = 0; i < object.fibers.length; ++i) {
                        if (typeof object.fibers[i] !== "object")
                            throw TypeError(".UIBot.Common.MsgFiberList.fibers: object expected");
                        message.fibers[i] = $root.UIBot.Common.MsgFiberItem.fromObject(object.fibers[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MsgFiberList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgFiberList
             * @static
             * @param {UIBot.Common.MsgFiberList} message MsgFiberList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgFiberList.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.fibers = [];
                if (message.fibers && message.fibers.length) {
                    object.fibers = [];
                    for (var j = 0; j < message.fibers.length; ++j)
                        object.fibers[j] = $root.UIBot.Common.MsgFiberItem.toObject(message.fibers[j], options);
                }
                return object;
            };

            /**
             * Converts this MsgFiberList to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgFiberList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgFiberList.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgFiberList
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgFiberList
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgFiberList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgFiberList";
            };

            return MsgFiberList;
        })();

        Common.MsgFiberOper = (function() {

            /**
             * Properties of a MsgFiberOper.
             * @memberof UIBot.Common
             * @interface IMsgFiberOper
             * @property {string} changeType MsgFiberOper changeType
             * @property {Uint8Array|null} [changeValue] MsgFiberOper changeValue
             * @property {number|null} [changeIndex] MsgFiberOper changeIndex
             */

            /**
             * Constructs a new MsgFiberOper.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgFiberOper.
             * @implements IMsgFiberOper
             * @constructor
             * @param {UIBot.Common.IMsgFiberOper=} [properties] Properties to set
             */
            function MsgFiberOper(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgFiberOper changeType.
             * @member {string} changeType
             * @memberof UIBot.Common.MsgFiberOper
             * @instance
             */
            MsgFiberOper.prototype.changeType = "";

            /**
             * MsgFiberOper changeValue.
             * @member {Uint8Array} changeValue
             * @memberof UIBot.Common.MsgFiberOper
             * @instance
             */
            MsgFiberOper.prototype.changeValue = $util.newBuffer([]);

            /**
             * MsgFiberOper changeIndex.
             * @member {number} changeIndex
             * @memberof UIBot.Common.MsgFiberOper
             * @instance
             */
            MsgFiberOper.prototype.changeIndex = 0;

            /**
             * Creates a new MsgFiberOper instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgFiberOper
             * @static
             * @param {UIBot.Common.IMsgFiberOper=} [properties] Properties to set
             * @returns {UIBot.Common.MsgFiberOper} MsgFiberOper instance
             */
            MsgFiberOper.create = function create(properties) {
                return new MsgFiberOper(properties);
            };

            /**
             * Encodes the specified MsgFiberOper message. Does not implicitly {@link UIBot.Common.MsgFiberOper.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgFiberOper
             * @static
             * @param {UIBot.Common.IMsgFiberOper} message MsgFiberOper message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgFiberOper.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.changeType);
                if (message.changeValue != null && Object.hasOwnProperty.call(message, "changeValue"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.changeValue);
                if (message.changeIndex != null && Object.hasOwnProperty.call(message, "changeIndex"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.changeIndex);
                return writer;
            };

            /**
             * Encodes the specified MsgFiberOper message, length delimited. Does not implicitly {@link UIBot.Common.MsgFiberOper.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgFiberOper
             * @static
             * @param {UIBot.Common.IMsgFiberOper} message MsgFiberOper message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgFiberOper.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgFiberOper message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgFiberOper
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgFiberOper} MsgFiberOper
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgFiberOper.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgFiberOper();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.changeType = reader.string();
                            break;
                        }
                    case 2: {
                            message.changeValue = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.changeIndex = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("changeType"))
                    throw $util.ProtocolError("missing required 'changeType'", { instance: message });
                return message;
            };

            /**
             * Decodes a MsgFiberOper message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgFiberOper
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgFiberOper} MsgFiberOper
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgFiberOper.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgFiberOper message.
             * @function verify
             * @memberof UIBot.Common.MsgFiberOper
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgFiberOper.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.changeType))
                    return "changeType: string expected";
                if (message.changeValue != null && message.hasOwnProperty("changeValue"))
                    if (!(message.changeValue && typeof message.changeValue.length === "number" || $util.isString(message.changeValue)))
                        return "changeValue: buffer expected";
                if (message.changeIndex != null && message.hasOwnProperty("changeIndex"))
                    if (!$util.isInteger(message.changeIndex))
                        return "changeIndex: integer expected";
                return null;
            };

            /**
             * Creates a MsgFiberOper message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgFiberOper
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgFiberOper} MsgFiberOper
             */
            MsgFiberOper.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgFiberOper)
                    return object;
                var message = new $root.UIBot.Common.MsgFiberOper();
                if (object.changeType != null)
                    message.changeType = String(object.changeType);
                if (object.changeValue != null)
                    if (typeof object.changeValue === "string")
                        $util.base64.decode(object.changeValue, message.changeValue = $util.newBuffer($util.base64.length(object.changeValue)), 0);
                    else if (object.changeValue.length >= 0)
                        message.changeValue = object.changeValue;
                if (object.changeIndex != null)
                    message.changeIndex = object.changeIndex | 0;
                return message;
            };

            /**
             * Creates a plain object from a MsgFiberOper message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgFiberOper
             * @static
             * @param {UIBot.Common.MsgFiberOper} message MsgFiberOper
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgFiberOper.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.changeType = "";
                    if (options.bytes === String)
                        object.changeValue = "";
                    else {
                        object.changeValue = [];
                        if (options.bytes !== Array)
                            object.changeValue = $util.newBuffer(object.changeValue);
                    }
                    object.changeIndex = 0;
                }
                if (message.changeType != null && message.hasOwnProperty("changeType"))
                    object.changeType = message.changeType;
                if (message.changeValue != null && message.hasOwnProperty("changeValue"))
                    object.changeValue = options.bytes === String ? $util.base64.encode(message.changeValue, 0, message.changeValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.changeValue) : message.changeValue;
                if (message.changeIndex != null && message.hasOwnProperty("changeIndex"))
                    object.changeIndex = message.changeIndex;
                return object;
            };

            /**
             * Converts this MsgFiberOper to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgFiberOper
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgFiberOper.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgFiberOper
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgFiberOper
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgFiberOper.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgFiberOper";
            };

            return MsgFiberOper;
        })();

        Common.StatisticResult = (function() {

            /**
             * Properties of a StatisticResult.
             * @memberof UIBot.Common
             * @interface IStatisticResult
             * @property {number|null} [elemCount] StatisticResult elemCount
             * @property {number|null} [volume] StatisticResult volume
             * @property {number|null} [mean] StatisticResult mean
             * @property {number|null} [staticMax] StatisticResult staticMax
             * @property {number|null} [staticMin] StatisticResult staticMin
             * @property {number|null} [staticStd] StatisticResult staticStd
             * @property {number|null} [maxX] StatisticResult maxX
             * @property {number|null} [maxY] StatisticResult maxY
             * @property {number|null} [maxZ] StatisticResult maxZ
             * @property {number|null} [sliceLocation] StatisticResult sliceLocation
             * @property {number|null} [peak] StatisticResult peak
             * @property {string|null} [rulerUnit] StatisticResult rulerUnit
             * @property {string|null} [valueUnit] StatisticResult valueUnit
             */

            /**
             * Constructs a new StatisticResult.
             * @memberof UIBot.Common
             * @classdesc Represents a StatisticResult.
             * @implements IStatisticResult
             * @constructor
             * @param {UIBot.Common.IStatisticResult=} [properties] Properties to set
             */
            function StatisticResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StatisticResult elemCount.
             * @member {number} elemCount
             * @memberof UIBot.Common.StatisticResult
             * @instance
             */
            StatisticResult.prototype.elemCount = 0;

            /**
             * StatisticResult volume.
             * @member {number} volume
             * @memberof UIBot.Common.StatisticResult
             * @instance
             */
            StatisticResult.prototype.volume = 0;

            /**
             * StatisticResult mean.
             * @member {number} mean
             * @memberof UIBot.Common.StatisticResult
             * @instance
             */
            StatisticResult.prototype.mean = 0;

            /**
             * StatisticResult staticMax.
             * @member {number} staticMax
             * @memberof UIBot.Common.StatisticResult
             * @instance
             */
            StatisticResult.prototype.staticMax = 0;

            /**
             * StatisticResult staticMin.
             * @member {number} staticMin
             * @memberof UIBot.Common.StatisticResult
             * @instance
             */
            StatisticResult.prototype.staticMin = 0;

            /**
             * StatisticResult staticStd.
             * @member {number} staticStd
             * @memberof UIBot.Common.StatisticResult
             * @instance
             */
            StatisticResult.prototype.staticStd = 0;

            /**
             * StatisticResult maxX.
             * @member {number} maxX
             * @memberof UIBot.Common.StatisticResult
             * @instance
             */
            StatisticResult.prototype.maxX = 0;

            /**
             * StatisticResult maxY.
             * @member {number} maxY
             * @memberof UIBot.Common.StatisticResult
             * @instance
             */
            StatisticResult.prototype.maxY = 0;

            /**
             * StatisticResult maxZ.
             * @member {number} maxZ
             * @memberof UIBot.Common.StatisticResult
             * @instance
             */
            StatisticResult.prototype.maxZ = 0;

            /**
             * StatisticResult sliceLocation.
             * @member {number} sliceLocation
             * @memberof UIBot.Common.StatisticResult
             * @instance
             */
            StatisticResult.prototype.sliceLocation = 0;

            /**
             * StatisticResult peak.
             * @member {number} peak
             * @memberof UIBot.Common.StatisticResult
             * @instance
             */
            StatisticResult.prototype.peak = 0;

            /**
             * StatisticResult rulerUnit.
             * @member {string} rulerUnit
             * @memberof UIBot.Common.StatisticResult
             * @instance
             */
            StatisticResult.prototype.rulerUnit = "";

            /**
             * StatisticResult valueUnit.
             * @member {string} valueUnit
             * @memberof UIBot.Common.StatisticResult
             * @instance
             */
            StatisticResult.prototype.valueUnit = "";

            /**
             * Creates a new StatisticResult instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.StatisticResult
             * @static
             * @param {UIBot.Common.IStatisticResult=} [properties] Properties to set
             * @returns {UIBot.Common.StatisticResult} StatisticResult instance
             */
            StatisticResult.create = function create(properties) {
                return new StatisticResult(properties);
            };

            /**
             * Encodes the specified StatisticResult message. Does not implicitly {@link UIBot.Common.StatisticResult.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.StatisticResult
             * @static
             * @param {UIBot.Common.IStatisticResult} message StatisticResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StatisticResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.elemCount != null && Object.hasOwnProperty.call(message, "elemCount"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.elemCount);
                if (message.volume != null && Object.hasOwnProperty.call(message, "volume"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.volume);
                if (message.mean != null && Object.hasOwnProperty.call(message, "mean"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.mean);
                if (message.staticMax != null && Object.hasOwnProperty.call(message, "staticMax"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.staticMax);
                if (message.staticMin != null && Object.hasOwnProperty.call(message, "staticMin"))
                    writer.uint32(/* id 5, wireType 1 =*/41).double(message.staticMin);
                if (message.staticStd != null && Object.hasOwnProperty.call(message, "staticStd"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.staticStd);
                if (message.maxX != null && Object.hasOwnProperty.call(message, "maxX"))
                    writer.uint32(/* id 7, wireType 1 =*/57).double(message.maxX);
                if (message.maxY != null && Object.hasOwnProperty.call(message, "maxY"))
                    writer.uint32(/* id 8, wireType 1 =*/65).double(message.maxY);
                if (message.maxZ != null && Object.hasOwnProperty.call(message, "maxZ"))
                    writer.uint32(/* id 9, wireType 1 =*/73).double(message.maxZ);
                if (message.sliceLocation != null && Object.hasOwnProperty.call(message, "sliceLocation"))
                    writer.uint32(/* id 10, wireType 1 =*/81).double(message.sliceLocation);
                if (message.peak != null && Object.hasOwnProperty.call(message, "peak"))
                    writer.uint32(/* id 11, wireType 1 =*/89).double(message.peak);
                if (message.rulerUnit != null && Object.hasOwnProperty.call(message, "rulerUnit"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.rulerUnit);
                if (message.valueUnit != null && Object.hasOwnProperty.call(message, "valueUnit"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.valueUnit);
                return writer;
            };

            /**
             * Encodes the specified StatisticResult message, length delimited. Does not implicitly {@link UIBot.Common.StatisticResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.StatisticResult
             * @static
             * @param {UIBot.Common.IStatisticResult} message StatisticResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StatisticResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StatisticResult message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.StatisticResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.StatisticResult} StatisticResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StatisticResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.StatisticResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.elemCount = reader.int32();
                            break;
                        }
                    case 2: {
                            message.volume = reader.double();
                            break;
                        }
                    case 3: {
                            message.mean = reader.double();
                            break;
                        }
                    case 4: {
                            message.staticMax = reader.double();
                            break;
                        }
                    case 5: {
                            message.staticMin = reader.double();
                            break;
                        }
                    case 6: {
                            message.staticStd = reader.double();
                            break;
                        }
                    case 7: {
                            message.maxX = reader.double();
                            break;
                        }
                    case 8: {
                            message.maxY = reader.double();
                            break;
                        }
                    case 9: {
                            message.maxZ = reader.double();
                            break;
                        }
                    case 10: {
                            message.sliceLocation = reader.double();
                            break;
                        }
                    case 11: {
                            message.peak = reader.double();
                            break;
                        }
                    case 12: {
                            message.rulerUnit = reader.string();
                            break;
                        }
                    case 13: {
                            message.valueUnit = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StatisticResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.StatisticResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.StatisticResult} StatisticResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StatisticResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StatisticResult message.
             * @function verify
             * @memberof UIBot.Common.StatisticResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StatisticResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.elemCount != null && message.hasOwnProperty("elemCount"))
                    if (!$util.isInteger(message.elemCount))
                        return "elemCount: integer expected";
                if (message.volume != null && message.hasOwnProperty("volume"))
                    if (typeof message.volume !== "number")
                        return "volume: number expected";
                if (message.mean != null && message.hasOwnProperty("mean"))
                    if (typeof message.mean !== "number")
                        return "mean: number expected";
                if (message.staticMax != null && message.hasOwnProperty("staticMax"))
                    if (typeof message.staticMax !== "number")
                        return "staticMax: number expected";
                if (message.staticMin != null && message.hasOwnProperty("staticMin"))
                    if (typeof message.staticMin !== "number")
                        return "staticMin: number expected";
                if (message.staticStd != null && message.hasOwnProperty("staticStd"))
                    if (typeof message.staticStd !== "number")
                        return "staticStd: number expected";
                if (message.maxX != null && message.hasOwnProperty("maxX"))
                    if (typeof message.maxX !== "number")
                        return "maxX: number expected";
                if (message.maxY != null && message.hasOwnProperty("maxY"))
                    if (typeof message.maxY !== "number")
                        return "maxY: number expected";
                if (message.maxZ != null && message.hasOwnProperty("maxZ"))
                    if (typeof message.maxZ !== "number")
                        return "maxZ: number expected";
                if (message.sliceLocation != null && message.hasOwnProperty("sliceLocation"))
                    if (typeof message.sliceLocation !== "number")
                        return "sliceLocation: number expected";
                if (message.peak != null && message.hasOwnProperty("peak"))
                    if (typeof message.peak !== "number")
                        return "peak: number expected";
                if (message.rulerUnit != null && message.hasOwnProperty("rulerUnit"))
                    if (!$util.isString(message.rulerUnit))
                        return "rulerUnit: string expected";
                if (message.valueUnit != null && message.hasOwnProperty("valueUnit"))
                    if (!$util.isString(message.valueUnit))
                        return "valueUnit: string expected";
                return null;
            };

            /**
             * Creates a StatisticResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.StatisticResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.StatisticResult} StatisticResult
             */
            StatisticResult.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.StatisticResult)
                    return object;
                var message = new $root.UIBot.Common.StatisticResult();
                if (object.elemCount != null)
                    message.elemCount = object.elemCount | 0;
                if (object.volume != null)
                    message.volume = Number(object.volume);
                if (object.mean != null)
                    message.mean = Number(object.mean);
                if (object.staticMax != null)
                    message.staticMax = Number(object.staticMax);
                if (object.staticMin != null)
                    message.staticMin = Number(object.staticMin);
                if (object.staticStd != null)
                    message.staticStd = Number(object.staticStd);
                if (object.maxX != null)
                    message.maxX = Number(object.maxX);
                if (object.maxY != null)
                    message.maxY = Number(object.maxY);
                if (object.maxZ != null)
                    message.maxZ = Number(object.maxZ);
                if (object.sliceLocation != null)
                    message.sliceLocation = Number(object.sliceLocation);
                if (object.peak != null)
                    message.peak = Number(object.peak);
                if (object.rulerUnit != null)
                    message.rulerUnit = String(object.rulerUnit);
                if (object.valueUnit != null)
                    message.valueUnit = String(object.valueUnit);
                return message;
            };

            /**
             * Creates a plain object from a StatisticResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.StatisticResult
             * @static
             * @param {UIBot.Common.StatisticResult} message StatisticResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StatisticResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.elemCount = 0;
                    object.volume = 0;
                    object.mean = 0;
                    object.staticMax = 0;
                    object.staticMin = 0;
                    object.staticStd = 0;
                    object.maxX = 0;
                    object.maxY = 0;
                    object.maxZ = 0;
                    object.sliceLocation = 0;
                    object.peak = 0;
                    object.rulerUnit = "";
                    object.valueUnit = "";
                }
                if (message.elemCount != null && message.hasOwnProperty("elemCount"))
                    object.elemCount = message.elemCount;
                if (message.volume != null && message.hasOwnProperty("volume"))
                    object.volume = options.json && !isFinite(message.volume) ? String(message.volume) : message.volume;
                if (message.mean != null && message.hasOwnProperty("mean"))
                    object.mean = options.json && !isFinite(message.mean) ? String(message.mean) : message.mean;
                if (message.staticMax != null && message.hasOwnProperty("staticMax"))
                    object.staticMax = options.json && !isFinite(message.staticMax) ? String(message.staticMax) : message.staticMax;
                if (message.staticMin != null && message.hasOwnProperty("staticMin"))
                    object.staticMin = options.json && !isFinite(message.staticMin) ? String(message.staticMin) : message.staticMin;
                if (message.staticStd != null && message.hasOwnProperty("staticStd"))
                    object.staticStd = options.json && !isFinite(message.staticStd) ? String(message.staticStd) : message.staticStd;
                if (message.maxX != null && message.hasOwnProperty("maxX"))
                    object.maxX = options.json && !isFinite(message.maxX) ? String(message.maxX) : message.maxX;
                if (message.maxY != null && message.hasOwnProperty("maxY"))
                    object.maxY = options.json && !isFinite(message.maxY) ? String(message.maxY) : message.maxY;
                if (message.maxZ != null && message.hasOwnProperty("maxZ"))
                    object.maxZ = options.json && !isFinite(message.maxZ) ? String(message.maxZ) : message.maxZ;
                if (message.sliceLocation != null && message.hasOwnProperty("sliceLocation"))
                    object.sliceLocation = options.json && !isFinite(message.sliceLocation) ? String(message.sliceLocation) : message.sliceLocation;
                if (message.peak != null && message.hasOwnProperty("peak"))
                    object.peak = options.json && !isFinite(message.peak) ? String(message.peak) : message.peak;
                if (message.rulerUnit != null && message.hasOwnProperty("rulerUnit"))
                    object.rulerUnit = message.rulerUnit;
                if (message.valueUnit != null && message.hasOwnProperty("valueUnit"))
                    object.valueUnit = message.valueUnit;
                return object;
            };

            /**
             * Converts this StatisticResult to JSON.
             * @function toJSON
             * @memberof UIBot.Common.StatisticResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StatisticResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StatisticResult
             * @function getTypeUrl
             * @memberof UIBot.Common.StatisticResult
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StatisticResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.StatisticResult";
            };

            return StatisticResult;
        })();

        Common.MsgTissueInfo = (function() {

            /**
             * Properties of a MsgTissueInfo.
             * @memberof UIBot.Common
             * @interface IMsgTissueInfo
             * @property {number} index MsgTissueInfo index
             * @property {string|null} [name] MsgTissueInfo name
             * @property {number|null} [opacity] MsgTissueInfo opacity
             * @property {UIBot.Common.IMsgColor|null} [color] MsgTissueInfo color
             * @property {string|null} [vrtPath] MsgTissueInfo vrtPath
             * @property {boolean|null} [visibility] MsgTissueInfo visibility
             * @property {boolean|null} [isLocked] MsgTissueInfo isLocked
             * @property {boolean|null} [deleteEnabled] MsgTissueInfo deleteEnabled
             * @property {boolean|null} [isSelected] MsgTissueInfo isSelected
             * @property {boolean|null} [isDisplayStatistic] MsgTissueInfo isDisplayStatistic
             * @property {boolean|null} [isUseVrt] MsgTissueInfo isUseVrt
             * @property {number|null} [tissueType] MsgTissueInfo tissueType
             * @property {string|null} [tissueBasis] MsgTissueInfo tissueBasis
             * @property {Uint8Array|null} [appInfo] MsgTissueInfo appInfo
             * @property {string|null} [tissueComments] MsgTissueInfo tissueComments
             * @property {boolean|null} [tissueRefUidVisible] MsgTissueInfo tissueRefUidVisible
             * @property {Array.<number>|null} [labels] MsgTissueInfo labels
             * @property {UIBot.Common.IStatisticResult|null} [tissueStatic] MsgTissueInfo tissueStatic
             * @property {Uint8Array|null} [stateOnMpr] MsgTissueInfo stateOnMpr
             * @property {Uint8Array|null} [stateOnVr] MsgTissueInfo stateOnVr
             */

            /**
             * Constructs a new MsgTissueInfo.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgTissueInfo.
             * @implements IMsgTissueInfo
             * @constructor
             * @param {UIBot.Common.IMsgTissueInfo=} [properties] Properties to set
             */
            function MsgTissueInfo(properties) {
                this.labels = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgTissueInfo index.
             * @member {number} index
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.index = 0;

            /**
             * MsgTissueInfo name.
             * @member {string} name
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.name = "";

            /**
             * MsgTissueInfo opacity.
             * @member {number} opacity
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.opacity = 0;

            /**
             * MsgTissueInfo color.
             * @member {UIBot.Common.IMsgColor|null|undefined} color
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.color = null;

            /**
             * MsgTissueInfo vrtPath.
             * @member {string} vrtPath
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.vrtPath = "";

            /**
             * MsgTissueInfo visibility.
             * @member {boolean} visibility
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.visibility = false;

            /**
             * MsgTissueInfo isLocked.
             * @member {boolean} isLocked
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.isLocked = false;

            /**
             * MsgTissueInfo deleteEnabled.
             * @member {boolean} deleteEnabled
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.deleteEnabled = false;

            /**
             * MsgTissueInfo isSelected.
             * @member {boolean} isSelected
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.isSelected = false;

            /**
             * MsgTissueInfo isDisplayStatistic.
             * @member {boolean} isDisplayStatistic
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.isDisplayStatistic = false;

            /**
             * MsgTissueInfo isUseVrt.
             * @member {boolean} isUseVrt
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.isUseVrt = false;

            /**
             * MsgTissueInfo tissueType.
             * @member {number} tissueType
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.tissueType = 0;

            /**
             * MsgTissueInfo tissueBasis.
             * @member {string} tissueBasis
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.tissueBasis = "";

            /**
             * MsgTissueInfo appInfo.
             * @member {Uint8Array} appInfo
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.appInfo = $util.newBuffer([]);

            /**
             * MsgTissueInfo tissueComments.
             * @member {string} tissueComments
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.tissueComments = "";

            /**
             * MsgTissueInfo tissueRefUidVisible.
             * @member {boolean} tissueRefUidVisible
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.tissueRefUidVisible = false;

            /**
             * MsgTissueInfo labels.
             * @member {Array.<number>} labels
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.labels = $util.emptyArray;

            /**
             * MsgTissueInfo tissueStatic.
             * @member {UIBot.Common.IStatisticResult|null|undefined} tissueStatic
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.tissueStatic = null;

            /**
             * MsgTissueInfo stateOnMpr.
             * @member {Uint8Array} stateOnMpr
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.stateOnMpr = $util.newBuffer([]);

            /**
             * MsgTissueInfo stateOnVr.
             * @member {Uint8Array} stateOnVr
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             */
            MsgTissueInfo.prototype.stateOnVr = $util.newBuffer([]);

            /**
             * Creates a new MsgTissueInfo instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgTissueInfo
             * @static
             * @param {UIBot.Common.IMsgTissueInfo=} [properties] Properties to set
             * @returns {UIBot.Common.MsgTissueInfo} MsgTissueInfo instance
             */
            MsgTissueInfo.create = function create(properties) {
                return new MsgTissueInfo(properties);
            };

            /**
             * Encodes the specified MsgTissueInfo message. Does not implicitly {@link UIBot.Common.MsgTissueInfo.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgTissueInfo
             * @static
             * @param {UIBot.Common.IMsgTissueInfo} message MsgTissueInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgTissueInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.opacity != null && Object.hasOwnProperty.call(message, "opacity"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.opacity);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    $root.UIBot.Common.MsgColor.encode(message.color, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.vrtPath != null && Object.hasOwnProperty.call(message, "vrtPath"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.vrtPath);
                if (message.visibility != null && Object.hasOwnProperty.call(message, "visibility"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.visibility);
                if (message.isLocked != null && Object.hasOwnProperty.call(message, "isLocked"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isLocked);
                if (message.deleteEnabled != null && Object.hasOwnProperty.call(message, "deleteEnabled"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.deleteEnabled);
                if (message.isSelected != null && Object.hasOwnProperty.call(message, "isSelected"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isSelected);
                if (message.isDisplayStatistic != null && Object.hasOwnProperty.call(message, "isDisplayStatistic"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.isDisplayStatistic);
                if (message.isUseVrt != null && Object.hasOwnProperty.call(message, "isUseVrt"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.isUseVrt);
                if (message.tissueType != null && Object.hasOwnProperty.call(message, "tissueType"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.tissueType);
                if (message.tissueBasis != null && Object.hasOwnProperty.call(message, "tissueBasis"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.tissueBasis);
                if (message.appInfo != null && Object.hasOwnProperty.call(message, "appInfo"))
                    writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.appInfo);
                if (message.tissueComments != null && Object.hasOwnProperty.call(message, "tissueComments"))
                    writer.uint32(/* id 15, wireType 2 =*/122).string(message.tissueComments);
                if (message.tissueRefUidVisible != null && Object.hasOwnProperty.call(message, "tissueRefUidVisible"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.tissueRefUidVisible);
                if (message.labels != null && message.labels.length)
                    for (var i = 0; i < message.labels.length; ++i)
                        writer.uint32(/* id 17, wireType 0 =*/136).int32(message.labels[i]);
                if (message.tissueStatic != null && Object.hasOwnProperty.call(message, "tissueStatic"))
                    $root.UIBot.Common.StatisticResult.encode(message.tissueStatic, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.stateOnMpr != null && Object.hasOwnProperty.call(message, "stateOnMpr"))
                    writer.uint32(/* id 19, wireType 2 =*/154).bytes(message.stateOnMpr);
                if (message.stateOnVr != null && Object.hasOwnProperty.call(message, "stateOnVr"))
                    writer.uint32(/* id 20, wireType 2 =*/162).bytes(message.stateOnVr);
                return writer;
            };

            /**
             * Encodes the specified MsgTissueInfo message, length delimited. Does not implicitly {@link UIBot.Common.MsgTissueInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgTissueInfo
             * @static
             * @param {UIBot.Common.IMsgTissueInfo} message MsgTissueInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgTissueInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgTissueInfo message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgTissueInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgTissueInfo} MsgTissueInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgTissueInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgTissueInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.index = reader.int32();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            message.opacity = reader.double();
                            break;
                        }
                    case 4: {
                            message.color = $root.UIBot.Common.MsgColor.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.vrtPath = reader.string();
                            break;
                        }
                    case 6: {
                            message.visibility = reader.bool();
                            break;
                        }
                    case 7: {
                            message.isLocked = reader.bool();
                            break;
                        }
                    case 8: {
                            message.deleteEnabled = reader.bool();
                            break;
                        }
                    case 9: {
                            message.isSelected = reader.bool();
                            break;
                        }
                    case 10: {
                            message.isDisplayStatistic = reader.bool();
                            break;
                        }
                    case 11: {
                            message.isUseVrt = reader.bool();
                            break;
                        }
                    case 12: {
                            message.tissueType = reader.int32();
                            break;
                        }
                    case 13: {
                            message.tissueBasis = reader.string();
                            break;
                        }
                    case 14: {
                            message.appInfo = reader.bytes();
                            break;
                        }
                    case 15: {
                            message.tissueComments = reader.string();
                            break;
                        }
                    case 16: {
                            message.tissueRefUidVisible = reader.bool();
                            break;
                        }
                    case 17: {
                            if (!(message.labels && message.labels.length))
                                message.labels = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.labels.push(reader.int32());
                            } else
                                message.labels.push(reader.int32());
                            break;
                        }
                    case 18: {
                            message.tissueStatic = $root.UIBot.Common.StatisticResult.decode(reader, reader.uint32());
                            break;
                        }
                    case 19: {
                            message.stateOnMpr = reader.bytes();
                            break;
                        }
                    case 20: {
                            message.stateOnVr = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("index"))
                    throw $util.ProtocolError("missing required 'index'", { instance: message });
                return message;
            };

            /**
             * Decodes a MsgTissueInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgTissueInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgTissueInfo} MsgTissueInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgTissueInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgTissueInfo message.
             * @function verify
             * @memberof UIBot.Common.MsgTissueInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgTissueInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.opacity != null && message.hasOwnProperty("opacity"))
                    if (typeof message.opacity !== "number")
                        return "opacity: number expected";
                if (message.color != null && message.hasOwnProperty("color")) {
                    var error = $root.UIBot.Common.MsgColor.verify(message.color);
                    if (error)
                        return "color." + error;
                }
                if (message.vrtPath != null && message.hasOwnProperty("vrtPath"))
                    if (!$util.isString(message.vrtPath))
                        return "vrtPath: string expected";
                if (message.visibility != null && message.hasOwnProperty("visibility"))
                    if (typeof message.visibility !== "boolean")
                        return "visibility: boolean expected";
                if (message.isLocked != null && message.hasOwnProperty("isLocked"))
                    if (typeof message.isLocked !== "boolean")
                        return "isLocked: boolean expected";
                if (message.deleteEnabled != null && message.hasOwnProperty("deleteEnabled"))
                    if (typeof message.deleteEnabled !== "boolean")
                        return "deleteEnabled: boolean expected";
                if (message.isSelected != null && message.hasOwnProperty("isSelected"))
                    if (typeof message.isSelected !== "boolean")
                        return "isSelected: boolean expected";
                if (message.isDisplayStatistic != null && message.hasOwnProperty("isDisplayStatistic"))
                    if (typeof message.isDisplayStatistic !== "boolean")
                        return "isDisplayStatistic: boolean expected";
                if (message.isUseVrt != null && message.hasOwnProperty("isUseVrt"))
                    if (typeof message.isUseVrt !== "boolean")
                        return "isUseVrt: boolean expected";
                if (message.tissueType != null && message.hasOwnProperty("tissueType"))
                    if (!$util.isInteger(message.tissueType))
                        return "tissueType: integer expected";
                if (message.tissueBasis != null && message.hasOwnProperty("tissueBasis"))
                    if (!$util.isString(message.tissueBasis))
                        return "tissueBasis: string expected";
                if (message.appInfo != null && message.hasOwnProperty("appInfo"))
                    if (!(message.appInfo && typeof message.appInfo.length === "number" || $util.isString(message.appInfo)))
                        return "appInfo: buffer expected";
                if (message.tissueComments != null && message.hasOwnProperty("tissueComments"))
                    if (!$util.isString(message.tissueComments))
                        return "tissueComments: string expected";
                if (message.tissueRefUidVisible != null && message.hasOwnProperty("tissueRefUidVisible"))
                    if (typeof message.tissueRefUidVisible !== "boolean")
                        return "tissueRefUidVisible: boolean expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!Array.isArray(message.labels))
                        return "labels: array expected";
                    for (var i = 0; i < message.labels.length; ++i)
                        if (!$util.isInteger(message.labels[i]))
                            return "labels: integer[] expected";
                }
                if (message.tissueStatic != null && message.hasOwnProperty("tissueStatic")) {
                    var error = $root.UIBot.Common.StatisticResult.verify(message.tissueStatic);
                    if (error)
                        return "tissueStatic." + error;
                }
                if (message.stateOnMpr != null && message.hasOwnProperty("stateOnMpr"))
                    if (!(message.stateOnMpr && typeof message.stateOnMpr.length === "number" || $util.isString(message.stateOnMpr)))
                        return "stateOnMpr: buffer expected";
                if (message.stateOnVr != null && message.hasOwnProperty("stateOnVr"))
                    if (!(message.stateOnVr && typeof message.stateOnVr.length === "number" || $util.isString(message.stateOnVr)))
                        return "stateOnVr: buffer expected";
                return null;
            };

            /**
             * Creates a MsgTissueInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgTissueInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgTissueInfo} MsgTissueInfo
             */
            MsgTissueInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgTissueInfo)
                    return object;
                var message = new $root.UIBot.Common.MsgTissueInfo();
                if (object.index != null)
                    message.index = object.index | 0;
                if (object.name != null)
                    message.name = String(object.name);
                if (object.opacity != null)
                    message.opacity = Number(object.opacity);
                if (object.color != null) {
                    if (typeof object.color !== "object")
                        throw TypeError(".UIBot.Common.MsgTissueInfo.color: object expected");
                    message.color = $root.UIBot.Common.MsgColor.fromObject(object.color);
                }
                if (object.vrtPath != null)
                    message.vrtPath = String(object.vrtPath);
                if (object.visibility != null)
                    message.visibility = Boolean(object.visibility);
                if (object.isLocked != null)
                    message.isLocked = Boolean(object.isLocked);
                if (object.deleteEnabled != null)
                    message.deleteEnabled = Boolean(object.deleteEnabled);
                if (object.isSelected != null)
                    message.isSelected = Boolean(object.isSelected);
                if (object.isDisplayStatistic != null)
                    message.isDisplayStatistic = Boolean(object.isDisplayStatistic);
                if (object.isUseVrt != null)
                    message.isUseVrt = Boolean(object.isUseVrt);
                if (object.tissueType != null)
                    message.tissueType = object.tissueType | 0;
                if (object.tissueBasis != null)
                    message.tissueBasis = String(object.tissueBasis);
                if (object.appInfo != null)
                    if (typeof object.appInfo === "string")
                        $util.base64.decode(object.appInfo, message.appInfo = $util.newBuffer($util.base64.length(object.appInfo)), 0);
                    else if (object.appInfo.length >= 0)
                        message.appInfo = object.appInfo;
                if (object.tissueComments != null)
                    message.tissueComments = String(object.tissueComments);
                if (object.tissueRefUidVisible != null)
                    message.tissueRefUidVisible = Boolean(object.tissueRefUidVisible);
                if (object.labels) {
                    if (!Array.isArray(object.labels))
                        throw TypeError(".UIBot.Common.MsgTissueInfo.labels: array expected");
                    message.labels = [];
                    for (var i = 0; i < object.labels.length; ++i)
                        message.labels[i] = object.labels[i] | 0;
                }
                if (object.tissueStatic != null) {
                    if (typeof object.tissueStatic !== "object")
                        throw TypeError(".UIBot.Common.MsgTissueInfo.tissueStatic: object expected");
                    message.tissueStatic = $root.UIBot.Common.StatisticResult.fromObject(object.tissueStatic);
                }
                if (object.stateOnMpr != null)
                    if (typeof object.stateOnMpr === "string")
                        $util.base64.decode(object.stateOnMpr, message.stateOnMpr = $util.newBuffer($util.base64.length(object.stateOnMpr)), 0);
                    else if (object.stateOnMpr.length >= 0)
                        message.stateOnMpr = object.stateOnMpr;
                if (object.stateOnVr != null)
                    if (typeof object.stateOnVr === "string")
                        $util.base64.decode(object.stateOnVr, message.stateOnVr = $util.newBuffer($util.base64.length(object.stateOnVr)), 0);
                    else if (object.stateOnVr.length >= 0)
                        message.stateOnVr = object.stateOnVr;
                return message;
            };

            /**
             * Creates a plain object from a MsgTissueInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgTissueInfo
             * @static
             * @param {UIBot.Common.MsgTissueInfo} message MsgTissueInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgTissueInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.labels = [];
                if (options.defaults) {
                    object.index = 0;
                    object.name = "";
                    object.opacity = 0;
                    object.color = null;
                    object.vrtPath = "";
                    object.visibility = false;
                    object.isLocked = false;
                    object.deleteEnabled = false;
                    object.isSelected = false;
                    object.isDisplayStatistic = false;
                    object.isUseVrt = false;
                    object.tissueType = 0;
                    object.tissueBasis = "";
                    if (options.bytes === String)
                        object.appInfo = "";
                    else {
                        object.appInfo = [];
                        if (options.bytes !== Array)
                            object.appInfo = $util.newBuffer(object.appInfo);
                    }
                    object.tissueComments = "";
                    object.tissueRefUidVisible = false;
                    object.tissueStatic = null;
                    if (options.bytes === String)
                        object.stateOnMpr = "";
                    else {
                        object.stateOnMpr = [];
                        if (options.bytes !== Array)
                            object.stateOnMpr = $util.newBuffer(object.stateOnMpr);
                    }
                    if (options.bytes === String)
                        object.stateOnVr = "";
                    else {
                        object.stateOnVr = [];
                        if (options.bytes !== Array)
                            object.stateOnVr = $util.newBuffer(object.stateOnVr);
                    }
                }
                if (message.index != null && message.hasOwnProperty("index"))
                    object.index = message.index;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.opacity != null && message.hasOwnProperty("opacity"))
                    object.opacity = options.json && !isFinite(message.opacity) ? String(message.opacity) : message.opacity;
                if (message.color != null && message.hasOwnProperty("color"))
                    object.color = $root.UIBot.Common.MsgColor.toObject(message.color, options);
                if (message.vrtPath != null && message.hasOwnProperty("vrtPath"))
                    object.vrtPath = message.vrtPath;
                if (message.visibility != null && message.hasOwnProperty("visibility"))
                    object.visibility = message.visibility;
                if (message.isLocked != null && message.hasOwnProperty("isLocked"))
                    object.isLocked = message.isLocked;
                if (message.deleteEnabled != null && message.hasOwnProperty("deleteEnabled"))
                    object.deleteEnabled = message.deleteEnabled;
                if (message.isSelected != null && message.hasOwnProperty("isSelected"))
                    object.isSelected = message.isSelected;
                if (message.isDisplayStatistic != null && message.hasOwnProperty("isDisplayStatistic"))
                    object.isDisplayStatistic = message.isDisplayStatistic;
                if (message.isUseVrt != null && message.hasOwnProperty("isUseVrt"))
                    object.isUseVrt = message.isUseVrt;
                if (message.tissueType != null && message.hasOwnProperty("tissueType"))
                    object.tissueType = message.tissueType;
                if (message.tissueBasis != null && message.hasOwnProperty("tissueBasis"))
                    object.tissueBasis = message.tissueBasis;
                if (message.appInfo != null && message.hasOwnProperty("appInfo"))
                    object.appInfo = options.bytes === String ? $util.base64.encode(message.appInfo, 0, message.appInfo.length) : options.bytes === Array ? Array.prototype.slice.call(message.appInfo) : message.appInfo;
                if (message.tissueComments != null && message.hasOwnProperty("tissueComments"))
                    object.tissueComments = message.tissueComments;
                if (message.tissueRefUidVisible != null && message.hasOwnProperty("tissueRefUidVisible"))
                    object.tissueRefUidVisible = message.tissueRefUidVisible;
                if (message.labels && message.labels.length) {
                    object.labels = [];
                    for (var j = 0; j < message.labels.length; ++j)
                        object.labels[j] = message.labels[j];
                }
                if (message.tissueStatic != null && message.hasOwnProperty("tissueStatic"))
                    object.tissueStatic = $root.UIBot.Common.StatisticResult.toObject(message.tissueStatic, options);
                if (message.stateOnMpr != null && message.hasOwnProperty("stateOnMpr"))
                    object.stateOnMpr = options.bytes === String ? $util.base64.encode(message.stateOnMpr, 0, message.stateOnMpr.length) : options.bytes === Array ? Array.prototype.slice.call(message.stateOnMpr) : message.stateOnMpr;
                if (message.stateOnVr != null && message.hasOwnProperty("stateOnVr"))
                    object.stateOnVr = options.bytes === String ? $util.base64.encode(message.stateOnVr, 0, message.stateOnVr.length) : options.bytes === Array ? Array.prototype.slice.call(message.stateOnVr) : message.stateOnVr;
                return object;
            };

            /**
             * Converts this MsgTissueInfo to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgTissueInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgTissueInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgTissueInfo
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgTissueInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgTissueInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgTissueInfo";
            };

            return MsgTissueInfo;
        })();

        Common.MsgTissueList = (function() {

            /**
             * Properties of a MsgTissueList.
             * @memberof UIBot.Common
             * @interface IMsgTissueList
             * @property {string|null} [seriesuid] MsgTissueList seriesuid
             * @property {Array.<UIBot.Common.IMsgTissueInfo>|null} [tissueList] MsgTissueList tissueList
             */

            /**
             * Constructs a new MsgTissueList.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgTissueList.
             * @implements IMsgTissueList
             * @constructor
             * @param {UIBot.Common.IMsgTissueList=} [properties] Properties to set
             */
            function MsgTissueList(properties) {
                this.tissueList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgTissueList seriesuid.
             * @member {string} seriesuid
             * @memberof UIBot.Common.MsgTissueList
             * @instance
             */
            MsgTissueList.prototype.seriesuid = "";

            /**
             * MsgTissueList tissueList.
             * @member {Array.<UIBot.Common.IMsgTissueInfo>} tissueList
             * @memberof UIBot.Common.MsgTissueList
             * @instance
             */
            MsgTissueList.prototype.tissueList = $util.emptyArray;

            /**
             * Creates a new MsgTissueList instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgTissueList
             * @static
             * @param {UIBot.Common.IMsgTissueList=} [properties] Properties to set
             * @returns {UIBot.Common.MsgTissueList} MsgTissueList instance
             */
            MsgTissueList.create = function create(properties) {
                return new MsgTissueList(properties);
            };

            /**
             * Encodes the specified MsgTissueList message. Does not implicitly {@link UIBot.Common.MsgTissueList.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgTissueList
             * @static
             * @param {UIBot.Common.IMsgTissueList} message MsgTissueList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgTissueList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seriesuid != null && Object.hasOwnProperty.call(message, "seriesuid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.seriesuid);
                if (message.tissueList != null && message.tissueList.length)
                    for (var i = 0; i < message.tissueList.length; ++i)
                        $root.UIBot.Common.MsgTissueInfo.encode(message.tissueList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MsgTissueList message, length delimited. Does not implicitly {@link UIBot.Common.MsgTissueList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgTissueList
             * @static
             * @param {UIBot.Common.IMsgTissueList} message MsgTissueList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgTissueList.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgTissueList message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgTissueList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgTissueList} MsgTissueList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgTissueList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgTissueList();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.seriesuid = reader.string();
                            break;
                        }
                    case 2: {
                            if (!(message.tissueList && message.tissueList.length))
                                message.tissueList = [];
                            message.tissueList.push($root.UIBot.Common.MsgTissueInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgTissueList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgTissueList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgTissueList} MsgTissueList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgTissueList.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgTissueList message.
             * @function verify
             * @memberof UIBot.Common.MsgTissueList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgTissueList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seriesuid != null && message.hasOwnProperty("seriesuid"))
                    if (!$util.isString(message.seriesuid))
                        return "seriesuid: string expected";
                if (message.tissueList != null && message.hasOwnProperty("tissueList")) {
                    if (!Array.isArray(message.tissueList))
                        return "tissueList: array expected";
                    for (var i = 0; i < message.tissueList.length; ++i) {
                        var error = $root.UIBot.Common.MsgTissueInfo.verify(message.tissueList[i]);
                        if (error)
                            return "tissueList." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MsgTissueList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgTissueList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgTissueList} MsgTissueList
             */
            MsgTissueList.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgTissueList)
                    return object;
                var message = new $root.UIBot.Common.MsgTissueList();
                if (object.seriesuid != null)
                    message.seriesuid = String(object.seriesuid);
                if (object.tissueList) {
                    if (!Array.isArray(object.tissueList))
                        throw TypeError(".UIBot.Common.MsgTissueList.tissueList: array expected");
                    message.tissueList = [];
                    for (var i = 0; i < object.tissueList.length; ++i) {
                        if (typeof object.tissueList[i] !== "object")
                            throw TypeError(".UIBot.Common.MsgTissueList.tissueList: object expected");
                        message.tissueList[i] = $root.UIBot.Common.MsgTissueInfo.fromObject(object.tissueList[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MsgTissueList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgTissueList
             * @static
             * @param {UIBot.Common.MsgTissueList} message MsgTissueList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgTissueList.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.tissueList = [];
                if (options.defaults)
                    object.seriesuid = "";
                if (message.seriesuid != null && message.hasOwnProperty("seriesuid"))
                    object.seriesuid = message.seriesuid;
                if (message.tissueList && message.tissueList.length) {
                    object.tissueList = [];
                    for (var j = 0; j < message.tissueList.length; ++j)
                        object.tissueList[j] = $root.UIBot.Common.MsgTissueInfo.toObject(message.tissueList[j], options);
                }
                return object;
            };

            /**
             * Converts this MsgTissueList to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgTissueList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgTissueList.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgTissueList
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgTissueList
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgTissueList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgTissueList";
            };

            return MsgTissueList;
        })();

        /**
         * EnumNavigationBarItem enum.
         * @name UIBot.Common.EnumNavigationBarItem
         * @enum {number}
         * @property {number} NavigationBarItem_All=1 NavigationBarItem_All value
         * @property {number} NavigationBarItem_Pa=2 NavigationBarItem_Pa value
         * @property {number} NavigationBarItem_ExitPatient=3 NavigationBarItem_ExitPatient value
         * @property {number} NavigationBarItem_ScreenRecording=4 NavigationBarItem_ScreenRecording value
         * @property {number} NavigationBarItem_Screenshot=5 NavigationBarItem_Screenshot value
         * @property {number} NavigationBarItem_StepBar=6 NavigationBarItem_StepBar value
         */
        Common.EnumNavigationBarItem = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "NavigationBarItem_All"] = 1;
            values[valuesById[2] = "NavigationBarItem_Pa"] = 2;
            values[valuesById[3] = "NavigationBarItem_ExitPatient"] = 3;
            values[valuesById[4] = "NavigationBarItem_ScreenRecording"] = 4;
            values[valuesById[5] = "NavigationBarItem_Screenshot"] = 5;
            values[valuesById[6] = "NavigationBarItem_StepBar"] = 6;
            return values;
        })();

        Common.MsgChangeNavigationBarUIItemStatus = (function() {

            /**
             * Properties of a MsgChangeNavigationBarUIItemStatus.
             * @memberof UIBot.Common
             * @interface IMsgChangeNavigationBarUIItemStatus
             * @property {UIBot.Common.EnumNavigationBarItem|null} [eBarItem] MsgChangeNavigationBarUIItemStatus eBarItem
             * @property {boolean|null} [enable] MsgChangeNavigationBarUIItemStatus enable
             */

            /**
             * Constructs a new MsgChangeNavigationBarUIItemStatus.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgChangeNavigationBarUIItemStatus.
             * @implements IMsgChangeNavigationBarUIItemStatus
             * @constructor
             * @param {UIBot.Common.IMsgChangeNavigationBarUIItemStatus=} [properties] Properties to set
             */
            function MsgChangeNavigationBarUIItemStatus(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgChangeNavigationBarUIItemStatus eBarItem.
             * @member {UIBot.Common.EnumNavigationBarItem} eBarItem
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatus
             * @instance
             */
            MsgChangeNavigationBarUIItemStatus.prototype.eBarItem = 1;

            /**
             * MsgChangeNavigationBarUIItemStatus enable.
             * @member {boolean} enable
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatus
             * @instance
             */
            MsgChangeNavigationBarUIItemStatus.prototype.enable = false;

            /**
             * Creates a new MsgChangeNavigationBarUIItemStatus instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatus
             * @static
             * @param {UIBot.Common.IMsgChangeNavigationBarUIItemStatus=} [properties] Properties to set
             * @returns {UIBot.Common.MsgChangeNavigationBarUIItemStatus} MsgChangeNavigationBarUIItemStatus instance
             */
            MsgChangeNavigationBarUIItemStatus.create = function create(properties) {
                return new MsgChangeNavigationBarUIItemStatus(properties);
            };

            /**
             * Encodes the specified MsgChangeNavigationBarUIItemStatus message. Does not implicitly {@link UIBot.Common.MsgChangeNavigationBarUIItemStatus.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatus
             * @static
             * @param {UIBot.Common.IMsgChangeNavigationBarUIItemStatus} message MsgChangeNavigationBarUIItemStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgChangeNavigationBarUIItemStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.eBarItem != null && Object.hasOwnProperty.call(message, "eBarItem"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.eBarItem);
                if (message.enable != null && Object.hasOwnProperty.call(message, "enable"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enable);
                return writer;
            };

            /**
             * Encodes the specified MsgChangeNavigationBarUIItemStatus message, length delimited. Does not implicitly {@link UIBot.Common.MsgChangeNavigationBarUIItemStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatus
             * @static
             * @param {UIBot.Common.IMsgChangeNavigationBarUIItemStatus} message MsgChangeNavigationBarUIItemStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgChangeNavigationBarUIItemStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgChangeNavigationBarUIItemStatus message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgChangeNavigationBarUIItemStatus} MsgChangeNavigationBarUIItemStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgChangeNavigationBarUIItemStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgChangeNavigationBarUIItemStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.eBarItem = reader.int32();
                            break;
                        }
                    case 2: {
                            message.enable = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgChangeNavigationBarUIItemStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgChangeNavigationBarUIItemStatus} MsgChangeNavigationBarUIItemStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgChangeNavigationBarUIItemStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgChangeNavigationBarUIItemStatus message.
             * @function verify
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgChangeNavigationBarUIItemStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.eBarItem != null && message.hasOwnProperty("eBarItem"))
                    switch (message.eBarItem) {
                    default:
                        return "eBarItem: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.enable != null && message.hasOwnProperty("enable"))
                    if (typeof message.enable !== "boolean")
                        return "enable: boolean expected";
                return null;
            };

            /**
             * Creates a MsgChangeNavigationBarUIItemStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgChangeNavigationBarUIItemStatus} MsgChangeNavigationBarUIItemStatus
             */
            MsgChangeNavigationBarUIItemStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgChangeNavigationBarUIItemStatus)
                    return object;
                var message = new $root.UIBot.Common.MsgChangeNavigationBarUIItemStatus();
                switch (object.eBarItem) {
                default:
                    if (typeof object.eBarItem === "number") {
                        message.eBarItem = object.eBarItem;
                        break;
                    }
                    break;
                case "NavigationBarItem_All":
                case 1:
                    message.eBarItem = 1;
                    break;
                case "NavigationBarItem_Pa":
                case 2:
                    message.eBarItem = 2;
                    break;
                case "NavigationBarItem_ExitPatient":
                case 3:
                    message.eBarItem = 3;
                    break;
                case "NavigationBarItem_ScreenRecording":
                case 4:
                    message.eBarItem = 4;
                    break;
                case "NavigationBarItem_Screenshot":
                case 5:
                    message.eBarItem = 5;
                    break;
                case "NavigationBarItem_StepBar":
                case 6:
                    message.eBarItem = 6;
                    break;
                }
                if (object.enable != null)
                    message.enable = Boolean(object.enable);
                return message;
            };

            /**
             * Creates a plain object from a MsgChangeNavigationBarUIItemStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatus
             * @static
             * @param {UIBot.Common.MsgChangeNavigationBarUIItemStatus} message MsgChangeNavigationBarUIItemStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgChangeNavigationBarUIItemStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.eBarItem = options.enums === String ? "NavigationBarItem_All" : 1;
                    object.enable = false;
                }
                if (message.eBarItem != null && message.hasOwnProperty("eBarItem"))
                    object.eBarItem = options.enums === String ? $root.UIBot.Common.EnumNavigationBarItem[message.eBarItem] === undefined ? message.eBarItem : $root.UIBot.Common.EnumNavigationBarItem[message.eBarItem] : message.eBarItem;
                if (message.enable != null && message.hasOwnProperty("enable"))
                    object.enable = message.enable;
                return object;
            };

            /**
             * Converts this MsgChangeNavigationBarUIItemStatus to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgChangeNavigationBarUIItemStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgChangeNavigationBarUIItemStatus
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatus
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgChangeNavigationBarUIItemStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgChangeNavigationBarUIItemStatus";
            };

            return MsgChangeNavigationBarUIItemStatus;
        })();

        Common.MsgChangeNavigationBarUIItemStatusList = (function() {

            /**
             * Properties of a MsgChangeNavigationBarUIItemStatusList.
             * @memberof UIBot.Common
             * @interface IMsgChangeNavigationBarUIItemStatusList
             * @property {Array.<UIBot.Common.IMsgChangeNavigationBarUIItemStatus>|null} [msgNavigationBarUIItemStatus] MsgChangeNavigationBarUIItemStatusList msgNavigationBarUIItemStatus
             */

            /**
             * Constructs a new MsgChangeNavigationBarUIItemStatusList.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgChangeNavigationBarUIItemStatusList.
             * @implements IMsgChangeNavigationBarUIItemStatusList
             * @constructor
             * @param {UIBot.Common.IMsgChangeNavigationBarUIItemStatusList=} [properties] Properties to set
             */
            function MsgChangeNavigationBarUIItemStatusList(properties) {
                this.msgNavigationBarUIItemStatus = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgChangeNavigationBarUIItemStatusList msgNavigationBarUIItemStatus.
             * @member {Array.<UIBot.Common.IMsgChangeNavigationBarUIItemStatus>} msgNavigationBarUIItemStatus
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatusList
             * @instance
             */
            MsgChangeNavigationBarUIItemStatusList.prototype.msgNavigationBarUIItemStatus = $util.emptyArray;

            /**
             * Creates a new MsgChangeNavigationBarUIItemStatusList instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatusList
             * @static
             * @param {UIBot.Common.IMsgChangeNavigationBarUIItemStatusList=} [properties] Properties to set
             * @returns {UIBot.Common.MsgChangeNavigationBarUIItemStatusList} MsgChangeNavigationBarUIItemStatusList instance
             */
            MsgChangeNavigationBarUIItemStatusList.create = function create(properties) {
                return new MsgChangeNavigationBarUIItemStatusList(properties);
            };

            /**
             * Encodes the specified MsgChangeNavigationBarUIItemStatusList message. Does not implicitly {@link UIBot.Common.MsgChangeNavigationBarUIItemStatusList.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatusList
             * @static
             * @param {UIBot.Common.IMsgChangeNavigationBarUIItemStatusList} message MsgChangeNavigationBarUIItemStatusList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgChangeNavigationBarUIItemStatusList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.msgNavigationBarUIItemStatus != null && message.msgNavigationBarUIItemStatus.length)
                    for (var i = 0; i < message.msgNavigationBarUIItemStatus.length; ++i)
                        $root.UIBot.Common.MsgChangeNavigationBarUIItemStatus.encode(message.msgNavigationBarUIItemStatus[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MsgChangeNavigationBarUIItemStatusList message, length delimited. Does not implicitly {@link UIBot.Common.MsgChangeNavigationBarUIItemStatusList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatusList
             * @static
             * @param {UIBot.Common.IMsgChangeNavigationBarUIItemStatusList} message MsgChangeNavigationBarUIItemStatusList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgChangeNavigationBarUIItemStatusList.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgChangeNavigationBarUIItemStatusList message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatusList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgChangeNavigationBarUIItemStatusList} MsgChangeNavigationBarUIItemStatusList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgChangeNavigationBarUIItemStatusList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgChangeNavigationBarUIItemStatusList();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.msgNavigationBarUIItemStatus && message.msgNavigationBarUIItemStatus.length))
                                message.msgNavigationBarUIItemStatus = [];
                            message.msgNavigationBarUIItemStatus.push($root.UIBot.Common.MsgChangeNavigationBarUIItemStatus.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgChangeNavigationBarUIItemStatusList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatusList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgChangeNavigationBarUIItemStatusList} MsgChangeNavigationBarUIItemStatusList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgChangeNavigationBarUIItemStatusList.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgChangeNavigationBarUIItemStatusList message.
             * @function verify
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatusList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgChangeNavigationBarUIItemStatusList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.msgNavigationBarUIItemStatus != null && message.hasOwnProperty("msgNavigationBarUIItemStatus")) {
                    if (!Array.isArray(message.msgNavigationBarUIItemStatus))
                        return "msgNavigationBarUIItemStatus: array expected";
                    for (var i = 0; i < message.msgNavigationBarUIItemStatus.length; ++i) {
                        var error = $root.UIBot.Common.MsgChangeNavigationBarUIItemStatus.verify(message.msgNavigationBarUIItemStatus[i]);
                        if (error)
                            return "msgNavigationBarUIItemStatus." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MsgChangeNavigationBarUIItemStatusList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatusList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgChangeNavigationBarUIItemStatusList} MsgChangeNavigationBarUIItemStatusList
             */
            MsgChangeNavigationBarUIItemStatusList.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgChangeNavigationBarUIItemStatusList)
                    return object;
                var message = new $root.UIBot.Common.MsgChangeNavigationBarUIItemStatusList();
                if (object.msgNavigationBarUIItemStatus) {
                    if (!Array.isArray(object.msgNavigationBarUIItemStatus))
                        throw TypeError(".UIBot.Common.MsgChangeNavigationBarUIItemStatusList.msgNavigationBarUIItemStatus: array expected");
                    message.msgNavigationBarUIItemStatus = [];
                    for (var i = 0; i < object.msgNavigationBarUIItemStatus.length; ++i) {
                        if (typeof object.msgNavigationBarUIItemStatus[i] !== "object")
                            throw TypeError(".UIBot.Common.MsgChangeNavigationBarUIItemStatusList.msgNavigationBarUIItemStatus: object expected");
                        message.msgNavigationBarUIItemStatus[i] = $root.UIBot.Common.MsgChangeNavigationBarUIItemStatus.fromObject(object.msgNavigationBarUIItemStatus[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MsgChangeNavigationBarUIItemStatusList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatusList
             * @static
             * @param {UIBot.Common.MsgChangeNavigationBarUIItemStatusList} message MsgChangeNavigationBarUIItemStatusList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgChangeNavigationBarUIItemStatusList.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.msgNavigationBarUIItemStatus = [];
                if (message.msgNavigationBarUIItemStatus && message.msgNavigationBarUIItemStatus.length) {
                    object.msgNavigationBarUIItemStatus = [];
                    for (var j = 0; j < message.msgNavigationBarUIItemStatus.length; ++j)
                        object.msgNavigationBarUIItemStatus[j] = $root.UIBot.Common.MsgChangeNavigationBarUIItemStatus.toObject(message.msgNavigationBarUIItemStatus[j], options);
                }
                return object;
            };

            /**
             * Converts this MsgChangeNavigationBarUIItemStatusList to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatusList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgChangeNavigationBarUIItemStatusList.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgChangeNavigationBarUIItemStatusList
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgChangeNavigationBarUIItemStatusList
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgChangeNavigationBarUIItemStatusList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgChangeNavigationBarUIItemStatusList";
            };

            return MsgChangeNavigationBarUIItemStatusList;
        })();

        Common.MsgLayerFusionData = (function() {

            /**
             * Properties of a MsgLayerFusionData.
             * @memberof UIBot.Common
             * @interface IMsgLayerFusionData
             * @property {string} LayerName MsgLayerFusionData LayerName
             * @property {boolean|null} [IsVisible] MsgLayerFusionData IsVisible
             * @property {number|null} [BlendRatio] MsgLayerFusionData BlendRatio
             * @property {boolean|null} [IsSelected] MsgLayerFusionData IsSelected
             */

            /**
             * Constructs a new MsgLayerFusionData.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgLayerFusionData.
             * @implements IMsgLayerFusionData
             * @constructor
             * @param {UIBot.Common.IMsgLayerFusionData=} [properties] Properties to set
             */
            function MsgLayerFusionData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgLayerFusionData LayerName.
             * @member {string} LayerName
             * @memberof UIBot.Common.MsgLayerFusionData
             * @instance
             */
            MsgLayerFusionData.prototype.LayerName = "";

            /**
             * MsgLayerFusionData IsVisible.
             * @member {boolean} IsVisible
             * @memberof UIBot.Common.MsgLayerFusionData
             * @instance
             */
            MsgLayerFusionData.prototype.IsVisible = false;

            /**
             * MsgLayerFusionData BlendRatio.
             * @member {number} BlendRatio
             * @memberof UIBot.Common.MsgLayerFusionData
             * @instance
             */
            MsgLayerFusionData.prototype.BlendRatio = 0;

            /**
             * MsgLayerFusionData IsSelected.
             * @member {boolean} IsSelected
             * @memberof UIBot.Common.MsgLayerFusionData
             * @instance
             */
            MsgLayerFusionData.prototype.IsSelected = false;

            /**
             * Creates a new MsgLayerFusionData instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgLayerFusionData
             * @static
             * @param {UIBot.Common.IMsgLayerFusionData=} [properties] Properties to set
             * @returns {UIBot.Common.MsgLayerFusionData} MsgLayerFusionData instance
             */
            MsgLayerFusionData.create = function create(properties) {
                return new MsgLayerFusionData(properties);
            };

            /**
             * Encodes the specified MsgLayerFusionData message. Does not implicitly {@link UIBot.Common.MsgLayerFusionData.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgLayerFusionData
             * @static
             * @param {UIBot.Common.IMsgLayerFusionData} message MsgLayerFusionData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgLayerFusionData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.LayerName);
                if (message.IsVisible != null && Object.hasOwnProperty.call(message, "IsVisible"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.IsVisible);
                if (message.BlendRatio != null && Object.hasOwnProperty.call(message, "BlendRatio"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.BlendRatio);
                if (message.IsSelected != null && Object.hasOwnProperty.call(message, "IsSelected"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.IsSelected);
                return writer;
            };

            /**
             * Encodes the specified MsgLayerFusionData message, length delimited. Does not implicitly {@link UIBot.Common.MsgLayerFusionData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgLayerFusionData
             * @static
             * @param {UIBot.Common.IMsgLayerFusionData} message MsgLayerFusionData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgLayerFusionData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgLayerFusionData message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgLayerFusionData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgLayerFusionData} MsgLayerFusionData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgLayerFusionData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgLayerFusionData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.LayerName = reader.string();
                            break;
                        }
                    case 2: {
                            message.IsVisible = reader.bool();
                            break;
                        }
                    case 3: {
                            message.BlendRatio = reader.float();
                            break;
                        }
                    case 4: {
                            message.IsSelected = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("LayerName"))
                    throw $util.ProtocolError("missing required 'LayerName'", { instance: message });
                return message;
            };

            /**
             * Decodes a MsgLayerFusionData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgLayerFusionData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgLayerFusionData} MsgLayerFusionData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgLayerFusionData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgLayerFusionData message.
             * @function verify
             * @memberof UIBot.Common.MsgLayerFusionData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgLayerFusionData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.LayerName))
                    return "LayerName: string expected";
                if (message.IsVisible != null && message.hasOwnProperty("IsVisible"))
                    if (typeof message.IsVisible !== "boolean")
                        return "IsVisible: boolean expected";
                if (message.BlendRatio != null && message.hasOwnProperty("BlendRatio"))
                    if (typeof message.BlendRatio !== "number")
                        return "BlendRatio: number expected";
                if (message.IsSelected != null && message.hasOwnProperty("IsSelected"))
                    if (typeof message.IsSelected !== "boolean")
                        return "IsSelected: boolean expected";
                return null;
            };

            /**
             * Creates a MsgLayerFusionData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgLayerFusionData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgLayerFusionData} MsgLayerFusionData
             */
            MsgLayerFusionData.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgLayerFusionData)
                    return object;
                var message = new $root.UIBot.Common.MsgLayerFusionData();
                if (object.LayerName != null)
                    message.LayerName = String(object.LayerName);
                if (object.IsVisible != null)
                    message.IsVisible = Boolean(object.IsVisible);
                if (object.BlendRatio != null)
                    message.BlendRatio = Number(object.BlendRatio);
                if (object.IsSelected != null)
                    message.IsSelected = Boolean(object.IsSelected);
                return message;
            };

            /**
             * Creates a plain object from a MsgLayerFusionData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgLayerFusionData
             * @static
             * @param {UIBot.Common.MsgLayerFusionData} message MsgLayerFusionData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgLayerFusionData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.LayerName = "";
                    object.IsVisible = false;
                    object.BlendRatio = 0;
                    object.IsSelected = false;
                }
                if (message.LayerName != null && message.hasOwnProperty("LayerName"))
                    object.LayerName = message.LayerName;
                if (message.IsVisible != null && message.hasOwnProperty("IsVisible"))
                    object.IsVisible = message.IsVisible;
                if (message.BlendRatio != null && message.hasOwnProperty("BlendRatio"))
                    object.BlendRatio = options.json && !isFinite(message.BlendRatio) ? String(message.BlendRatio) : message.BlendRatio;
                if (message.IsSelected != null && message.hasOwnProperty("IsSelected"))
                    object.IsSelected = message.IsSelected;
                return object;
            };

            /**
             * Converts this MsgLayerFusionData to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgLayerFusionData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgLayerFusionData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgLayerFusionData
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgLayerFusionData
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgLayerFusionData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgLayerFusionData";
            };

            return MsgLayerFusionData;
        })();

        Common.MsgWorkStepFusionData = (function() {

            /**
             * Properties of a MsgWorkStepFusionData.
             * @memberof UIBot.Common
             * @interface IMsgWorkStepFusionData
             * @property {string} curStepName MsgWorkStepFusionData curStepName
             * @property {Array.<UIBot.Common.IMsgLayerFusionData>|null} [curLayerFusion] MsgWorkStepFusionData curLayerFusion
             */

            /**
             * Constructs a new MsgWorkStepFusionData.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgWorkStepFusionData.
             * @implements IMsgWorkStepFusionData
             * @constructor
             * @param {UIBot.Common.IMsgWorkStepFusionData=} [properties] Properties to set
             */
            function MsgWorkStepFusionData(properties) {
                this.curLayerFusion = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgWorkStepFusionData curStepName.
             * @member {string} curStepName
             * @memberof UIBot.Common.MsgWorkStepFusionData
             * @instance
             */
            MsgWorkStepFusionData.prototype.curStepName = "";

            /**
             * MsgWorkStepFusionData curLayerFusion.
             * @member {Array.<UIBot.Common.IMsgLayerFusionData>} curLayerFusion
             * @memberof UIBot.Common.MsgWorkStepFusionData
             * @instance
             */
            MsgWorkStepFusionData.prototype.curLayerFusion = $util.emptyArray;

            /**
             * Creates a new MsgWorkStepFusionData instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgWorkStepFusionData
             * @static
             * @param {UIBot.Common.IMsgWorkStepFusionData=} [properties] Properties to set
             * @returns {UIBot.Common.MsgWorkStepFusionData} MsgWorkStepFusionData instance
             */
            MsgWorkStepFusionData.create = function create(properties) {
                return new MsgWorkStepFusionData(properties);
            };

            /**
             * Encodes the specified MsgWorkStepFusionData message. Does not implicitly {@link UIBot.Common.MsgWorkStepFusionData.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgWorkStepFusionData
             * @static
             * @param {UIBot.Common.IMsgWorkStepFusionData} message MsgWorkStepFusionData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgWorkStepFusionData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.curStepName);
                if (message.curLayerFusion != null && message.curLayerFusion.length)
                    for (var i = 0; i < message.curLayerFusion.length; ++i)
                        $root.UIBot.Common.MsgLayerFusionData.encode(message.curLayerFusion[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MsgWorkStepFusionData message, length delimited. Does not implicitly {@link UIBot.Common.MsgWorkStepFusionData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgWorkStepFusionData
             * @static
             * @param {UIBot.Common.IMsgWorkStepFusionData} message MsgWorkStepFusionData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgWorkStepFusionData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgWorkStepFusionData message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgWorkStepFusionData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgWorkStepFusionData} MsgWorkStepFusionData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgWorkStepFusionData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgWorkStepFusionData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.curStepName = reader.string();
                            break;
                        }
                    case 2: {
                            if (!(message.curLayerFusion && message.curLayerFusion.length))
                                message.curLayerFusion = [];
                            message.curLayerFusion.push($root.UIBot.Common.MsgLayerFusionData.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("curStepName"))
                    throw $util.ProtocolError("missing required 'curStepName'", { instance: message });
                return message;
            };

            /**
             * Decodes a MsgWorkStepFusionData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgWorkStepFusionData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgWorkStepFusionData} MsgWorkStepFusionData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgWorkStepFusionData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgWorkStepFusionData message.
             * @function verify
             * @memberof UIBot.Common.MsgWorkStepFusionData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgWorkStepFusionData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.curStepName))
                    return "curStepName: string expected";
                if (message.curLayerFusion != null && message.hasOwnProperty("curLayerFusion")) {
                    if (!Array.isArray(message.curLayerFusion))
                        return "curLayerFusion: array expected";
                    for (var i = 0; i < message.curLayerFusion.length; ++i) {
                        var error = $root.UIBot.Common.MsgLayerFusionData.verify(message.curLayerFusion[i]);
                        if (error)
                            return "curLayerFusion." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MsgWorkStepFusionData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgWorkStepFusionData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgWorkStepFusionData} MsgWorkStepFusionData
             */
            MsgWorkStepFusionData.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgWorkStepFusionData)
                    return object;
                var message = new $root.UIBot.Common.MsgWorkStepFusionData();
                if (object.curStepName != null)
                    message.curStepName = String(object.curStepName);
                if (object.curLayerFusion) {
                    if (!Array.isArray(object.curLayerFusion))
                        throw TypeError(".UIBot.Common.MsgWorkStepFusionData.curLayerFusion: array expected");
                    message.curLayerFusion = [];
                    for (var i = 0; i < object.curLayerFusion.length; ++i) {
                        if (typeof object.curLayerFusion[i] !== "object")
                            throw TypeError(".UIBot.Common.MsgWorkStepFusionData.curLayerFusion: object expected");
                        message.curLayerFusion[i] = $root.UIBot.Common.MsgLayerFusionData.fromObject(object.curLayerFusion[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MsgWorkStepFusionData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgWorkStepFusionData
             * @static
             * @param {UIBot.Common.MsgWorkStepFusionData} message MsgWorkStepFusionData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgWorkStepFusionData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.curLayerFusion = [];
                if (options.defaults)
                    object.curStepName = "";
                if (message.curStepName != null && message.hasOwnProperty("curStepName"))
                    object.curStepName = message.curStepName;
                if (message.curLayerFusion && message.curLayerFusion.length) {
                    object.curLayerFusion = [];
                    for (var j = 0; j < message.curLayerFusion.length; ++j)
                        object.curLayerFusion[j] = $root.UIBot.Common.MsgLayerFusionData.toObject(message.curLayerFusion[j], options);
                }
                return object;
            };

            /**
             * Converts this MsgWorkStepFusionData to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgWorkStepFusionData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgWorkStepFusionData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgWorkStepFusionData
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgWorkStepFusionData
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgWorkStepFusionData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgWorkStepFusionData";
            };

            return MsgWorkStepFusionData;
        })();

        Common.MsgPatientInfo = (function() {

            /**
             * Properties of a MsgPatientInfo.
             * @memberof UIBot.Common
             * @interface IMsgPatientInfo
             * @property {string|null} [Name] MsgPatientInfo Name
             * @property {string|null} [Sex] MsgPatientInfo Sex
             * @property {string|null} [ImageNum] MsgPatientInfo ImageNum
             * @property {string|null} [BirthDate] MsgPatientInfo BirthDate
             * @property {Array.<string>|null} [StudyUIDs] MsgPatientInfo StudyUIDs
             */

            /**
             * Constructs a new MsgPatientInfo.
             * @memberof UIBot.Common
             * @classdesc Represents a MsgPatientInfo.
             * @implements IMsgPatientInfo
             * @constructor
             * @param {UIBot.Common.IMsgPatientInfo=} [properties] Properties to set
             */
            function MsgPatientInfo(properties) {
                this.StudyUIDs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgPatientInfo Name.
             * @member {string} Name
             * @memberof UIBot.Common.MsgPatientInfo
             * @instance
             */
            MsgPatientInfo.prototype.Name = "";

            /**
             * MsgPatientInfo Sex.
             * @member {string} Sex
             * @memberof UIBot.Common.MsgPatientInfo
             * @instance
             */
            MsgPatientInfo.prototype.Sex = "";

            /**
             * MsgPatientInfo ImageNum.
             * @member {string} ImageNum
             * @memberof UIBot.Common.MsgPatientInfo
             * @instance
             */
            MsgPatientInfo.prototype.ImageNum = "";

            /**
             * MsgPatientInfo BirthDate.
             * @member {string} BirthDate
             * @memberof UIBot.Common.MsgPatientInfo
             * @instance
             */
            MsgPatientInfo.prototype.BirthDate = "";

            /**
             * MsgPatientInfo StudyUIDs.
             * @member {Array.<string>} StudyUIDs
             * @memberof UIBot.Common.MsgPatientInfo
             * @instance
             */
            MsgPatientInfo.prototype.StudyUIDs = $util.emptyArray;

            /**
             * Creates a new MsgPatientInfo instance using the specified properties.
             * @function create
             * @memberof UIBot.Common.MsgPatientInfo
             * @static
             * @param {UIBot.Common.IMsgPatientInfo=} [properties] Properties to set
             * @returns {UIBot.Common.MsgPatientInfo} MsgPatientInfo instance
             */
            MsgPatientInfo.create = function create(properties) {
                return new MsgPatientInfo(properties);
            };

            /**
             * Encodes the specified MsgPatientInfo message. Does not implicitly {@link UIBot.Common.MsgPatientInfo.verify|verify} messages.
             * @function encode
             * @memberof UIBot.Common.MsgPatientInfo
             * @static
             * @param {UIBot.Common.IMsgPatientInfo} message MsgPatientInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgPatientInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Name != null && Object.hasOwnProperty.call(message, "Name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.Name);
                if (message.Sex != null && Object.hasOwnProperty.call(message, "Sex"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.Sex);
                if (message.ImageNum != null && Object.hasOwnProperty.call(message, "ImageNum"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.ImageNum);
                if (message.BirthDate != null && Object.hasOwnProperty.call(message, "BirthDate"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.BirthDate);
                if (message.StudyUIDs != null && message.StudyUIDs.length)
                    for (var i = 0; i < message.StudyUIDs.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.StudyUIDs[i]);
                return writer;
            };

            /**
             * Encodes the specified MsgPatientInfo message, length delimited. Does not implicitly {@link UIBot.Common.MsgPatientInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof UIBot.Common.MsgPatientInfo
             * @static
             * @param {UIBot.Common.IMsgPatientInfo} message MsgPatientInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgPatientInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgPatientInfo message from the specified reader or buffer.
             * @function decode
             * @memberof UIBot.Common.MsgPatientInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {UIBot.Common.MsgPatientInfo} MsgPatientInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgPatientInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.Common.MsgPatientInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.Name = reader.string();
                            break;
                        }
                    case 2: {
                            message.Sex = reader.string();
                            break;
                        }
                    case 3: {
                            message.ImageNum = reader.string();
                            break;
                        }
                    case 4: {
                            message.BirthDate = reader.string();
                            break;
                        }
                    case 5: {
                            if (!(message.StudyUIDs && message.StudyUIDs.length))
                                message.StudyUIDs = [];
                            message.StudyUIDs.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgPatientInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof UIBot.Common.MsgPatientInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {UIBot.Common.MsgPatientInfo} MsgPatientInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgPatientInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgPatientInfo message.
             * @function verify
             * @memberof UIBot.Common.MsgPatientInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgPatientInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.Name != null && message.hasOwnProperty("Name"))
                    if (!$util.isString(message.Name))
                        return "Name: string expected";
                if (message.Sex != null && message.hasOwnProperty("Sex"))
                    if (!$util.isString(message.Sex))
                        return "Sex: string expected";
                if (message.ImageNum != null && message.hasOwnProperty("ImageNum"))
                    if (!$util.isString(message.ImageNum))
                        return "ImageNum: string expected";
                if (message.BirthDate != null && message.hasOwnProperty("BirthDate"))
                    if (!$util.isString(message.BirthDate))
                        return "BirthDate: string expected";
                if (message.StudyUIDs != null && message.hasOwnProperty("StudyUIDs")) {
                    if (!Array.isArray(message.StudyUIDs))
                        return "StudyUIDs: array expected";
                    for (var i = 0; i < message.StudyUIDs.length; ++i)
                        if (!$util.isString(message.StudyUIDs[i]))
                            return "StudyUIDs: string[] expected";
                }
                return null;
            };

            /**
             * Creates a MsgPatientInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof UIBot.Common.MsgPatientInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {UIBot.Common.MsgPatientInfo} MsgPatientInfo
             */
            MsgPatientInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.UIBot.Common.MsgPatientInfo)
                    return object;
                var message = new $root.UIBot.Common.MsgPatientInfo();
                if (object.Name != null)
                    message.Name = String(object.Name);
                if (object.Sex != null)
                    message.Sex = String(object.Sex);
                if (object.ImageNum != null)
                    message.ImageNum = String(object.ImageNum);
                if (object.BirthDate != null)
                    message.BirthDate = String(object.BirthDate);
                if (object.StudyUIDs) {
                    if (!Array.isArray(object.StudyUIDs))
                        throw TypeError(".UIBot.Common.MsgPatientInfo.StudyUIDs: array expected");
                    message.StudyUIDs = [];
                    for (var i = 0; i < object.StudyUIDs.length; ++i)
                        message.StudyUIDs[i] = String(object.StudyUIDs[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a MsgPatientInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof UIBot.Common.MsgPatientInfo
             * @static
             * @param {UIBot.Common.MsgPatientInfo} message MsgPatientInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgPatientInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.StudyUIDs = [];
                if (options.defaults) {
                    object.Name = "";
                    object.Sex = "";
                    object.ImageNum = "";
                    object.BirthDate = "";
                }
                if (message.Name != null && message.hasOwnProperty("Name"))
                    object.Name = message.Name;
                if (message.Sex != null && message.hasOwnProperty("Sex"))
                    object.Sex = message.Sex;
                if (message.ImageNum != null && message.hasOwnProperty("ImageNum"))
                    object.ImageNum = message.ImageNum;
                if (message.BirthDate != null && message.hasOwnProperty("BirthDate"))
                    object.BirthDate = message.BirthDate;
                if (message.StudyUIDs && message.StudyUIDs.length) {
                    object.StudyUIDs = [];
                    for (var j = 0; j < message.StudyUIDs.length; ++j)
                        object.StudyUIDs[j] = message.StudyUIDs[j];
                }
                return object;
            };

            /**
             * Converts this MsgPatientInfo to JSON.
             * @function toJSON
             * @memberof UIBot.Common.MsgPatientInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgPatientInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MsgPatientInfo
             * @function getTypeUrl
             * @memberof UIBot.Common.MsgPatientInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MsgPatientInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/UIBot.Common.MsgPatientInfo";
            };

            return MsgPatientInfo;
        })();

        Common.ProtoBuf = (function() {

            /**
             * Namespace ProtoBuf.
             * @memberof UIBot.Common
             * @namespace
             */
            var ProtoBuf = {};

            return ProtoBuf;
        })();

        return Common;
    })();

    UIBot.UHOR = (function() {

        /**
         * Namespace UHOR.
         * @memberof UIBot
         * @namespace
         */
        var UHOR = {};

        UHOR.ProtoBuf = (function() {

            /**
             * Namespace ProtoBuf.
             * @memberof UIBot.UHOR
             * @namespace
             */
            var ProtoBuf = {};

            /**
             * LoadLevel enum.
             * @name UIBot.UHOR.ProtoBuf.LoadLevel
             * @enum {number}
             * @property {number} Patient=0 Patient value
             * @property {number} Study=1 Study value
             * @property {number} Series=2 Series value
             * @property {number} Image=3 Image value
             */
            ProtoBuf.LoadLevel = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Patient"] = 0;
                values[valuesById[1] = "Study"] = 1;
                values[valuesById[2] = "Series"] = 2;
                values[valuesById[3] = "Image"] = 3;
                return values;
            })();

            /**
             * SeriseType enum.
             * @name UIBot.UHOR.ProtoBuf.SeriseType
             * @enum {number}
             * @property {number} SeriseT1=0 SeriseT1 value
             * @property {number} SeriseT2=1 SeriseT2 value
             * @property {number} SeriseBold=2 SeriseBold value
             * @property {number} SeriseDTI=3 SeriseDTI value
             * @property {number} SeriseFlair=4 SeriseFlair value
             * @property {number} SeriseSWI=5 SeriseSWI value
             * @property {number} SeriseNone=6 SeriseNone value
             */
            ProtoBuf.SeriseType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SeriseT1"] = 0;
                values[valuesById[1] = "SeriseT2"] = 1;
                values[valuesById[2] = "SeriseBold"] = 2;
                values[valuesById[3] = "SeriseDTI"] = 3;
                values[valuesById[4] = "SeriseFlair"] = 4;
                values[valuesById[5] = "SeriseSWI"] = 5;
                values[valuesById[6] = "SeriseNone"] = 6;
                return values;
            })();

            /**
             * NeuroSeriseType enum.
             * @name UIBot.UHOR.ProtoBuf.NeuroSeriseType
             * @enum {number}
             * @property {number} NormalSerise=0 NormalSerise value
             * @property {number} DTIResultSerise=1 DTIResultSerise value
             * @property {number} BoldResultSerise=2 BoldResultSerise value
             * @property {number} PlanningResultSerise=3 PlanningResultSerise value
             * @property {number} CTA=4 CTA value
             * @property {number} PCA=5 PCA value
             * @property {number} T1=6 T1 value
             * @property {number} T2=7 T2 value
             * @property {number} T1_Flair=8 T1_Flair value
             * @property {number} T2_Flair=9 T2_Flair value
             * @property {number} T1_C=10 T1_C value
             * @property {number} T2_C=11 T2_C value
             * @property {number} T1_Flair_C=12 T1_Flair_C value
             * @property {number} T2_Flair_C=13 T2_Flair_C value
             */
            ProtoBuf.NeuroSeriseType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NormalSerise"] = 0;
                values[valuesById[1] = "DTIResultSerise"] = 1;
                values[valuesById[2] = "BoldResultSerise"] = 2;
                values[valuesById[3] = "PlanningResultSerise"] = 3;
                values[valuesById[4] = "CTA"] = 4;
                values[valuesById[5] = "PCA"] = 5;
                values[valuesById[6] = "T1"] = 6;
                values[valuesById[7] = "T2"] = 7;
                values[valuesById[8] = "T1_Flair"] = 8;
                values[valuesById[9] = "T2_Flair"] = 9;
                values[valuesById[10] = "T1_C"] = 10;
                values[valuesById[11] = "T2_C"] = 11;
                values[valuesById[12] = "T1_Flair_C"] = 12;
                values[valuesById[13] = "T2_Flair_C"] = 13;
                return values;
            })();

            /**
             * InterpolationOperationType enum.
             * @name UIBot.UHOR.ProtoBuf.InterpolationOperationType
             * @enum {number}
             * @property {number} ChangeOpacity=1 ChangeOpacity value
             * @property {number} ChangeVisible=2 ChangeVisible value
             */
            ProtoBuf.InterpolationOperationType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "ChangeOpacity"] = 1;
                values[valuesById[2] = "ChangeVisible"] = 2;
                return values;
            })();

            /**
             * NeuroErrorCode enum.
             * @name UIBot.UHOR.ProtoBuf.NeuroErrorCode
             * @enum {number}
             * @property {number} Neuro_Success=0 Neuro_Success value
             * @property {number} Neuro_Bold_Error=257 Neuro_Bold_Error value
             * @property {number} Neuro_Bold_Missing_Active_Region_Error=258 Neuro_Bold_Missing_Active_Region_Error value
             * @property {number} Neuro_Bold_Protocol_Info_Error=259 Neuro_Bold_Protocol_Info_Error value
             * @property {number} Neuro_DTI_Error=769 Neuro_DTI_Error value
             * @property {number} Neuro_DTI_Outside_Volume_Error=770 Neuro_DTI_Outside_Volume_Error value
             * @property {number} Neuro_Hemorhage_Vessel_Segment_Error=1281 Neuro_Hemorhage_Vessel_Segment_Error value
             * @property {number} Neuro_Hemorhage_Hemorrhage_Segment_Error=1282 Neuro_Hemorhage_Hemorrhage_Segment_Error value
             * @property {number} Neuro_Hemorhage_Hydroncus_Segment_Error=1283 Neuro_Hemorhage_Hydroncus_Segment_Error value
             * @property {number} Neuro_Hemorhage_Skull_Extraction_Error=1284 Neuro_Hemorhage_Skull_Extraction_Error value
             * @property {number} Neuro_Hemorhage_DrainageTube_Extraction_Error=1285 Neuro_Hemorhage_DrainageTube_Extraction_Error value
             * @property {number} Neuro_TumorBiopsies_Vessel_Segment_Error=1793 Neuro_TumorBiopsies_Vessel_Segment_Error value
             * @property {number} Neuro_TumorBiopsies_TumorBiopsies_Segment_Error=1794 Neuro_TumorBiopsies_TumorBiopsies_Segment_Error value
             * @property {number} Neuro_DBS_Vessel_Segment_Error=2305 Neuro_DBS_Vessel_Segment_Error value
             * @property {number} Neuro_DBS_BrainAltlases_Error=2306 Neuro_DBS_BrainAltlases_Error value
             * @property {number} Neuro_DBS_ACPCVolumeUIDMatchCurrentVolumeUID_Error=2307 Neuro_DBS_ACPCVolumeUIDMatchCurrentVolumeUID_Error value
             * @property {number} Neuro_DBS_CorticalLandmarkCalculate_Error=2308 Neuro_DBS_CorticalLandmarkCalculate_Error value
             * @property {number} Neuro_DBS_EditBrainAtlases_Error=2309 Neuro_DBS_EditBrainAtlases_Error value
             * @property {number} Neuro_SEEG_Vessel_Segment_Error=2817 Neuro_SEEG_Vessel_Segment_Error value
             * @property {number} Neuro_SEEG_Cucoloris_Error=2818 Neuro_SEEG_Cucoloris_Error value
             * @property {number} Neuro_SEEG_Brain_Segmentation_Error=2819 Neuro_SEEG_Brain_Segmentation_Error value
             * @property {number} Neuro_Common_Marker_Auto_Add_Nail_Error=8193 Neuro_Common_Marker_Auto_Add_Nail_Error value
             * @property {number} Neuro_Common_Marker_Auto_Add_Sphere_Error=8194 Neuro_Common_Marker_Auto_Add_Sphere_Error value
             * @property {number} Neuro_Common_Marker_Add_Marker_Duplicate_Error=8195 Neuro_Common_Marker_Add_Marker_Duplicate_Error value
             * @property {number} Neuro_Common_Marker_Add_Marker_Limit_Exceeded_Error=8196 Neuro_Common_Marker_Add_Marker_Limit_Exceeded_Error value
             * @property {number} Neuro_Common_ParcellationDKT_Error=8197 Neuro_Common_ParcellationDKT_Error value
             * @property {number} Neuro_Common_BedboardRemovement_Error=8198 Neuro_Common_BedboardRemovement_Error value
             * @property {number} Neuro_Common_NucleiExtract_Error=8199 Neuro_Common_NucleiExtract_Error value
             * @property {number} Neuro_Common_TissueGrow_Error=8200 Neuro_Common_TissueGrow_Error value
             * @property {number} Neuro_Common_MultiPointsConnection_Error=8201 Neuro_Common_MultiPointsConnection_Error value
             * @property {number} Neuro_Common_Upload_Error=8202 Neuro_Common_Upload_Error value
             * @property {number} Neuro_Common_Upload_Success=8203 Neuro_Common_Upload_Success value
             * @property {number} Neuro_Common_No_Exit_User_Error=8204 Neuro_Common_No_Exit_User_Error value
             * @property {number} Neuro_Common_Could_Not_Connect_Error=8205 Neuro_Common_Could_Not_Connect_Error value
             * @property {number} Neuro_DataChecking_Validate_Error=12289 Neuro_DataChecking_Validate_Error value
             * @property {number} Neuro_DataChecking_Dicom_Empty_Error=12290 Neuro_DataChecking_Dicom_Empty_Error value
             * @property {number} Neuro_DataChecking_Dicom_Absence_Error=12291 Neuro_DataChecking_Dicom_Absence_Error value
             * @property {number} Neuro_DataChecking_Dicom_Ori_Error=12292 Neuro_DataChecking_Dicom_Ori_Error value
             * @property {number} Neuro_DataChecking_Dicom_Space_Error=12293 Neuro_DataChecking_Dicom_Space_Error value
             * @property {number} Neuro_DataChecking_Serise_Number_Error=12294 Neuro_DataChecking_Serise_Number_Error value
             * @property {number} Neuro_DataChecking_DTI_Missing_Ref_Sequence_Error=12295 Neuro_DataChecking_DTI_Missing_Ref_Sequence_Error value
             * @property {number} Neuro_DataChecking_BOLD_Missing_Ref_Sequence_Error=12296 Neuro_DataChecking_BOLD_Missing_Ref_Sequence_Error value
             * @property {number} Neuro_DataChecking_Result_Not_Match_Error=12297 Neuro_DataChecking_Result_Not_Match_Error value
             * @property {number} Neuro_DataChecking_Result_Sequence_Error=12301 Neuro_DataChecking_Result_Sequence_Error value
             * @property {number} Neuro_DataChecking_Load_Series_Error=12302 Neuro_DataChecking_Load_Series_Error value
             * @property {number} Neuro_LoadPlanningResult_OtherApp_Error=16385 Neuro_LoadPlanningResult_OtherApp_Error value
             * @property {number} Neuro_LoadPlanningResult_LoadData_Error=16386 Neuro_LoadPlanningResult_LoadData_Error value
             * @property {number} Neuro_SavePlanningResult_SaveData_Success=16387 Neuro_SavePlanningResult_SaveData_Success value
             * @property {number} Neruo_SavePlanningResult_SaveData_Fail=16388 Neruo_SavePlanningResult_SaveData_Fail value
             * @property {number} Neruo_SavePlanningResult_SaveFiber_TooMuch=16389 Neruo_SavePlanningResult_SaveFiber_TooMuch value
             */
            ProtoBuf.NeuroErrorCode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Neuro_Success"] = 0;
                values[valuesById[257] = "Neuro_Bold_Error"] = 257;
                values[valuesById[258] = "Neuro_Bold_Missing_Active_Region_Error"] = 258;
                values[valuesById[259] = "Neuro_Bold_Protocol_Info_Error"] = 259;
                values[valuesById[769] = "Neuro_DTI_Error"] = 769;
                values[valuesById[770] = "Neuro_DTI_Outside_Volume_Error"] = 770;
                values[valuesById[1281] = "Neuro_Hemorhage_Vessel_Segment_Error"] = 1281;
                values[valuesById[1282] = "Neuro_Hemorhage_Hemorrhage_Segment_Error"] = 1282;
                values[valuesById[1283] = "Neuro_Hemorhage_Hydroncus_Segment_Error"] = 1283;
                values[valuesById[1284] = "Neuro_Hemorhage_Skull_Extraction_Error"] = 1284;
                values[valuesById[1285] = "Neuro_Hemorhage_DrainageTube_Extraction_Error"] = 1285;
                values[valuesById[1793] = "Neuro_TumorBiopsies_Vessel_Segment_Error"] = 1793;
                values[valuesById[1794] = "Neuro_TumorBiopsies_TumorBiopsies_Segment_Error"] = 1794;
                values[valuesById[2305] = "Neuro_DBS_Vessel_Segment_Error"] = 2305;
                values[valuesById[2306] = "Neuro_DBS_BrainAltlases_Error"] = 2306;
                values[valuesById[2307] = "Neuro_DBS_ACPCVolumeUIDMatchCurrentVolumeUID_Error"] = 2307;
                values[valuesById[2308] = "Neuro_DBS_CorticalLandmarkCalculate_Error"] = 2308;
                values[valuesById[2309] = "Neuro_DBS_EditBrainAtlases_Error"] = 2309;
                values[valuesById[2817] = "Neuro_SEEG_Vessel_Segment_Error"] = 2817;
                values[valuesById[2818] = "Neuro_SEEG_Cucoloris_Error"] = 2818;
                values[valuesById[2819] = "Neuro_SEEG_Brain_Segmentation_Error"] = 2819;
                values[valuesById[8193] = "Neuro_Common_Marker_Auto_Add_Nail_Error"] = 8193;
                values[valuesById[8194] = "Neuro_Common_Marker_Auto_Add_Sphere_Error"] = 8194;
                values[valuesById[8195] = "Neuro_Common_Marker_Add_Marker_Duplicate_Error"] = 8195;
                values[valuesById[8196] = "Neuro_Common_Marker_Add_Marker_Limit_Exceeded_Error"] = 8196;
                values[valuesById[8197] = "Neuro_Common_ParcellationDKT_Error"] = 8197;
                values[valuesById[8198] = "Neuro_Common_BedboardRemovement_Error"] = 8198;
                values[valuesById[8199] = "Neuro_Common_NucleiExtract_Error"] = 8199;
                values[valuesById[8200] = "Neuro_Common_TissueGrow_Error"] = 8200;
                values[valuesById[8201] = "Neuro_Common_MultiPointsConnection_Error"] = 8201;
                values[valuesById[8202] = "Neuro_Common_Upload_Error"] = 8202;
                values[valuesById[8203] = "Neuro_Common_Upload_Success"] = 8203;
                values[valuesById[8204] = "Neuro_Common_No_Exit_User_Error"] = 8204;
                values[valuesById[8205] = "Neuro_Common_Could_Not_Connect_Error"] = 8205;
                values[valuesById[12289] = "Neuro_DataChecking_Validate_Error"] = 12289;
                values[valuesById[12290] = "Neuro_DataChecking_Dicom_Empty_Error"] = 12290;
                values[valuesById[12291] = "Neuro_DataChecking_Dicom_Absence_Error"] = 12291;
                values[valuesById[12292] = "Neuro_DataChecking_Dicom_Ori_Error"] = 12292;
                values[valuesById[12293] = "Neuro_DataChecking_Dicom_Space_Error"] = 12293;
                values[valuesById[12294] = "Neuro_DataChecking_Serise_Number_Error"] = 12294;
                values[valuesById[12295] = "Neuro_DataChecking_DTI_Missing_Ref_Sequence_Error"] = 12295;
                values[valuesById[12296] = "Neuro_DataChecking_BOLD_Missing_Ref_Sequence_Error"] = 12296;
                values[valuesById[12297] = "Neuro_DataChecking_Result_Not_Match_Error"] = 12297;
                values[valuesById[12301] = "Neuro_DataChecking_Result_Sequence_Error"] = 12301;
                values[valuesById[12302] = "Neuro_DataChecking_Load_Series_Error"] = 12302;
                values[valuesById[16385] = "Neuro_LoadPlanningResult_OtherApp_Error"] = 16385;
                values[valuesById[16386] = "Neuro_LoadPlanningResult_LoadData_Error"] = 16386;
                values[valuesById[16387] = "Neuro_SavePlanningResult_SaveData_Success"] = 16387;
                values[valuesById[16388] = "Neruo_SavePlanningResult_SaveData_Fail"] = 16388;
                values[valuesById[16389] = "Neruo_SavePlanningResult_SaveFiber_TooMuch"] = 16389;
                return values;
            })();

            /**
             * EnumPage enum.
             * @name UIBot.UHOR.ProtoBuf.EnumPage
             * @enum {number}
             * @property {number} Registration=0 Registration value
             * @property {number} Segment=1 Segment value
             * @property {number} PlanningStep=2 PlanningStep value
             * @property {number} DTI=3 DTI value
             */
            ProtoBuf.EnumPage = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Registration"] = 0;
                values[valuesById[1] = "Segment"] = 1;
                values[valuesById[2] = "PlanningStep"] = 2;
                values[valuesById[3] = "DTI"] = 3;
                return values;
            })();

            /**
             * EnumTumorExpandSimulationAction enum.
             * @name UIBot.UHOR.ProtoBuf.EnumTumorExpandSimulationAction
             * @enum {number}
             * @property {number} Open=0 Open value
             * @property {number} Close=1 Close value
             */
            ProtoBuf.EnumTumorExpandSimulationAction = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Open"] = 0;
                values[valuesById[1] = "Close"] = 1;
                return values;
            })();

            /**
             * EnumRegistrationType enum.
             * @name UIBot.UHOR.ProtoBuf.EnumRegistrationType
             * @enum {number}
             * @property {number} RoughAndPrecis=0 RoughAndPrecis value
             * @property {number} OnlyRough=1 OnlyRough value
             */
            ProtoBuf.EnumRegistrationType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "RoughAndPrecis"] = 0;
                values[valuesById[1] = "OnlyRough"] = 1;
                return values;
            })();

            ProtoBuf.Point2DInt = (function() {

                /**
                 * Properties of a Point2DInt.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IPoint2DInt
                 * @property {number|null} [x] Point2DInt x
                 * @property {number|null} [y] Point2DInt y
                 */

                /**
                 * Constructs a new Point2DInt.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a Point2DInt.
                 * @implements IPoint2DInt
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IPoint2DInt=} [properties] Properties to set
                 */
                function Point2DInt(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Point2DInt x.
                 * @member {number} x
                 * @memberof UIBot.UHOR.ProtoBuf.Point2DInt
                 * @instance
                 */
                Point2DInt.prototype.x = 0;

                /**
                 * Point2DInt y.
                 * @member {number} y
                 * @memberof UIBot.UHOR.ProtoBuf.Point2DInt
                 * @instance
                 */
                Point2DInt.prototype.y = 0;

                /**
                 * Creates a new Point2DInt instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.Point2DInt
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IPoint2DInt=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.Point2DInt} Point2DInt instance
                 */
                Point2DInt.create = function create(properties) {
                    return new Point2DInt(properties);
                };

                /**
                 * Encodes the specified Point2DInt message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.Point2DInt.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.Point2DInt
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IPoint2DInt} message Point2DInt message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Point2DInt.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.x);
                    if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.y);
                    return writer;
                };

                /**
                 * Encodes the specified Point2DInt message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.Point2DInt.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.Point2DInt
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IPoint2DInt} message Point2DInt message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Point2DInt.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Point2DInt message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.Point2DInt
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.Point2DInt} Point2DInt
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Point2DInt.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.Point2DInt();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.x = reader.int32();
                                break;
                            }
                        case 2: {
                                message.y = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Point2DInt message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.Point2DInt
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.Point2DInt} Point2DInt
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Point2DInt.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Point2DInt message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.Point2DInt
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Point2DInt.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.x != null && message.hasOwnProperty("x"))
                        if (!$util.isInteger(message.x))
                            return "x: integer expected";
                    if (message.y != null && message.hasOwnProperty("y"))
                        if (!$util.isInteger(message.y))
                            return "y: integer expected";
                    return null;
                };

                /**
                 * Creates a Point2DInt message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.Point2DInt
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.Point2DInt} Point2DInt
                 */
                Point2DInt.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.Point2DInt)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.Point2DInt();
                    if (object.x != null)
                        message.x = object.x | 0;
                    if (object.y != null)
                        message.y = object.y | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a Point2DInt message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.Point2DInt
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.Point2DInt} message Point2DInt
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Point2DInt.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.x = 0;
                        object.y = 0;
                    }
                    if (message.x != null && message.hasOwnProperty("x"))
                        object.x = message.x;
                    if (message.y != null && message.hasOwnProperty("y"))
                        object.y = message.y;
                    return object;
                };

                /**
                 * Converts this Point2DInt to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.Point2DInt
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Point2DInt.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Point2DInt
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.Point2DInt
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Point2DInt.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.Point2DInt";
                };

                return Point2DInt;
            })();

            ProtoBuf.Point3DDouble = (function() {

                /**
                 * Properties of a Point3DDouble.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IPoint3DDouble
                 * @property {number|null} [x] Point3DDouble x
                 * @property {number|null} [y] Point3DDouble y
                 * @property {number|null} [z] Point3DDouble z
                 */

                /**
                 * Constructs a new Point3DDouble.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a Point3DDouble.
                 * @implements IPoint3DDouble
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IPoint3DDouble=} [properties] Properties to set
                 */
                function Point3DDouble(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Point3DDouble x.
                 * @member {number} x
                 * @memberof UIBot.UHOR.ProtoBuf.Point3DDouble
                 * @instance
                 */
                Point3DDouble.prototype.x = 0;

                /**
                 * Point3DDouble y.
                 * @member {number} y
                 * @memberof UIBot.UHOR.ProtoBuf.Point3DDouble
                 * @instance
                 */
                Point3DDouble.prototype.y = 0;

                /**
                 * Point3DDouble z.
                 * @member {number} z
                 * @memberof UIBot.UHOR.ProtoBuf.Point3DDouble
                 * @instance
                 */
                Point3DDouble.prototype.z = 0;

                /**
                 * Creates a new Point3DDouble instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.Point3DDouble
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IPoint3DDouble=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.Point3DDouble} Point3DDouble instance
                 */
                Point3DDouble.create = function create(properties) {
                    return new Point3DDouble(properties);
                };

                /**
                 * Encodes the specified Point3DDouble message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.Point3DDouble.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.Point3DDouble
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IPoint3DDouble} message Point3DDouble message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Point3DDouble.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.x);
                    if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.y);
                    if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.z);
                    return writer;
                };

                /**
                 * Encodes the specified Point3DDouble message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.Point3DDouble.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.Point3DDouble
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IPoint3DDouble} message Point3DDouble message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Point3DDouble.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Point3DDouble message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.Point3DDouble
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.Point3DDouble} Point3DDouble
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Point3DDouble.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.Point3DDouble();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.x = reader.double();
                                break;
                            }
                        case 2: {
                                message.y = reader.double();
                                break;
                            }
                        case 3: {
                                message.z = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Point3DDouble message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.Point3DDouble
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.Point3DDouble} Point3DDouble
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Point3DDouble.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Point3DDouble message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.Point3DDouble
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Point3DDouble.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.x != null && message.hasOwnProperty("x"))
                        if (typeof message.x !== "number")
                            return "x: number expected";
                    if (message.y != null && message.hasOwnProperty("y"))
                        if (typeof message.y !== "number")
                            return "y: number expected";
                    if (message.z != null && message.hasOwnProperty("z"))
                        if (typeof message.z !== "number")
                            return "z: number expected";
                    return null;
                };

                /**
                 * Creates a Point3DDouble message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.Point3DDouble
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.Point3DDouble} Point3DDouble
                 */
                Point3DDouble.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.Point3DDouble)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.Point3DDouble();
                    if (object.x != null)
                        message.x = Number(object.x);
                    if (object.y != null)
                        message.y = Number(object.y);
                    if (object.z != null)
                        message.z = Number(object.z);
                    return message;
                };

                /**
                 * Creates a plain object from a Point3DDouble message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.Point3DDouble
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.Point3DDouble} message Point3DDouble
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Point3DDouble.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.x = 0;
                        object.y = 0;
                        object.z = 0;
                    }
                    if (message.x != null && message.hasOwnProperty("x"))
                        object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
                    if (message.y != null && message.hasOwnProperty("y"))
                        object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
                    if (message.z != null && message.hasOwnProperty("z"))
                        object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
                    return object;
                };

                /**
                 * Converts this Point3DDouble to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.Point3DDouble
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Point3DDouble.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Point3DDouble
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.Point3DDouble
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Point3DDouble.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.Point3DDouble";
                };

                return Point3DDouble;
            })();

            ProtoBuf.MsgPointList = (function() {

                /**
                 * Properties of a MsgPointList.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMsgPointList
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IPoint2DInt>|null} [PointList] MsgPointList PointList
                 */

                /**
                 * Constructs a new MsgPointList.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MsgPointList.
                 * @implements IMsgPointList
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMsgPointList=} [properties] Properties to set
                 */
                function MsgPointList(properties) {
                    this.PointList = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MsgPointList PointList.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IPoint2DInt>} PointList
                 * @memberof UIBot.UHOR.ProtoBuf.MsgPointList
                 * @instance
                 */
                MsgPointList.prototype.PointList = $util.emptyArray;

                /**
                 * Creates a new MsgPointList instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MsgPointList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgPointList=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MsgPointList} MsgPointList instance
                 */
                MsgPointList.create = function create(properties) {
                    return new MsgPointList(properties);
                };

                /**
                 * Encodes the specified MsgPointList message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgPointList.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgPointList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgPointList} message MsgPointList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgPointList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.PointList != null && message.PointList.length)
                        for (var i = 0; i < message.PointList.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.Point2DInt.encode(message.PointList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MsgPointList message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgPointList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgPointList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgPointList} message MsgPointList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgPointList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MsgPointList message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgPointList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MsgPointList} MsgPointList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgPointList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MsgPointList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.PointList && message.PointList.length))
                                    message.PointList = [];
                                message.PointList.push($root.UIBot.UHOR.ProtoBuf.Point2DInt.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MsgPointList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgPointList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MsgPointList} MsgPointList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgPointList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MsgPointList message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MsgPointList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgPointList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.PointList != null && message.hasOwnProperty("PointList")) {
                        if (!Array.isArray(message.PointList))
                            return "PointList: array expected";
                        for (var i = 0; i < message.PointList.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.Point2DInt.verify(message.PointList[i]);
                            if (error)
                                return "PointList." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MsgPointList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgPointList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MsgPointList} MsgPointList
                 */
                MsgPointList.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MsgPointList)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MsgPointList();
                    if (object.PointList) {
                        if (!Array.isArray(object.PointList))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgPointList.PointList: array expected");
                        message.PointList = [];
                        for (var i = 0; i < object.PointList.length; ++i) {
                            if (typeof object.PointList[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MsgPointList.PointList: object expected");
                            message.PointList[i] = $root.UIBot.UHOR.ProtoBuf.Point2DInt.fromObject(object.PointList[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MsgPointList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgPointList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MsgPointList} message MsgPointList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgPointList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.PointList = [];
                    if (message.PointList && message.PointList.length) {
                        object.PointList = [];
                        for (var j = 0; j < message.PointList.length; ++j)
                            object.PointList[j] = $root.UIBot.UHOR.ProtoBuf.Point2DInt.toObject(message.PointList[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MsgPointList to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MsgPointList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgPointList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MsgPointList
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MsgPointList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MsgPointList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MsgPointList";
                };

                return MsgPointList;
            })();

            ProtoBuf.PatientInfo = (function() {

                /**
                 * Properties of a PatientInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IPatientInfo
                 * @property {string|null} [UID] PatientInfo UID
                 * @property {string|null} [ID] PatientInfo ID
                 * @property {string|null} [Name] PatientInfo Name
                 * @property {string|null} [Gender] PatientInfo Gender
                 * @property {string|null} [Age] PatientInfo Age
                 * @property {string|null} [DateOfBirth] PatientInfo DateOfBirth
                 * @property {string|null} [AccumulatedDosage] PatientInfo AccumulatedDosage
                 */

                /**
                 * Constructs a new PatientInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a PatientInfo.
                 * @implements IPatientInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IPatientInfo=} [properties] Properties to set
                 */
                function PatientInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PatientInfo UID.
                 * @member {string} UID
                 * @memberof UIBot.UHOR.ProtoBuf.PatientInfo
                 * @instance
                 */
                PatientInfo.prototype.UID = "";

                /**
                 * PatientInfo ID.
                 * @member {string} ID
                 * @memberof UIBot.UHOR.ProtoBuf.PatientInfo
                 * @instance
                 */
                PatientInfo.prototype.ID = "";

                /**
                 * PatientInfo Name.
                 * @member {string} Name
                 * @memberof UIBot.UHOR.ProtoBuf.PatientInfo
                 * @instance
                 */
                PatientInfo.prototype.Name = "";

                /**
                 * PatientInfo Gender.
                 * @member {string} Gender
                 * @memberof UIBot.UHOR.ProtoBuf.PatientInfo
                 * @instance
                 */
                PatientInfo.prototype.Gender = "";

                /**
                 * PatientInfo Age.
                 * @member {string} Age
                 * @memberof UIBot.UHOR.ProtoBuf.PatientInfo
                 * @instance
                 */
                PatientInfo.prototype.Age = "";

                /**
                 * PatientInfo DateOfBirth.
                 * @member {string} DateOfBirth
                 * @memberof UIBot.UHOR.ProtoBuf.PatientInfo
                 * @instance
                 */
                PatientInfo.prototype.DateOfBirth = "";

                /**
                 * PatientInfo AccumulatedDosage.
                 * @member {string} AccumulatedDosage
                 * @memberof UIBot.UHOR.ProtoBuf.PatientInfo
                 * @instance
                 */
                PatientInfo.prototype.AccumulatedDosage = "";

                /**
                 * Creates a new PatientInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.PatientInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IPatientInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.PatientInfo} PatientInfo instance
                 */
                PatientInfo.create = function create(properties) {
                    return new PatientInfo(properties);
                };

                /**
                 * Encodes the specified PatientInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.PatientInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.PatientInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IPatientInfo} message PatientInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PatientInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.UID != null && Object.hasOwnProperty.call(message, "UID"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.UID);
                    if (message.ID != null && Object.hasOwnProperty.call(message, "ID"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.ID);
                    if (message.Name != null && Object.hasOwnProperty.call(message, "Name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.Name);
                    if (message.Gender != null && Object.hasOwnProperty.call(message, "Gender"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.Gender);
                    if (message.Age != null && Object.hasOwnProperty.call(message, "Age"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.Age);
                    if (message.DateOfBirth != null && Object.hasOwnProperty.call(message, "DateOfBirth"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.DateOfBirth);
                    if (message.AccumulatedDosage != null && Object.hasOwnProperty.call(message, "AccumulatedDosage"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.AccumulatedDosage);
                    return writer;
                };

                /**
                 * Encodes the specified PatientInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.PatientInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.PatientInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IPatientInfo} message PatientInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PatientInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PatientInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.PatientInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.PatientInfo} PatientInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PatientInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.PatientInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.UID = reader.string();
                                break;
                            }
                        case 2: {
                                message.ID = reader.string();
                                break;
                            }
                        case 3: {
                                message.Name = reader.string();
                                break;
                            }
                        case 4: {
                                message.Gender = reader.string();
                                break;
                            }
                        case 5: {
                                message.Age = reader.string();
                                break;
                            }
                        case 6: {
                                message.DateOfBirth = reader.string();
                                break;
                            }
                        case 7: {
                                message.AccumulatedDosage = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PatientInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.PatientInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.PatientInfo} PatientInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PatientInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PatientInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.PatientInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PatientInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.UID != null && message.hasOwnProperty("UID"))
                        if (!$util.isString(message.UID))
                            return "UID: string expected";
                    if (message.ID != null && message.hasOwnProperty("ID"))
                        if (!$util.isString(message.ID))
                            return "ID: string expected";
                    if (message.Name != null && message.hasOwnProperty("Name"))
                        if (!$util.isString(message.Name))
                            return "Name: string expected";
                    if (message.Gender != null && message.hasOwnProperty("Gender"))
                        if (!$util.isString(message.Gender))
                            return "Gender: string expected";
                    if (message.Age != null && message.hasOwnProperty("Age"))
                        if (!$util.isString(message.Age))
                            return "Age: string expected";
                    if (message.DateOfBirth != null && message.hasOwnProperty("DateOfBirth"))
                        if (!$util.isString(message.DateOfBirth))
                            return "DateOfBirth: string expected";
                    if (message.AccumulatedDosage != null && message.hasOwnProperty("AccumulatedDosage"))
                        if (!$util.isString(message.AccumulatedDosage))
                            return "AccumulatedDosage: string expected";
                    return null;
                };

                /**
                 * Creates a PatientInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.PatientInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.PatientInfo} PatientInfo
                 */
                PatientInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.PatientInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.PatientInfo();
                    if (object.UID != null)
                        message.UID = String(object.UID);
                    if (object.ID != null)
                        message.ID = String(object.ID);
                    if (object.Name != null)
                        message.Name = String(object.Name);
                    if (object.Gender != null)
                        message.Gender = String(object.Gender);
                    if (object.Age != null)
                        message.Age = String(object.Age);
                    if (object.DateOfBirth != null)
                        message.DateOfBirth = String(object.DateOfBirth);
                    if (object.AccumulatedDosage != null)
                        message.AccumulatedDosage = String(object.AccumulatedDosage);
                    return message;
                };

                /**
                 * Creates a plain object from a PatientInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.PatientInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.PatientInfo} message PatientInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PatientInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.UID = "";
                        object.ID = "";
                        object.Name = "";
                        object.Gender = "";
                        object.Age = "";
                        object.DateOfBirth = "";
                        object.AccumulatedDosage = "";
                    }
                    if (message.UID != null && message.hasOwnProperty("UID"))
                        object.UID = message.UID;
                    if (message.ID != null && message.hasOwnProperty("ID"))
                        object.ID = message.ID;
                    if (message.Name != null && message.hasOwnProperty("Name"))
                        object.Name = message.Name;
                    if (message.Gender != null && message.hasOwnProperty("Gender"))
                        object.Gender = message.Gender;
                    if (message.Age != null && message.hasOwnProperty("Age"))
                        object.Age = message.Age;
                    if (message.DateOfBirth != null && message.hasOwnProperty("DateOfBirth"))
                        object.DateOfBirth = message.DateOfBirth;
                    if (message.AccumulatedDosage != null && message.hasOwnProperty("AccumulatedDosage"))
                        object.AccumulatedDosage = message.AccumulatedDosage;
                    return object;
                };

                /**
                 * Converts this PatientInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.PatientInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PatientInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PatientInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.PatientInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PatientInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.PatientInfo";
                };

                return PatientInfo;
            })();

            ProtoBuf.ProcedureInfo = (function() {

                /**
                 * Properties of a ProcedureInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IProcedureInfo
                 * @property {string|null} [UID] ProcedureInfo UID
                 * @property {string|null} [ID] ProcedureInfo ID
                 * @property {string|null} [IsExamed] ProcedureInfo IsExamed
                 * @property {string|null} [PatientPosition] ProcedureInfo PatientPosition
                 * @property {UIBot.UHOR.ProtoBuf.IStudyInfo|null} [ParentStudy] ProcedureInfo ParentStudy
                 */

                /**
                 * Constructs a new ProcedureInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a ProcedureInfo.
                 * @implements IProcedureInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IProcedureInfo=} [properties] Properties to set
                 */
                function ProcedureInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ProcedureInfo UID.
                 * @member {string} UID
                 * @memberof UIBot.UHOR.ProtoBuf.ProcedureInfo
                 * @instance
                 */
                ProcedureInfo.prototype.UID = "";

                /**
                 * ProcedureInfo ID.
                 * @member {string} ID
                 * @memberof UIBot.UHOR.ProtoBuf.ProcedureInfo
                 * @instance
                 */
                ProcedureInfo.prototype.ID = "";

                /**
                 * ProcedureInfo IsExamed.
                 * @member {string} IsExamed
                 * @memberof UIBot.UHOR.ProtoBuf.ProcedureInfo
                 * @instance
                 */
                ProcedureInfo.prototype.IsExamed = "";

                /**
                 * ProcedureInfo PatientPosition.
                 * @member {string} PatientPosition
                 * @memberof UIBot.UHOR.ProtoBuf.ProcedureInfo
                 * @instance
                 */
                ProcedureInfo.prototype.PatientPosition = "";

                /**
                 * ProcedureInfo ParentStudy.
                 * @member {UIBot.UHOR.ProtoBuf.IStudyInfo|null|undefined} ParentStudy
                 * @memberof UIBot.UHOR.ProtoBuf.ProcedureInfo
                 * @instance
                 */
                ProcedureInfo.prototype.ParentStudy = null;

                /**
                 * Creates a new ProcedureInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.ProcedureInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IProcedureInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.ProcedureInfo} ProcedureInfo instance
                 */
                ProcedureInfo.create = function create(properties) {
                    return new ProcedureInfo(properties);
                };

                /**
                 * Encodes the specified ProcedureInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ProcedureInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.ProcedureInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IProcedureInfo} message ProcedureInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProcedureInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.UID != null && Object.hasOwnProperty.call(message, "UID"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.UID);
                    if (message.ID != null && Object.hasOwnProperty.call(message, "ID"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.ID);
                    if (message.IsExamed != null && Object.hasOwnProperty.call(message, "IsExamed"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.IsExamed);
                    if (message.PatientPosition != null && Object.hasOwnProperty.call(message, "PatientPosition"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.PatientPosition);
                    if (message.ParentStudy != null && Object.hasOwnProperty.call(message, "ParentStudy"))
                        $root.UIBot.UHOR.ProtoBuf.StudyInfo.encode(message.ParentStudy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ProcedureInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ProcedureInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ProcedureInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IProcedureInfo} message ProcedureInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProcedureInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ProcedureInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.ProcedureInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.ProcedureInfo} ProcedureInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProcedureInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.ProcedureInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.UID = reader.string();
                                break;
                            }
                        case 2: {
                                message.ID = reader.string();
                                break;
                            }
                        case 3: {
                                message.IsExamed = reader.string();
                                break;
                            }
                        case 4: {
                                message.PatientPosition = reader.string();
                                break;
                            }
                        case 5: {
                                message.ParentStudy = $root.UIBot.UHOR.ProtoBuf.StudyInfo.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ProcedureInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ProcedureInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.ProcedureInfo} ProcedureInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProcedureInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ProcedureInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.ProcedureInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProcedureInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.UID != null && message.hasOwnProperty("UID"))
                        if (!$util.isString(message.UID))
                            return "UID: string expected";
                    if (message.ID != null && message.hasOwnProperty("ID"))
                        if (!$util.isString(message.ID))
                            return "ID: string expected";
                    if (message.IsExamed != null && message.hasOwnProperty("IsExamed"))
                        if (!$util.isString(message.IsExamed))
                            return "IsExamed: string expected";
                    if (message.PatientPosition != null && message.hasOwnProperty("PatientPosition"))
                        if (!$util.isString(message.PatientPosition))
                            return "PatientPosition: string expected";
                    if (message.ParentStudy != null && message.hasOwnProperty("ParentStudy")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.StudyInfo.verify(message.ParentStudy);
                        if (error)
                            return "ParentStudy." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ProcedureInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.ProcedureInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.ProcedureInfo} ProcedureInfo
                 */
                ProcedureInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.ProcedureInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.ProcedureInfo();
                    if (object.UID != null)
                        message.UID = String(object.UID);
                    if (object.ID != null)
                        message.ID = String(object.ID);
                    if (object.IsExamed != null)
                        message.IsExamed = String(object.IsExamed);
                    if (object.PatientPosition != null)
                        message.PatientPosition = String(object.PatientPosition);
                    if (object.ParentStudy != null) {
                        if (typeof object.ParentStudy !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.ProcedureInfo.ParentStudy: object expected");
                        message.ParentStudy = $root.UIBot.UHOR.ProtoBuf.StudyInfo.fromObject(object.ParentStudy);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ProcedureInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.ProcedureInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ProcedureInfo} message ProcedureInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ProcedureInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.UID = "";
                        object.ID = "";
                        object.IsExamed = "";
                        object.PatientPosition = "";
                        object.ParentStudy = null;
                    }
                    if (message.UID != null && message.hasOwnProperty("UID"))
                        object.UID = message.UID;
                    if (message.ID != null && message.hasOwnProperty("ID"))
                        object.ID = message.ID;
                    if (message.IsExamed != null && message.hasOwnProperty("IsExamed"))
                        object.IsExamed = message.IsExamed;
                    if (message.PatientPosition != null && message.hasOwnProperty("PatientPosition"))
                        object.PatientPosition = message.PatientPosition;
                    if (message.ParentStudy != null && message.hasOwnProperty("ParentStudy"))
                        object.ParentStudy = $root.UIBot.UHOR.ProtoBuf.StudyInfo.toObject(message.ParentStudy, options);
                    return object;
                };

                /**
                 * Converts this ProcedureInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.ProcedureInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ProcedureInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ProcedureInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.ProcedureInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ProcedureInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.ProcedureInfo";
                };

                return ProcedureInfo;
            })();

            ProtoBuf.ImageInfo = (function() {

                /**
                 * Properties of an ImageInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IImageInfo
                 * @property {string|null} [UID] ImageInfo UID
                 * @property {string|null} [ID] ImageInfo ID
                 * @property {string|null} [FilePath] ImageInfo FilePath
                 * @property {UIBot.UHOR.ProtoBuf.ISeriesInfo|null} [ParentSeries] ImageInfo ParentSeries
                 */

                /**
                 * Constructs a new ImageInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents an ImageInfo.
                 * @implements IImageInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IImageInfo=} [properties] Properties to set
                 */
                function ImageInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ImageInfo UID.
                 * @member {string} UID
                 * @memberof UIBot.UHOR.ProtoBuf.ImageInfo
                 * @instance
                 */
                ImageInfo.prototype.UID = "";

                /**
                 * ImageInfo ID.
                 * @member {string} ID
                 * @memberof UIBot.UHOR.ProtoBuf.ImageInfo
                 * @instance
                 */
                ImageInfo.prototype.ID = "";

                /**
                 * ImageInfo FilePath.
                 * @member {string} FilePath
                 * @memberof UIBot.UHOR.ProtoBuf.ImageInfo
                 * @instance
                 */
                ImageInfo.prototype.FilePath = "";

                /**
                 * ImageInfo ParentSeries.
                 * @member {UIBot.UHOR.ProtoBuf.ISeriesInfo|null|undefined} ParentSeries
                 * @memberof UIBot.UHOR.ProtoBuf.ImageInfo
                 * @instance
                 */
                ImageInfo.prototype.ParentSeries = null;

                /**
                 * Creates a new ImageInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.ImageInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IImageInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.ImageInfo} ImageInfo instance
                 */
                ImageInfo.create = function create(properties) {
                    return new ImageInfo(properties);
                };

                /**
                 * Encodes the specified ImageInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ImageInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.ImageInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IImageInfo} message ImageInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ImageInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.UID != null && Object.hasOwnProperty.call(message, "UID"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.UID);
                    if (message.ID != null && Object.hasOwnProperty.call(message, "ID"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.ID);
                    if (message.FilePath != null && Object.hasOwnProperty.call(message, "FilePath"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.FilePath);
                    if (message.ParentSeries != null && Object.hasOwnProperty.call(message, "ParentSeries"))
                        $root.UIBot.UHOR.ProtoBuf.SeriesInfo.encode(message.ParentSeries, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ImageInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ImageInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ImageInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IImageInfo} message ImageInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ImageInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ImageInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.ImageInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.ImageInfo} ImageInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ImageInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.ImageInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.UID = reader.string();
                                break;
                            }
                        case 2: {
                                message.ID = reader.string();
                                break;
                            }
                        case 3: {
                                message.FilePath = reader.string();
                                break;
                            }
                        case 4: {
                                message.ParentSeries = $root.UIBot.UHOR.ProtoBuf.SeriesInfo.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ImageInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ImageInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.ImageInfo} ImageInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ImageInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ImageInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.ImageInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ImageInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.UID != null && message.hasOwnProperty("UID"))
                        if (!$util.isString(message.UID))
                            return "UID: string expected";
                    if (message.ID != null && message.hasOwnProperty("ID"))
                        if (!$util.isString(message.ID))
                            return "ID: string expected";
                    if (message.FilePath != null && message.hasOwnProperty("FilePath"))
                        if (!$util.isString(message.FilePath))
                            return "FilePath: string expected";
                    if (message.ParentSeries != null && message.hasOwnProperty("ParentSeries")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.SeriesInfo.verify(message.ParentSeries);
                        if (error)
                            return "ParentSeries." + error;
                    }
                    return null;
                };

                /**
                 * Creates an ImageInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.ImageInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.ImageInfo} ImageInfo
                 */
                ImageInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.ImageInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.ImageInfo();
                    if (object.UID != null)
                        message.UID = String(object.UID);
                    if (object.ID != null)
                        message.ID = String(object.ID);
                    if (object.FilePath != null)
                        message.FilePath = String(object.FilePath);
                    if (object.ParentSeries != null) {
                        if (typeof object.ParentSeries !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.ImageInfo.ParentSeries: object expected");
                        message.ParentSeries = $root.UIBot.UHOR.ProtoBuf.SeriesInfo.fromObject(object.ParentSeries);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ImageInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.ImageInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ImageInfo} message ImageInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ImageInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.UID = "";
                        object.ID = "";
                        object.FilePath = "";
                        object.ParentSeries = null;
                    }
                    if (message.UID != null && message.hasOwnProperty("UID"))
                        object.UID = message.UID;
                    if (message.ID != null && message.hasOwnProperty("ID"))
                        object.ID = message.ID;
                    if (message.FilePath != null && message.hasOwnProperty("FilePath"))
                        object.FilePath = message.FilePath;
                    if (message.ParentSeries != null && message.hasOwnProperty("ParentSeries"))
                        object.ParentSeries = $root.UIBot.UHOR.ProtoBuf.SeriesInfo.toObject(message.ParentSeries, options);
                    return object;
                };

                /**
                 * Converts this ImageInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.ImageInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ImageInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ImageInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.ImageInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ImageInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.ImageInfo";
                };

                return ImageInfo;
            })();

            ProtoBuf.SeriesInfo = (function() {

                /**
                 * Properties of a SeriesInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface ISeriesInfo
                 * @property {string|null} [UID] SeriesInfo UID
                 * @property {string|null} [ID] SeriesInfo ID
                 * @property {UIBot.UHOR.ProtoBuf.IStudyInfo|null} [ParentStudy] SeriesInfo ParentStudy
                 */

                /**
                 * Constructs a new SeriesInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a SeriesInfo.
                 * @implements ISeriesInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.ISeriesInfo=} [properties] Properties to set
                 */
                function SeriesInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SeriesInfo UID.
                 * @member {string} UID
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesInfo
                 * @instance
                 */
                SeriesInfo.prototype.UID = "";

                /**
                 * SeriesInfo ID.
                 * @member {string} ID
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesInfo
                 * @instance
                 */
                SeriesInfo.prototype.ID = "";

                /**
                 * SeriesInfo ParentStudy.
                 * @member {UIBot.UHOR.ProtoBuf.IStudyInfo|null|undefined} ParentStudy
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesInfo
                 * @instance
                 */
                SeriesInfo.prototype.ParentStudy = null;

                /**
                 * Creates a new SeriesInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ISeriesInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.SeriesInfo} SeriesInfo instance
                 */
                SeriesInfo.create = function create(properties) {
                    return new SeriesInfo(properties);
                };

                /**
                 * Encodes the specified SeriesInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.SeriesInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ISeriesInfo} message SeriesInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SeriesInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.UID != null && Object.hasOwnProperty.call(message, "UID"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.UID);
                    if (message.ID != null && Object.hasOwnProperty.call(message, "ID"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.ID);
                    if (message.ParentStudy != null && Object.hasOwnProperty.call(message, "ParentStudy"))
                        $root.UIBot.UHOR.ProtoBuf.StudyInfo.encode(message.ParentStudy, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SeriesInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.SeriesInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ISeriesInfo} message SeriesInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SeriesInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SeriesInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.SeriesInfo} SeriesInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SeriesInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.SeriesInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.UID = reader.string();
                                break;
                            }
                        case 2: {
                                message.ID = reader.string();
                                break;
                            }
                        case 3: {
                                message.ParentStudy = $root.UIBot.UHOR.ProtoBuf.StudyInfo.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SeriesInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.SeriesInfo} SeriesInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SeriesInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SeriesInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SeriesInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.UID != null && message.hasOwnProperty("UID"))
                        if (!$util.isString(message.UID))
                            return "UID: string expected";
                    if (message.ID != null && message.hasOwnProperty("ID"))
                        if (!$util.isString(message.ID))
                            return "ID: string expected";
                    if (message.ParentStudy != null && message.hasOwnProperty("ParentStudy")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.StudyInfo.verify(message.ParentStudy);
                        if (error)
                            return "ParentStudy." + error;
                    }
                    return null;
                };

                /**
                 * Creates a SeriesInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.SeriesInfo} SeriesInfo
                 */
                SeriesInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.SeriesInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.SeriesInfo();
                    if (object.UID != null)
                        message.UID = String(object.UID);
                    if (object.ID != null)
                        message.ID = String(object.ID);
                    if (object.ParentStudy != null) {
                        if (typeof object.ParentStudy !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.SeriesInfo.ParentStudy: object expected");
                        message.ParentStudy = $root.UIBot.UHOR.ProtoBuf.StudyInfo.fromObject(object.ParentStudy);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SeriesInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.SeriesInfo} message SeriesInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SeriesInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.UID = "";
                        object.ID = "";
                        object.ParentStudy = null;
                    }
                    if (message.UID != null && message.hasOwnProperty("UID"))
                        object.UID = message.UID;
                    if (message.ID != null && message.hasOwnProperty("ID"))
                        object.ID = message.ID;
                    if (message.ParentStudy != null && message.hasOwnProperty("ParentStudy"))
                        object.ParentStudy = $root.UIBot.UHOR.ProtoBuf.StudyInfo.toObject(message.ParentStudy, options);
                    return object;
                };

                /**
                 * Converts this SeriesInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SeriesInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SeriesInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SeriesInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.SeriesInfo";
                };

                return SeriesInfo;
            })();

            ProtoBuf.StudyInfo = (function() {

                /**
                 * Properties of a StudyInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IStudyInfo
                 * @property {string|null} [UID] StudyInfo UID
                 * @property {string|null} [ID] StudyInfo ID
                 * @property {string|null} [ExamStatus] StudyInfo ExamStatus
                 * @property {Array.<string>|null} [ExamPart] StudyInfo ExamPart
                 * @property {boolean|null} [HasSeries] StudyInfo HasSeries
                 * @property {boolean|null} [HasImage] StudyInfo HasImage
                 * @property {string|null} [ModalityType] StudyInfo ModalityType
                 * @property {UIBot.UHOR.ProtoBuf.IPatientInfo|null} [ParentPatient] StudyInfo ParentPatient
                 */

                /**
                 * Constructs a new StudyInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a StudyInfo.
                 * @implements IStudyInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IStudyInfo=} [properties] Properties to set
                 */
                function StudyInfo(properties) {
                    this.ExamPart = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StudyInfo UID.
                 * @member {string} UID
                 * @memberof UIBot.UHOR.ProtoBuf.StudyInfo
                 * @instance
                 */
                StudyInfo.prototype.UID = "";

                /**
                 * StudyInfo ID.
                 * @member {string} ID
                 * @memberof UIBot.UHOR.ProtoBuf.StudyInfo
                 * @instance
                 */
                StudyInfo.prototype.ID = "";

                /**
                 * StudyInfo ExamStatus.
                 * @member {string} ExamStatus
                 * @memberof UIBot.UHOR.ProtoBuf.StudyInfo
                 * @instance
                 */
                StudyInfo.prototype.ExamStatus = "";

                /**
                 * StudyInfo ExamPart.
                 * @member {Array.<string>} ExamPart
                 * @memberof UIBot.UHOR.ProtoBuf.StudyInfo
                 * @instance
                 */
                StudyInfo.prototype.ExamPart = $util.emptyArray;

                /**
                 * StudyInfo HasSeries.
                 * @member {boolean} HasSeries
                 * @memberof UIBot.UHOR.ProtoBuf.StudyInfo
                 * @instance
                 */
                StudyInfo.prototype.HasSeries = false;

                /**
                 * StudyInfo HasImage.
                 * @member {boolean} HasImage
                 * @memberof UIBot.UHOR.ProtoBuf.StudyInfo
                 * @instance
                 */
                StudyInfo.prototype.HasImage = false;

                /**
                 * StudyInfo ModalityType.
                 * @member {string} ModalityType
                 * @memberof UIBot.UHOR.ProtoBuf.StudyInfo
                 * @instance
                 */
                StudyInfo.prototype.ModalityType = "";

                /**
                 * StudyInfo ParentPatient.
                 * @member {UIBot.UHOR.ProtoBuf.IPatientInfo|null|undefined} ParentPatient
                 * @memberof UIBot.UHOR.ProtoBuf.StudyInfo
                 * @instance
                 */
                StudyInfo.prototype.ParentPatient = null;

                /**
                 * Creates a new StudyInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.StudyInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IStudyInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.StudyInfo} StudyInfo instance
                 */
                StudyInfo.create = function create(properties) {
                    return new StudyInfo(properties);
                };

                /**
                 * Encodes the specified StudyInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.StudyInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.StudyInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IStudyInfo} message StudyInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StudyInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.UID != null && Object.hasOwnProperty.call(message, "UID"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.UID);
                    if (message.ID != null && Object.hasOwnProperty.call(message, "ID"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.ID);
                    if (message.ExamStatus != null && Object.hasOwnProperty.call(message, "ExamStatus"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.ExamStatus);
                    if (message.ExamPart != null && message.ExamPart.length)
                        for (var i = 0; i < message.ExamPart.length; ++i)
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.ExamPart[i]);
                    if (message.HasSeries != null && Object.hasOwnProperty.call(message, "HasSeries"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.HasSeries);
                    if (message.HasImage != null && Object.hasOwnProperty.call(message, "HasImage"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.HasImage);
                    if (message.ModalityType != null && Object.hasOwnProperty.call(message, "ModalityType"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.ModalityType);
                    if (message.ParentPatient != null && Object.hasOwnProperty.call(message, "ParentPatient"))
                        $root.UIBot.UHOR.ProtoBuf.PatientInfo.encode(message.ParentPatient, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified StudyInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.StudyInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.StudyInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IStudyInfo} message StudyInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StudyInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a StudyInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.StudyInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.StudyInfo} StudyInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StudyInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.StudyInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.UID = reader.string();
                                break;
                            }
                        case 2: {
                                message.ID = reader.string();
                                break;
                            }
                        case 3: {
                                message.ExamStatus = reader.string();
                                break;
                            }
                        case 4: {
                                if (!(message.ExamPart && message.ExamPart.length))
                                    message.ExamPart = [];
                                message.ExamPart.push(reader.string());
                                break;
                            }
                        case 5: {
                                message.HasSeries = reader.bool();
                                break;
                            }
                        case 6: {
                                message.HasImage = reader.bool();
                                break;
                            }
                        case 7: {
                                message.ModalityType = reader.string();
                                break;
                            }
                        case 8: {
                                message.ParentPatient = $root.UIBot.UHOR.ProtoBuf.PatientInfo.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a StudyInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.StudyInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.StudyInfo} StudyInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StudyInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a StudyInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.StudyInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StudyInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.UID != null && message.hasOwnProperty("UID"))
                        if (!$util.isString(message.UID))
                            return "UID: string expected";
                    if (message.ID != null && message.hasOwnProperty("ID"))
                        if (!$util.isString(message.ID))
                            return "ID: string expected";
                    if (message.ExamStatus != null && message.hasOwnProperty("ExamStatus"))
                        if (!$util.isString(message.ExamStatus))
                            return "ExamStatus: string expected";
                    if (message.ExamPart != null && message.hasOwnProperty("ExamPart")) {
                        if (!Array.isArray(message.ExamPart))
                            return "ExamPart: array expected";
                        for (var i = 0; i < message.ExamPart.length; ++i)
                            if (!$util.isString(message.ExamPart[i]))
                                return "ExamPart: string[] expected";
                    }
                    if (message.HasSeries != null && message.hasOwnProperty("HasSeries"))
                        if (typeof message.HasSeries !== "boolean")
                            return "HasSeries: boolean expected";
                    if (message.HasImage != null && message.hasOwnProperty("HasImage"))
                        if (typeof message.HasImage !== "boolean")
                            return "HasImage: boolean expected";
                    if (message.ModalityType != null && message.hasOwnProperty("ModalityType"))
                        if (!$util.isString(message.ModalityType))
                            return "ModalityType: string expected";
                    if (message.ParentPatient != null && message.hasOwnProperty("ParentPatient")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.PatientInfo.verify(message.ParentPatient);
                        if (error)
                            return "ParentPatient." + error;
                    }
                    return null;
                };

                /**
                 * Creates a StudyInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.StudyInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.StudyInfo} StudyInfo
                 */
                StudyInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.StudyInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.StudyInfo();
                    if (object.UID != null)
                        message.UID = String(object.UID);
                    if (object.ID != null)
                        message.ID = String(object.ID);
                    if (object.ExamStatus != null)
                        message.ExamStatus = String(object.ExamStatus);
                    if (object.ExamPart) {
                        if (!Array.isArray(object.ExamPart))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.StudyInfo.ExamPart: array expected");
                        message.ExamPart = [];
                        for (var i = 0; i < object.ExamPart.length; ++i)
                            message.ExamPart[i] = String(object.ExamPart[i]);
                    }
                    if (object.HasSeries != null)
                        message.HasSeries = Boolean(object.HasSeries);
                    if (object.HasImage != null)
                        message.HasImage = Boolean(object.HasImage);
                    if (object.ModalityType != null)
                        message.ModalityType = String(object.ModalityType);
                    if (object.ParentPatient != null) {
                        if (typeof object.ParentPatient !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.StudyInfo.ParentPatient: object expected");
                        message.ParentPatient = $root.UIBot.UHOR.ProtoBuf.PatientInfo.fromObject(object.ParentPatient);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a StudyInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.StudyInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.StudyInfo} message StudyInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StudyInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.ExamPart = [];
                    if (options.defaults) {
                        object.UID = "";
                        object.ID = "";
                        object.ExamStatus = "";
                        object.HasSeries = false;
                        object.HasImage = false;
                        object.ModalityType = "";
                        object.ParentPatient = null;
                    }
                    if (message.UID != null && message.hasOwnProperty("UID"))
                        object.UID = message.UID;
                    if (message.ID != null && message.hasOwnProperty("ID"))
                        object.ID = message.ID;
                    if (message.ExamStatus != null && message.hasOwnProperty("ExamStatus"))
                        object.ExamStatus = message.ExamStatus;
                    if (message.ExamPart && message.ExamPart.length) {
                        object.ExamPart = [];
                        for (var j = 0; j < message.ExamPart.length; ++j)
                            object.ExamPart[j] = message.ExamPart[j];
                    }
                    if (message.HasSeries != null && message.hasOwnProperty("HasSeries"))
                        object.HasSeries = message.HasSeries;
                    if (message.HasImage != null && message.hasOwnProperty("HasImage"))
                        object.HasImage = message.HasImage;
                    if (message.ModalityType != null && message.hasOwnProperty("ModalityType"))
                        object.ModalityType = message.ModalityType;
                    if (message.ParentPatient != null && message.hasOwnProperty("ParentPatient"))
                        object.ParentPatient = $root.UIBot.UHOR.ProtoBuf.PatientInfo.toObject(message.ParentPatient, options);
                    return object;
                };

                /**
                 * Converts this StudyInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.StudyInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StudyInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for StudyInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.StudyInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                StudyInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.StudyInfo";
                };

                return StudyInfo;
            })();

            ProtoBuf.RawDataInfo = (function() {

                /**
                 * Properties of a RawDataInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IRawDataInfo
                 * @property {string|null} [RawInstanceUID] RawDataInfo RawInstanceUID
                 */

                /**
                 * Constructs a new RawDataInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a RawDataInfo.
                 * @implements IRawDataInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IRawDataInfo=} [properties] Properties to set
                 */
                function RawDataInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RawDataInfo RawInstanceUID.
                 * @member {string} RawInstanceUID
                 * @memberof UIBot.UHOR.ProtoBuf.RawDataInfo
                 * @instance
                 */
                RawDataInfo.prototype.RawInstanceUID = "";

                /**
                 * Creates a new RawDataInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.RawDataInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IRawDataInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.RawDataInfo} RawDataInfo instance
                 */
                RawDataInfo.create = function create(properties) {
                    return new RawDataInfo(properties);
                };

                /**
                 * Encodes the specified RawDataInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.RawDataInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.RawDataInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IRawDataInfo} message RawDataInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RawDataInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.RawInstanceUID != null && Object.hasOwnProperty.call(message, "RawInstanceUID"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.RawInstanceUID);
                    return writer;
                };

                /**
                 * Encodes the specified RawDataInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.RawDataInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.RawDataInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IRawDataInfo} message RawDataInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RawDataInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RawDataInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.RawDataInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.RawDataInfo} RawDataInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RawDataInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.RawDataInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.RawInstanceUID = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RawDataInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.RawDataInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.RawDataInfo} RawDataInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RawDataInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RawDataInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.RawDataInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RawDataInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.RawInstanceUID != null && message.hasOwnProperty("RawInstanceUID"))
                        if (!$util.isString(message.RawInstanceUID))
                            return "RawInstanceUID: string expected";
                    return null;
                };

                /**
                 * Creates a RawDataInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.RawDataInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.RawDataInfo} RawDataInfo
                 */
                RawDataInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.RawDataInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.RawDataInfo();
                    if (object.RawInstanceUID != null)
                        message.RawInstanceUID = String(object.RawInstanceUID);
                    return message;
                };

                /**
                 * Creates a plain object from a RawDataInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.RawDataInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.RawDataInfo} message RawDataInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RawDataInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.RawInstanceUID = "";
                    if (message.RawInstanceUID != null && message.hasOwnProperty("RawInstanceUID"))
                        object.RawInstanceUID = message.RawInstanceUID;
                    return object;
                };

                /**
                 * Converts this RawDataInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.RawDataInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RawDataInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for RawDataInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.RawDataInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                RawDataInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.RawDataInfo";
                };

                return RawDataInfo;
            })();

            ProtoBuf.InteractionInfo = (function() {

                /**
                 * Properties of an InteractionInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IInteractionInfo
                 * @property {string|null} [SrcAppName] InteractionInfo SrcAppName
                 * @property {string|null} [DestAppName] InteractionInfo DestAppName
                 * @property {number|null} [OperationID] InteractionInfo OperationID
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IStudyInfo>|null} [Studies] InteractionInfo Studies
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IPatientInfo>|null} [Patients] InteractionInfo Patients
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IProcedureInfo>|null} [Procedures] InteractionInfo Procedures
                 * @property {Array.<UIBot.UHOR.ProtoBuf.ISeriesInfo>|null} [Series] InteractionInfo Series
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IImageInfo>|null} [Images] InteractionInfo Images
                 * @property {string|null} [CustomizedInfo] InteractionInfo CustomizedInfo
                 * @property {UIBot.UHOR.ProtoBuf.IRawDataInfo|null} [RawData] InteractionInfo RawData
                 * @property {string|null} [NlsAppName] InteractionInfo NlsAppName
                 * @property {string|null} [ProcedureBuffer] InteractionInfo ProcedureBuffer
                 * @property {boolean|null} [PreAttachFlag] InteractionInfo PreAttachFlag
                 * @property {UIBot.UHOR.ProtoBuf.LoadLevel|null} [Level] InteractionInfo Level
                 * @property {boolean|null} [TargetIsStudyList] InteractionInfo TargetIsStudyList
                 * @property {boolean|null} [AllowAppend] InteractionInfo AllowAppend
                 */

                /**
                 * Constructs a new InteractionInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents an InteractionInfo.
                 * @implements IInteractionInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IInteractionInfo=} [properties] Properties to set
                 */
                function InteractionInfo(properties) {
                    this.Studies = [];
                    this.Patients = [];
                    this.Procedures = [];
                    this.Series = [];
                    this.Images = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * InteractionInfo SrcAppName.
                 * @member {string} SrcAppName
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @instance
                 */
                InteractionInfo.prototype.SrcAppName = "";

                /**
                 * InteractionInfo DestAppName.
                 * @member {string} DestAppName
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @instance
                 */
                InteractionInfo.prototype.DestAppName = "";

                /**
                 * InteractionInfo OperationID.
                 * @member {number} OperationID
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @instance
                 */
                InteractionInfo.prototype.OperationID = 0;

                /**
                 * InteractionInfo Studies.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IStudyInfo>} Studies
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @instance
                 */
                InteractionInfo.prototype.Studies = $util.emptyArray;

                /**
                 * InteractionInfo Patients.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IPatientInfo>} Patients
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @instance
                 */
                InteractionInfo.prototype.Patients = $util.emptyArray;

                /**
                 * InteractionInfo Procedures.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IProcedureInfo>} Procedures
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @instance
                 */
                InteractionInfo.prototype.Procedures = $util.emptyArray;

                /**
                 * InteractionInfo Series.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.ISeriesInfo>} Series
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @instance
                 */
                InteractionInfo.prototype.Series = $util.emptyArray;

                /**
                 * InteractionInfo Images.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IImageInfo>} Images
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @instance
                 */
                InteractionInfo.prototype.Images = $util.emptyArray;

                /**
                 * InteractionInfo CustomizedInfo.
                 * @member {string} CustomizedInfo
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @instance
                 */
                InteractionInfo.prototype.CustomizedInfo = "";

                /**
                 * InteractionInfo RawData.
                 * @member {UIBot.UHOR.ProtoBuf.IRawDataInfo|null|undefined} RawData
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @instance
                 */
                InteractionInfo.prototype.RawData = null;

                /**
                 * InteractionInfo NlsAppName.
                 * @member {string} NlsAppName
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @instance
                 */
                InteractionInfo.prototype.NlsAppName = "";

                /**
                 * InteractionInfo ProcedureBuffer.
                 * @member {string} ProcedureBuffer
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @instance
                 */
                InteractionInfo.prototype.ProcedureBuffer = "";

                /**
                 * InteractionInfo PreAttachFlag.
                 * @member {boolean} PreAttachFlag
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @instance
                 */
                InteractionInfo.prototype.PreAttachFlag = false;

                /**
                 * InteractionInfo Level.
                 * @member {UIBot.UHOR.ProtoBuf.LoadLevel} Level
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @instance
                 */
                InteractionInfo.prototype.Level = 0;

                /**
                 * InteractionInfo TargetIsStudyList.
                 * @member {boolean} TargetIsStudyList
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @instance
                 */
                InteractionInfo.prototype.TargetIsStudyList = false;

                /**
                 * InteractionInfo AllowAppend.
                 * @member {boolean} AllowAppend
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @instance
                 */
                InteractionInfo.prototype.AllowAppend = false;

                /**
                 * Creates a new InteractionInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IInteractionInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.InteractionInfo} InteractionInfo instance
                 */
                InteractionInfo.create = function create(properties) {
                    return new InteractionInfo(properties);
                };

                /**
                 * Encodes the specified InteractionInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.InteractionInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IInteractionInfo} message InteractionInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InteractionInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.SrcAppName != null && Object.hasOwnProperty.call(message, "SrcAppName"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.SrcAppName);
                    if (message.DestAppName != null && Object.hasOwnProperty.call(message, "DestAppName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.DestAppName);
                    if (message.OperationID != null && Object.hasOwnProperty.call(message, "OperationID"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.OperationID);
                    if (message.Studies != null && message.Studies.length)
                        for (var i = 0; i < message.Studies.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.StudyInfo.encode(message.Studies[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.Patients != null && message.Patients.length)
                        for (var i = 0; i < message.Patients.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.PatientInfo.encode(message.Patients[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.Procedures != null && message.Procedures.length)
                        for (var i = 0; i < message.Procedures.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.ProcedureInfo.encode(message.Procedures[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.Series != null && message.Series.length)
                        for (var i = 0; i < message.Series.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.SeriesInfo.encode(message.Series[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.Images != null && message.Images.length)
                        for (var i = 0; i < message.Images.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.ImageInfo.encode(message.Images[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.CustomizedInfo != null && Object.hasOwnProperty.call(message, "CustomizedInfo"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.CustomizedInfo);
                    if (message.RawData != null && Object.hasOwnProperty.call(message, "RawData"))
                        $root.UIBot.UHOR.ProtoBuf.RawDataInfo.encode(message.RawData, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.NlsAppName != null && Object.hasOwnProperty.call(message, "NlsAppName"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.NlsAppName);
                    if (message.ProcedureBuffer != null && Object.hasOwnProperty.call(message, "ProcedureBuffer"))
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.ProcedureBuffer);
                    if (message.PreAttachFlag != null && Object.hasOwnProperty.call(message, "PreAttachFlag"))
                        writer.uint32(/* id 13, wireType 0 =*/104).bool(message.PreAttachFlag);
                    if (message.Level != null && Object.hasOwnProperty.call(message, "Level"))
                        writer.uint32(/* id 14, wireType 0 =*/112).int32(message.Level);
                    if (message.TargetIsStudyList != null && Object.hasOwnProperty.call(message, "TargetIsStudyList"))
                        writer.uint32(/* id 15, wireType 0 =*/120).bool(message.TargetIsStudyList);
                    if (message.AllowAppend != null && Object.hasOwnProperty.call(message, "AllowAppend"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.AllowAppend);
                    return writer;
                };

                /**
                 * Encodes the specified InteractionInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.InteractionInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IInteractionInfo} message InteractionInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InteractionInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an InteractionInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.InteractionInfo} InteractionInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InteractionInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.InteractionInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.SrcAppName = reader.string();
                                break;
                            }
                        case 2: {
                                message.DestAppName = reader.string();
                                break;
                            }
                        case 3: {
                                message.OperationID = reader.int32();
                                break;
                            }
                        case 4: {
                                if (!(message.Studies && message.Studies.length))
                                    message.Studies = [];
                                message.Studies.push($root.UIBot.UHOR.ProtoBuf.StudyInfo.decode(reader, reader.uint32()));
                                break;
                            }
                        case 5: {
                                if (!(message.Patients && message.Patients.length))
                                    message.Patients = [];
                                message.Patients.push($root.UIBot.UHOR.ProtoBuf.PatientInfo.decode(reader, reader.uint32()));
                                break;
                            }
                        case 6: {
                                if (!(message.Procedures && message.Procedures.length))
                                    message.Procedures = [];
                                message.Procedures.push($root.UIBot.UHOR.ProtoBuf.ProcedureInfo.decode(reader, reader.uint32()));
                                break;
                            }
                        case 7: {
                                if (!(message.Series && message.Series.length))
                                    message.Series = [];
                                message.Series.push($root.UIBot.UHOR.ProtoBuf.SeriesInfo.decode(reader, reader.uint32()));
                                break;
                            }
                        case 8: {
                                if (!(message.Images && message.Images.length))
                                    message.Images = [];
                                message.Images.push($root.UIBot.UHOR.ProtoBuf.ImageInfo.decode(reader, reader.uint32()));
                                break;
                            }
                        case 9: {
                                message.CustomizedInfo = reader.string();
                                break;
                            }
                        case 10: {
                                message.RawData = $root.UIBot.UHOR.ProtoBuf.RawDataInfo.decode(reader, reader.uint32());
                                break;
                            }
                        case 11: {
                                message.NlsAppName = reader.string();
                                break;
                            }
                        case 12: {
                                message.ProcedureBuffer = reader.string();
                                break;
                            }
                        case 13: {
                                message.PreAttachFlag = reader.bool();
                                break;
                            }
                        case 14: {
                                message.Level = reader.int32();
                                break;
                            }
                        case 15: {
                                message.TargetIsStudyList = reader.bool();
                                break;
                            }
                        case 16: {
                                message.AllowAppend = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an InteractionInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.InteractionInfo} InteractionInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InteractionInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an InteractionInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InteractionInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.SrcAppName != null && message.hasOwnProperty("SrcAppName"))
                        if (!$util.isString(message.SrcAppName))
                            return "SrcAppName: string expected";
                    if (message.DestAppName != null && message.hasOwnProperty("DestAppName"))
                        if (!$util.isString(message.DestAppName))
                            return "DestAppName: string expected";
                    if (message.OperationID != null && message.hasOwnProperty("OperationID"))
                        if (!$util.isInteger(message.OperationID))
                            return "OperationID: integer expected";
                    if (message.Studies != null && message.hasOwnProperty("Studies")) {
                        if (!Array.isArray(message.Studies))
                            return "Studies: array expected";
                        for (var i = 0; i < message.Studies.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.StudyInfo.verify(message.Studies[i]);
                            if (error)
                                return "Studies." + error;
                        }
                    }
                    if (message.Patients != null && message.hasOwnProperty("Patients")) {
                        if (!Array.isArray(message.Patients))
                            return "Patients: array expected";
                        for (var i = 0; i < message.Patients.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.PatientInfo.verify(message.Patients[i]);
                            if (error)
                                return "Patients." + error;
                        }
                    }
                    if (message.Procedures != null && message.hasOwnProperty("Procedures")) {
                        if (!Array.isArray(message.Procedures))
                            return "Procedures: array expected";
                        for (var i = 0; i < message.Procedures.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.ProcedureInfo.verify(message.Procedures[i]);
                            if (error)
                                return "Procedures." + error;
                        }
                    }
                    if (message.Series != null && message.hasOwnProperty("Series")) {
                        if (!Array.isArray(message.Series))
                            return "Series: array expected";
                        for (var i = 0; i < message.Series.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.SeriesInfo.verify(message.Series[i]);
                            if (error)
                                return "Series." + error;
                        }
                    }
                    if (message.Images != null && message.hasOwnProperty("Images")) {
                        if (!Array.isArray(message.Images))
                            return "Images: array expected";
                        for (var i = 0; i < message.Images.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.ImageInfo.verify(message.Images[i]);
                            if (error)
                                return "Images." + error;
                        }
                    }
                    if (message.CustomizedInfo != null && message.hasOwnProperty("CustomizedInfo"))
                        if (!$util.isString(message.CustomizedInfo))
                            return "CustomizedInfo: string expected";
                    if (message.RawData != null && message.hasOwnProperty("RawData")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.RawDataInfo.verify(message.RawData);
                        if (error)
                            return "RawData." + error;
                    }
                    if (message.NlsAppName != null && message.hasOwnProperty("NlsAppName"))
                        if (!$util.isString(message.NlsAppName))
                            return "NlsAppName: string expected";
                    if (message.ProcedureBuffer != null && message.hasOwnProperty("ProcedureBuffer"))
                        if (!$util.isString(message.ProcedureBuffer))
                            return "ProcedureBuffer: string expected";
                    if (message.PreAttachFlag != null && message.hasOwnProperty("PreAttachFlag"))
                        if (typeof message.PreAttachFlag !== "boolean")
                            return "PreAttachFlag: boolean expected";
                    if (message.Level != null && message.hasOwnProperty("Level"))
                        switch (message.Level) {
                        default:
                            return "Level: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.TargetIsStudyList != null && message.hasOwnProperty("TargetIsStudyList"))
                        if (typeof message.TargetIsStudyList !== "boolean")
                            return "TargetIsStudyList: boolean expected";
                    if (message.AllowAppend != null && message.hasOwnProperty("AllowAppend"))
                        if (typeof message.AllowAppend !== "boolean")
                            return "AllowAppend: boolean expected";
                    return null;
                };

                /**
                 * Creates an InteractionInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.InteractionInfo} InteractionInfo
                 */
                InteractionInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.InteractionInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.InteractionInfo();
                    if (object.SrcAppName != null)
                        message.SrcAppName = String(object.SrcAppName);
                    if (object.DestAppName != null)
                        message.DestAppName = String(object.DestAppName);
                    if (object.OperationID != null)
                        message.OperationID = object.OperationID | 0;
                    if (object.Studies) {
                        if (!Array.isArray(object.Studies))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.InteractionInfo.Studies: array expected");
                        message.Studies = [];
                        for (var i = 0; i < object.Studies.length; ++i) {
                            if (typeof object.Studies[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.InteractionInfo.Studies: object expected");
                            message.Studies[i] = $root.UIBot.UHOR.ProtoBuf.StudyInfo.fromObject(object.Studies[i]);
                        }
                    }
                    if (object.Patients) {
                        if (!Array.isArray(object.Patients))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.InteractionInfo.Patients: array expected");
                        message.Patients = [];
                        for (var i = 0; i < object.Patients.length; ++i) {
                            if (typeof object.Patients[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.InteractionInfo.Patients: object expected");
                            message.Patients[i] = $root.UIBot.UHOR.ProtoBuf.PatientInfo.fromObject(object.Patients[i]);
                        }
                    }
                    if (object.Procedures) {
                        if (!Array.isArray(object.Procedures))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.InteractionInfo.Procedures: array expected");
                        message.Procedures = [];
                        for (var i = 0; i < object.Procedures.length; ++i) {
                            if (typeof object.Procedures[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.InteractionInfo.Procedures: object expected");
                            message.Procedures[i] = $root.UIBot.UHOR.ProtoBuf.ProcedureInfo.fromObject(object.Procedures[i]);
                        }
                    }
                    if (object.Series) {
                        if (!Array.isArray(object.Series))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.InteractionInfo.Series: array expected");
                        message.Series = [];
                        for (var i = 0; i < object.Series.length; ++i) {
                            if (typeof object.Series[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.InteractionInfo.Series: object expected");
                            message.Series[i] = $root.UIBot.UHOR.ProtoBuf.SeriesInfo.fromObject(object.Series[i]);
                        }
                    }
                    if (object.Images) {
                        if (!Array.isArray(object.Images))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.InteractionInfo.Images: array expected");
                        message.Images = [];
                        for (var i = 0; i < object.Images.length; ++i) {
                            if (typeof object.Images[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.InteractionInfo.Images: object expected");
                            message.Images[i] = $root.UIBot.UHOR.ProtoBuf.ImageInfo.fromObject(object.Images[i]);
                        }
                    }
                    if (object.CustomizedInfo != null)
                        message.CustomizedInfo = String(object.CustomizedInfo);
                    if (object.RawData != null) {
                        if (typeof object.RawData !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.InteractionInfo.RawData: object expected");
                        message.RawData = $root.UIBot.UHOR.ProtoBuf.RawDataInfo.fromObject(object.RawData);
                    }
                    if (object.NlsAppName != null)
                        message.NlsAppName = String(object.NlsAppName);
                    if (object.ProcedureBuffer != null)
                        message.ProcedureBuffer = String(object.ProcedureBuffer);
                    if (object.PreAttachFlag != null)
                        message.PreAttachFlag = Boolean(object.PreAttachFlag);
                    switch (object.Level) {
                    default:
                        if (typeof object.Level === "number") {
                            message.Level = object.Level;
                            break;
                        }
                        break;
                    case "Patient":
                    case 0:
                        message.Level = 0;
                        break;
                    case "Study":
                    case 1:
                        message.Level = 1;
                        break;
                    case "Series":
                    case 2:
                        message.Level = 2;
                        break;
                    case "Image":
                    case 3:
                        message.Level = 3;
                        break;
                    }
                    if (object.TargetIsStudyList != null)
                        message.TargetIsStudyList = Boolean(object.TargetIsStudyList);
                    if (object.AllowAppend != null)
                        message.AllowAppend = Boolean(object.AllowAppend);
                    return message;
                };

                /**
                 * Creates a plain object from an InteractionInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.InteractionInfo} message InteractionInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InteractionInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.Studies = [];
                        object.Patients = [];
                        object.Procedures = [];
                        object.Series = [];
                        object.Images = [];
                    }
                    if (options.defaults) {
                        object.SrcAppName = "";
                        object.DestAppName = "";
                        object.OperationID = 0;
                        object.CustomizedInfo = "";
                        object.RawData = null;
                        object.NlsAppName = "";
                        object.ProcedureBuffer = "";
                        object.PreAttachFlag = false;
                        object.Level = options.enums === String ? "Patient" : 0;
                        object.TargetIsStudyList = false;
                        object.AllowAppend = false;
                    }
                    if (message.SrcAppName != null && message.hasOwnProperty("SrcAppName"))
                        object.SrcAppName = message.SrcAppName;
                    if (message.DestAppName != null && message.hasOwnProperty("DestAppName"))
                        object.DestAppName = message.DestAppName;
                    if (message.OperationID != null && message.hasOwnProperty("OperationID"))
                        object.OperationID = message.OperationID;
                    if (message.Studies && message.Studies.length) {
                        object.Studies = [];
                        for (var j = 0; j < message.Studies.length; ++j)
                            object.Studies[j] = $root.UIBot.UHOR.ProtoBuf.StudyInfo.toObject(message.Studies[j], options);
                    }
                    if (message.Patients && message.Patients.length) {
                        object.Patients = [];
                        for (var j = 0; j < message.Patients.length; ++j)
                            object.Patients[j] = $root.UIBot.UHOR.ProtoBuf.PatientInfo.toObject(message.Patients[j], options);
                    }
                    if (message.Procedures && message.Procedures.length) {
                        object.Procedures = [];
                        for (var j = 0; j < message.Procedures.length; ++j)
                            object.Procedures[j] = $root.UIBot.UHOR.ProtoBuf.ProcedureInfo.toObject(message.Procedures[j], options);
                    }
                    if (message.Series && message.Series.length) {
                        object.Series = [];
                        for (var j = 0; j < message.Series.length; ++j)
                            object.Series[j] = $root.UIBot.UHOR.ProtoBuf.SeriesInfo.toObject(message.Series[j], options);
                    }
                    if (message.Images && message.Images.length) {
                        object.Images = [];
                        for (var j = 0; j < message.Images.length; ++j)
                            object.Images[j] = $root.UIBot.UHOR.ProtoBuf.ImageInfo.toObject(message.Images[j], options);
                    }
                    if (message.CustomizedInfo != null && message.hasOwnProperty("CustomizedInfo"))
                        object.CustomizedInfo = message.CustomizedInfo;
                    if (message.RawData != null && message.hasOwnProperty("RawData"))
                        object.RawData = $root.UIBot.UHOR.ProtoBuf.RawDataInfo.toObject(message.RawData, options);
                    if (message.NlsAppName != null && message.hasOwnProperty("NlsAppName"))
                        object.NlsAppName = message.NlsAppName;
                    if (message.ProcedureBuffer != null && message.hasOwnProperty("ProcedureBuffer"))
                        object.ProcedureBuffer = message.ProcedureBuffer;
                    if (message.PreAttachFlag != null && message.hasOwnProperty("PreAttachFlag"))
                        object.PreAttachFlag = message.PreAttachFlag;
                    if (message.Level != null && message.hasOwnProperty("Level"))
                        object.Level = options.enums === String ? $root.UIBot.UHOR.ProtoBuf.LoadLevel[message.Level] === undefined ? message.Level : $root.UIBot.UHOR.ProtoBuf.LoadLevel[message.Level] : message.Level;
                    if (message.TargetIsStudyList != null && message.hasOwnProperty("TargetIsStudyList"))
                        object.TargetIsStudyList = message.TargetIsStudyList;
                    if (message.AllowAppend != null && message.hasOwnProperty("AllowAppend"))
                        object.AllowAppend = message.AllowAppend;
                    return object;
                };

                /**
                 * Converts this InteractionInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InteractionInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for InteractionInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.InteractionInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                InteractionInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.InteractionInfo";
                };

                return InteractionInfo;
            })();

            ProtoBuf.BoldCalAgreementInfo = (function() {

                /**
                 * Properties of a BoldCalAgreementInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IBoldCalAgreementInfo
                 * @property {string|null} [ProtocalId] BoldCalAgreementInfo ProtocalId
                 * @property {string|null} [ProtocalName] BoldCalAgreementInfo ProtocalName
                 * @property {string|null} [BoldProtocolIdFk] BoldCalAgreementInfo BoldProtocolIdFk
                 * @property {string|null} [ExperimentalcycleId] BoldCalAgreementInfo ExperimentalcycleId
                 * @property {number|null} [GroupCount] BoldCalAgreementInfo GroupCount
                 * @property {boolean|null} [IsDefault] BoldCalAgreementInfo IsDefault
                 * @property {number|null} [BlockSize] BoldCalAgreementInfo BlockSize
                 * @property {number|null} [ActiveTaskStartPoint] BoldCalAgreementInfo ActiveTaskStartPoint
                 * @property {number|null} [ActiveTaskSize] BoldCalAgreementInfo ActiveTaskSize
                 * @property {boolean|null} [IsRightAlign] BoldCalAgreementInfo IsRightAlign
                 * @property {string|null} [StatisticsMethod] BoldCalAgreementInfo StatisticsMethod
                 * @property {boolean|null} [IsSelected] BoldCalAgreementInfo IsSelected
                 * @property {number|null} [StartOffsetValue] BoldCalAgreementInfo StartOffsetValue
                 * @property {boolean|null} [StartOffsetIsEnabled] BoldCalAgreementInfo StartOffsetIsEnabled
                 * @property {boolean|null} [StartOffsetIsChecked] BoldCalAgreementInfo StartOffsetIsChecked
                 * @property {number|null} [SpatialFilterValue] BoldCalAgreementInfo SpatialFilterValue
                 * @property {boolean|null} [SpatialFilterIsEnabled] BoldCalAgreementInfo SpatialFilterIsEnabled
                 * @property {boolean|null} [SpatialFilterIsChecked] BoldCalAgreementInfo SpatialFilterIsChecked
                 * @property {string|null} [SpatialFilterUnit] BoldCalAgreementInfo SpatialFilterUnit
                 * @property {number|null} [TransitionSkipValue] BoldCalAgreementInfo TransitionSkipValue
                 * @property {boolean|null} [TransitionSkipIsEnabled] BoldCalAgreementInfo TransitionSkipIsEnabled
                 * @property {boolean|null} [TransitionSkipIsChecked] BoldCalAgreementInfo TransitionSkipIsChecked
                 * @property {boolean|null} [TemporalFilterIsEnabled] BoldCalAgreementInfo TemporalFilterIsEnabled
                 * @property {boolean|null} [TemporalFilterIsChecked] BoldCalAgreementInfo TemporalFilterIsChecked
                 * @property {boolean|null} [HRFDeconvolutionIsEnabled] BoldCalAgreementInfo HRFDeconvolutionIsEnabled
                 * @property {boolean|null} [HRFDeconvolutionIsChecked] BoldCalAgreementInfo HRFDeconvolutionIsChecked
                 * @property {number|null} [InitialPvalue] BoldCalAgreementInfo InitialPvalue
                 * @property {string|null} [SeriseDescription] BoldCalAgreementInfo SeriseDescription
                 */

                /**
                 * Constructs a new BoldCalAgreementInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a BoldCalAgreementInfo.
                 * @implements IBoldCalAgreementInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IBoldCalAgreementInfo=} [properties] Properties to set
                 */
                function BoldCalAgreementInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BoldCalAgreementInfo ProtocalId.
                 * @member {string} ProtocalId
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.ProtocalId = "";

                /**
                 * BoldCalAgreementInfo ProtocalName.
                 * @member {string} ProtocalName
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.ProtocalName = "";

                /**
                 * BoldCalAgreementInfo BoldProtocolIdFk.
                 * @member {string} BoldProtocolIdFk
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.BoldProtocolIdFk = "";

                /**
                 * BoldCalAgreementInfo ExperimentalcycleId.
                 * @member {string} ExperimentalcycleId
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.ExperimentalcycleId = "";

                /**
                 * BoldCalAgreementInfo GroupCount.
                 * @member {number} GroupCount
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.GroupCount = 0;

                /**
                 * BoldCalAgreementInfo IsDefault.
                 * @member {boolean} IsDefault
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.IsDefault = false;

                /**
                 * BoldCalAgreementInfo BlockSize.
                 * @member {number} BlockSize
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.BlockSize = 0;

                /**
                 * BoldCalAgreementInfo ActiveTaskStartPoint.
                 * @member {number} ActiveTaskStartPoint
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.ActiveTaskStartPoint = 0;

                /**
                 * BoldCalAgreementInfo ActiveTaskSize.
                 * @member {number} ActiveTaskSize
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.ActiveTaskSize = 0;

                /**
                 * BoldCalAgreementInfo IsRightAlign.
                 * @member {boolean} IsRightAlign
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.IsRightAlign = false;

                /**
                 * BoldCalAgreementInfo StatisticsMethod.
                 * @member {string} StatisticsMethod
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.StatisticsMethod = "";

                /**
                 * BoldCalAgreementInfo IsSelected.
                 * @member {boolean} IsSelected
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.IsSelected = false;

                /**
                 * BoldCalAgreementInfo StartOffsetValue.
                 * @member {number} StartOffsetValue
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.StartOffsetValue = 0;

                /**
                 * BoldCalAgreementInfo StartOffsetIsEnabled.
                 * @member {boolean} StartOffsetIsEnabled
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.StartOffsetIsEnabled = false;

                /**
                 * BoldCalAgreementInfo StartOffsetIsChecked.
                 * @member {boolean} StartOffsetIsChecked
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.StartOffsetIsChecked = true;

                /**
                 * BoldCalAgreementInfo SpatialFilterValue.
                 * @member {number} SpatialFilterValue
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.SpatialFilterValue = 0;

                /**
                 * BoldCalAgreementInfo SpatialFilterIsEnabled.
                 * @member {boolean} SpatialFilterIsEnabled
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.SpatialFilterIsEnabled = false;

                /**
                 * BoldCalAgreementInfo SpatialFilterIsChecked.
                 * @member {boolean} SpatialFilterIsChecked
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.SpatialFilterIsChecked = false;

                /**
                 * BoldCalAgreementInfo SpatialFilterUnit.
                 * @member {string} SpatialFilterUnit
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.SpatialFilterUnit = "";

                /**
                 * BoldCalAgreementInfo TransitionSkipValue.
                 * @member {number} TransitionSkipValue
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.TransitionSkipValue = 0;

                /**
                 * BoldCalAgreementInfo TransitionSkipIsEnabled.
                 * @member {boolean} TransitionSkipIsEnabled
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.TransitionSkipIsEnabled = false;

                /**
                 * BoldCalAgreementInfo TransitionSkipIsChecked.
                 * @member {boolean} TransitionSkipIsChecked
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.TransitionSkipIsChecked = false;

                /**
                 * BoldCalAgreementInfo TemporalFilterIsEnabled.
                 * @member {boolean} TemporalFilterIsEnabled
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.TemporalFilterIsEnabled = false;

                /**
                 * BoldCalAgreementInfo TemporalFilterIsChecked.
                 * @member {boolean} TemporalFilterIsChecked
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.TemporalFilterIsChecked = false;

                /**
                 * BoldCalAgreementInfo HRFDeconvolutionIsEnabled.
                 * @member {boolean} HRFDeconvolutionIsEnabled
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.HRFDeconvolutionIsEnabled = false;

                /**
                 * BoldCalAgreementInfo HRFDeconvolutionIsChecked.
                 * @member {boolean} HRFDeconvolutionIsChecked
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.HRFDeconvolutionIsChecked = false;

                /**
                 * BoldCalAgreementInfo InitialPvalue.
                 * @member {number} InitialPvalue
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.InitialPvalue = 0;

                /**
                 * BoldCalAgreementInfo SeriseDescription.
                 * @member {string} SeriseDescription
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 */
                BoldCalAgreementInfo.prototype.SeriseDescription = "";

                /**
                 * Creates a new BoldCalAgreementInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBoldCalAgreementInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo} BoldCalAgreementInfo instance
                 */
                BoldCalAgreementInfo.create = function create(properties) {
                    return new BoldCalAgreementInfo(properties);
                };

                /**
                 * Encodes the specified BoldCalAgreementInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBoldCalAgreementInfo} message BoldCalAgreementInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BoldCalAgreementInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ProtocalId != null && Object.hasOwnProperty.call(message, "ProtocalId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.ProtocalId);
                    if (message.ProtocalName != null && Object.hasOwnProperty.call(message, "ProtocalName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.ProtocalName);
                    if (message.BoldProtocolIdFk != null && Object.hasOwnProperty.call(message, "BoldProtocolIdFk"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.BoldProtocolIdFk);
                    if (message.ExperimentalcycleId != null && Object.hasOwnProperty.call(message, "ExperimentalcycleId"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.ExperimentalcycleId);
                    if (message.GroupCount != null && Object.hasOwnProperty.call(message, "GroupCount"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.GroupCount);
                    if (message.IsDefault != null && Object.hasOwnProperty.call(message, "IsDefault"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.IsDefault);
                    if (message.BlockSize != null && Object.hasOwnProperty.call(message, "BlockSize"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.BlockSize);
                    if (message.ActiveTaskStartPoint != null && Object.hasOwnProperty.call(message, "ActiveTaskStartPoint"))
                        writer.uint32(/* id 8, wireType 1 =*/65).double(message.ActiveTaskStartPoint);
                    if (message.ActiveTaskSize != null && Object.hasOwnProperty.call(message, "ActiveTaskSize"))
                        writer.uint32(/* id 9, wireType 1 =*/73).double(message.ActiveTaskSize);
                    if (message.IsRightAlign != null && Object.hasOwnProperty.call(message, "IsRightAlign"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.IsRightAlign);
                    if (message.StatisticsMethod != null && Object.hasOwnProperty.call(message, "StatisticsMethod"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.StatisticsMethod);
                    if (message.IsSelected != null && Object.hasOwnProperty.call(message, "IsSelected"))
                        writer.uint32(/* id 12, wireType 0 =*/96).bool(message.IsSelected);
                    if (message.StartOffsetValue != null && Object.hasOwnProperty.call(message, "StartOffsetValue"))
                        writer.uint32(/* id 13, wireType 0 =*/104).int32(message.StartOffsetValue);
                    if (message.StartOffsetIsEnabled != null && Object.hasOwnProperty.call(message, "StartOffsetIsEnabled"))
                        writer.uint32(/* id 14, wireType 0 =*/112).bool(message.StartOffsetIsEnabled);
                    if (message.StartOffsetIsChecked != null && Object.hasOwnProperty.call(message, "StartOffsetIsChecked"))
                        writer.uint32(/* id 15, wireType 0 =*/120).bool(message.StartOffsetIsChecked);
                    if (message.SpatialFilterValue != null && Object.hasOwnProperty.call(message, "SpatialFilterValue"))
                        writer.uint32(/* id 16, wireType 0 =*/128).int32(message.SpatialFilterValue);
                    if (message.SpatialFilterIsEnabled != null && Object.hasOwnProperty.call(message, "SpatialFilterIsEnabled"))
                        writer.uint32(/* id 17, wireType 0 =*/136).bool(message.SpatialFilterIsEnabled);
                    if (message.SpatialFilterIsChecked != null && Object.hasOwnProperty.call(message, "SpatialFilterIsChecked"))
                        writer.uint32(/* id 18, wireType 0 =*/144).bool(message.SpatialFilterIsChecked);
                    if (message.SpatialFilterUnit != null && Object.hasOwnProperty.call(message, "SpatialFilterUnit"))
                        writer.uint32(/* id 19, wireType 2 =*/154).string(message.SpatialFilterUnit);
                    if (message.TransitionSkipValue != null && Object.hasOwnProperty.call(message, "TransitionSkipValue"))
                        writer.uint32(/* id 20, wireType 0 =*/160).int32(message.TransitionSkipValue);
                    if (message.TransitionSkipIsEnabled != null && Object.hasOwnProperty.call(message, "TransitionSkipIsEnabled"))
                        writer.uint32(/* id 21, wireType 0 =*/168).bool(message.TransitionSkipIsEnabled);
                    if (message.TransitionSkipIsChecked != null && Object.hasOwnProperty.call(message, "TransitionSkipIsChecked"))
                        writer.uint32(/* id 22, wireType 0 =*/176).bool(message.TransitionSkipIsChecked);
                    if (message.TemporalFilterIsEnabled != null && Object.hasOwnProperty.call(message, "TemporalFilterIsEnabled"))
                        writer.uint32(/* id 23, wireType 0 =*/184).bool(message.TemporalFilterIsEnabled);
                    if (message.TemporalFilterIsChecked != null && Object.hasOwnProperty.call(message, "TemporalFilterIsChecked"))
                        writer.uint32(/* id 24, wireType 0 =*/192).bool(message.TemporalFilterIsChecked);
                    if (message.HRFDeconvolutionIsEnabled != null && Object.hasOwnProperty.call(message, "HRFDeconvolutionIsEnabled"))
                        writer.uint32(/* id 25, wireType 0 =*/200).bool(message.HRFDeconvolutionIsEnabled);
                    if (message.HRFDeconvolutionIsChecked != null && Object.hasOwnProperty.call(message, "HRFDeconvolutionIsChecked"))
                        writer.uint32(/* id 26, wireType 0 =*/208).bool(message.HRFDeconvolutionIsChecked);
                    if (message.InitialPvalue != null && Object.hasOwnProperty.call(message, "InitialPvalue"))
                        writer.uint32(/* id 27, wireType 5 =*/221).float(message.InitialPvalue);
                    if (message.SeriseDescription != null && Object.hasOwnProperty.call(message, "SeriseDescription"))
                        writer.uint32(/* id 28, wireType 2 =*/226).string(message.SeriseDescription);
                    return writer;
                };

                /**
                 * Encodes the specified BoldCalAgreementInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBoldCalAgreementInfo} message BoldCalAgreementInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BoldCalAgreementInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BoldCalAgreementInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo} BoldCalAgreementInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BoldCalAgreementInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.ProtocalId = reader.string();
                                break;
                            }
                        case 2: {
                                message.ProtocalName = reader.string();
                                break;
                            }
                        case 3: {
                                message.BoldProtocolIdFk = reader.string();
                                break;
                            }
                        case 4: {
                                message.ExperimentalcycleId = reader.string();
                                break;
                            }
                        case 5: {
                                message.GroupCount = reader.int32();
                                break;
                            }
                        case 6: {
                                message.IsDefault = reader.bool();
                                break;
                            }
                        case 7: {
                                message.BlockSize = reader.int32();
                                break;
                            }
                        case 8: {
                                message.ActiveTaskStartPoint = reader.double();
                                break;
                            }
                        case 9: {
                                message.ActiveTaskSize = reader.double();
                                break;
                            }
                        case 10: {
                                message.IsRightAlign = reader.bool();
                                break;
                            }
                        case 11: {
                                message.StatisticsMethod = reader.string();
                                break;
                            }
                        case 12: {
                                message.IsSelected = reader.bool();
                                break;
                            }
                        case 13: {
                                message.StartOffsetValue = reader.int32();
                                break;
                            }
                        case 14: {
                                message.StartOffsetIsEnabled = reader.bool();
                                break;
                            }
                        case 15: {
                                message.StartOffsetIsChecked = reader.bool();
                                break;
                            }
                        case 16: {
                                message.SpatialFilterValue = reader.int32();
                                break;
                            }
                        case 17: {
                                message.SpatialFilterIsEnabled = reader.bool();
                                break;
                            }
                        case 18: {
                                message.SpatialFilterIsChecked = reader.bool();
                                break;
                            }
                        case 19: {
                                message.SpatialFilterUnit = reader.string();
                                break;
                            }
                        case 20: {
                                message.TransitionSkipValue = reader.int32();
                                break;
                            }
                        case 21: {
                                message.TransitionSkipIsEnabled = reader.bool();
                                break;
                            }
                        case 22: {
                                message.TransitionSkipIsChecked = reader.bool();
                                break;
                            }
                        case 23: {
                                message.TemporalFilterIsEnabled = reader.bool();
                                break;
                            }
                        case 24: {
                                message.TemporalFilterIsChecked = reader.bool();
                                break;
                            }
                        case 25: {
                                message.HRFDeconvolutionIsEnabled = reader.bool();
                                break;
                            }
                        case 26: {
                                message.HRFDeconvolutionIsChecked = reader.bool();
                                break;
                            }
                        case 27: {
                                message.InitialPvalue = reader.float();
                                break;
                            }
                        case 28: {
                                message.SeriseDescription = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BoldCalAgreementInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo} BoldCalAgreementInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BoldCalAgreementInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BoldCalAgreementInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BoldCalAgreementInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ProtocalId != null && message.hasOwnProperty("ProtocalId"))
                        if (!$util.isString(message.ProtocalId))
                            return "ProtocalId: string expected";
                    if (message.ProtocalName != null && message.hasOwnProperty("ProtocalName"))
                        if (!$util.isString(message.ProtocalName))
                            return "ProtocalName: string expected";
                    if (message.BoldProtocolIdFk != null && message.hasOwnProperty("BoldProtocolIdFk"))
                        if (!$util.isString(message.BoldProtocolIdFk))
                            return "BoldProtocolIdFk: string expected";
                    if (message.ExperimentalcycleId != null && message.hasOwnProperty("ExperimentalcycleId"))
                        if (!$util.isString(message.ExperimentalcycleId))
                            return "ExperimentalcycleId: string expected";
                    if (message.GroupCount != null && message.hasOwnProperty("GroupCount"))
                        if (!$util.isInteger(message.GroupCount))
                            return "GroupCount: integer expected";
                    if (message.IsDefault != null && message.hasOwnProperty("IsDefault"))
                        if (typeof message.IsDefault !== "boolean")
                            return "IsDefault: boolean expected";
                    if (message.BlockSize != null && message.hasOwnProperty("BlockSize"))
                        if (!$util.isInteger(message.BlockSize))
                            return "BlockSize: integer expected";
                    if (message.ActiveTaskStartPoint != null && message.hasOwnProperty("ActiveTaskStartPoint"))
                        if (typeof message.ActiveTaskStartPoint !== "number")
                            return "ActiveTaskStartPoint: number expected";
                    if (message.ActiveTaskSize != null && message.hasOwnProperty("ActiveTaskSize"))
                        if (typeof message.ActiveTaskSize !== "number")
                            return "ActiveTaskSize: number expected";
                    if (message.IsRightAlign != null && message.hasOwnProperty("IsRightAlign"))
                        if (typeof message.IsRightAlign !== "boolean")
                            return "IsRightAlign: boolean expected";
                    if (message.StatisticsMethod != null && message.hasOwnProperty("StatisticsMethod"))
                        if (!$util.isString(message.StatisticsMethod))
                            return "StatisticsMethod: string expected";
                    if (message.IsSelected != null && message.hasOwnProperty("IsSelected"))
                        if (typeof message.IsSelected !== "boolean")
                            return "IsSelected: boolean expected";
                    if (message.StartOffsetValue != null && message.hasOwnProperty("StartOffsetValue"))
                        if (!$util.isInteger(message.StartOffsetValue))
                            return "StartOffsetValue: integer expected";
                    if (message.StartOffsetIsEnabled != null && message.hasOwnProperty("StartOffsetIsEnabled"))
                        if (typeof message.StartOffsetIsEnabled !== "boolean")
                            return "StartOffsetIsEnabled: boolean expected";
                    if (message.StartOffsetIsChecked != null && message.hasOwnProperty("StartOffsetIsChecked"))
                        if (typeof message.StartOffsetIsChecked !== "boolean")
                            return "StartOffsetIsChecked: boolean expected";
                    if (message.SpatialFilterValue != null && message.hasOwnProperty("SpatialFilterValue"))
                        if (!$util.isInteger(message.SpatialFilterValue))
                            return "SpatialFilterValue: integer expected";
                    if (message.SpatialFilterIsEnabled != null && message.hasOwnProperty("SpatialFilterIsEnabled"))
                        if (typeof message.SpatialFilterIsEnabled !== "boolean")
                            return "SpatialFilterIsEnabled: boolean expected";
                    if (message.SpatialFilterIsChecked != null && message.hasOwnProperty("SpatialFilterIsChecked"))
                        if (typeof message.SpatialFilterIsChecked !== "boolean")
                            return "SpatialFilterIsChecked: boolean expected";
                    if (message.SpatialFilterUnit != null && message.hasOwnProperty("SpatialFilterUnit"))
                        if (!$util.isString(message.SpatialFilterUnit))
                            return "SpatialFilterUnit: string expected";
                    if (message.TransitionSkipValue != null && message.hasOwnProperty("TransitionSkipValue"))
                        if (!$util.isInteger(message.TransitionSkipValue))
                            return "TransitionSkipValue: integer expected";
                    if (message.TransitionSkipIsEnabled != null && message.hasOwnProperty("TransitionSkipIsEnabled"))
                        if (typeof message.TransitionSkipIsEnabled !== "boolean")
                            return "TransitionSkipIsEnabled: boolean expected";
                    if (message.TransitionSkipIsChecked != null && message.hasOwnProperty("TransitionSkipIsChecked"))
                        if (typeof message.TransitionSkipIsChecked !== "boolean")
                            return "TransitionSkipIsChecked: boolean expected";
                    if (message.TemporalFilterIsEnabled != null && message.hasOwnProperty("TemporalFilterIsEnabled"))
                        if (typeof message.TemporalFilterIsEnabled !== "boolean")
                            return "TemporalFilterIsEnabled: boolean expected";
                    if (message.TemporalFilterIsChecked != null && message.hasOwnProperty("TemporalFilterIsChecked"))
                        if (typeof message.TemporalFilterIsChecked !== "boolean")
                            return "TemporalFilterIsChecked: boolean expected";
                    if (message.HRFDeconvolutionIsEnabled != null && message.hasOwnProperty("HRFDeconvolutionIsEnabled"))
                        if (typeof message.HRFDeconvolutionIsEnabled !== "boolean")
                            return "HRFDeconvolutionIsEnabled: boolean expected";
                    if (message.HRFDeconvolutionIsChecked != null && message.hasOwnProperty("HRFDeconvolutionIsChecked"))
                        if (typeof message.HRFDeconvolutionIsChecked !== "boolean")
                            return "HRFDeconvolutionIsChecked: boolean expected";
                    if (message.InitialPvalue != null && message.hasOwnProperty("InitialPvalue"))
                        if (typeof message.InitialPvalue !== "number")
                            return "InitialPvalue: number expected";
                    if (message.SeriseDescription != null && message.hasOwnProperty("SeriseDescription"))
                        if (!$util.isString(message.SeriseDescription))
                            return "SeriseDescription: string expected";
                    return null;
                };

                /**
                 * Creates a BoldCalAgreementInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo} BoldCalAgreementInfo
                 */
                BoldCalAgreementInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo();
                    if (object.ProtocalId != null)
                        message.ProtocalId = String(object.ProtocalId);
                    if (object.ProtocalName != null)
                        message.ProtocalName = String(object.ProtocalName);
                    if (object.BoldProtocolIdFk != null)
                        message.BoldProtocolIdFk = String(object.BoldProtocolIdFk);
                    if (object.ExperimentalcycleId != null)
                        message.ExperimentalcycleId = String(object.ExperimentalcycleId);
                    if (object.GroupCount != null)
                        message.GroupCount = object.GroupCount | 0;
                    if (object.IsDefault != null)
                        message.IsDefault = Boolean(object.IsDefault);
                    if (object.BlockSize != null)
                        message.BlockSize = object.BlockSize | 0;
                    if (object.ActiveTaskStartPoint != null)
                        message.ActiveTaskStartPoint = Number(object.ActiveTaskStartPoint);
                    if (object.ActiveTaskSize != null)
                        message.ActiveTaskSize = Number(object.ActiveTaskSize);
                    if (object.IsRightAlign != null)
                        message.IsRightAlign = Boolean(object.IsRightAlign);
                    if (object.StatisticsMethod != null)
                        message.StatisticsMethod = String(object.StatisticsMethod);
                    if (object.IsSelected != null)
                        message.IsSelected = Boolean(object.IsSelected);
                    if (object.StartOffsetValue != null)
                        message.StartOffsetValue = object.StartOffsetValue | 0;
                    if (object.StartOffsetIsEnabled != null)
                        message.StartOffsetIsEnabled = Boolean(object.StartOffsetIsEnabled);
                    if (object.StartOffsetIsChecked != null)
                        message.StartOffsetIsChecked = Boolean(object.StartOffsetIsChecked);
                    if (object.SpatialFilterValue != null)
                        message.SpatialFilterValue = object.SpatialFilterValue | 0;
                    if (object.SpatialFilterIsEnabled != null)
                        message.SpatialFilterIsEnabled = Boolean(object.SpatialFilterIsEnabled);
                    if (object.SpatialFilterIsChecked != null)
                        message.SpatialFilterIsChecked = Boolean(object.SpatialFilterIsChecked);
                    if (object.SpatialFilterUnit != null)
                        message.SpatialFilterUnit = String(object.SpatialFilterUnit);
                    if (object.TransitionSkipValue != null)
                        message.TransitionSkipValue = object.TransitionSkipValue | 0;
                    if (object.TransitionSkipIsEnabled != null)
                        message.TransitionSkipIsEnabled = Boolean(object.TransitionSkipIsEnabled);
                    if (object.TransitionSkipIsChecked != null)
                        message.TransitionSkipIsChecked = Boolean(object.TransitionSkipIsChecked);
                    if (object.TemporalFilterIsEnabled != null)
                        message.TemporalFilterIsEnabled = Boolean(object.TemporalFilterIsEnabled);
                    if (object.TemporalFilterIsChecked != null)
                        message.TemporalFilterIsChecked = Boolean(object.TemporalFilterIsChecked);
                    if (object.HRFDeconvolutionIsEnabled != null)
                        message.HRFDeconvolutionIsEnabled = Boolean(object.HRFDeconvolutionIsEnabled);
                    if (object.HRFDeconvolutionIsChecked != null)
                        message.HRFDeconvolutionIsChecked = Boolean(object.HRFDeconvolutionIsChecked);
                    if (object.InitialPvalue != null)
                        message.InitialPvalue = Number(object.InitialPvalue);
                    if (object.SeriseDescription != null)
                        message.SeriseDescription = String(object.SeriseDescription);
                    return message;
                };

                /**
                 * Creates a plain object from a BoldCalAgreementInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo} message BoldCalAgreementInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BoldCalAgreementInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.ProtocalId = "";
                        object.ProtocalName = "";
                        object.BoldProtocolIdFk = "";
                        object.ExperimentalcycleId = "";
                        object.GroupCount = 0;
                        object.IsDefault = false;
                        object.BlockSize = 0;
                        object.ActiveTaskStartPoint = 0;
                        object.ActiveTaskSize = 0;
                        object.IsRightAlign = false;
                        object.StatisticsMethod = "";
                        object.IsSelected = false;
                        object.StartOffsetValue = 0;
                        object.StartOffsetIsEnabled = false;
                        object.StartOffsetIsChecked = true;
                        object.SpatialFilterValue = 0;
                        object.SpatialFilterIsEnabled = false;
                        object.SpatialFilterIsChecked = false;
                        object.SpatialFilterUnit = "";
                        object.TransitionSkipValue = 0;
                        object.TransitionSkipIsEnabled = false;
                        object.TransitionSkipIsChecked = false;
                        object.TemporalFilterIsEnabled = false;
                        object.TemporalFilterIsChecked = false;
                        object.HRFDeconvolutionIsEnabled = false;
                        object.HRFDeconvolutionIsChecked = false;
                        object.InitialPvalue = 0;
                        object.SeriseDescription = "";
                    }
                    if (message.ProtocalId != null && message.hasOwnProperty("ProtocalId"))
                        object.ProtocalId = message.ProtocalId;
                    if (message.ProtocalName != null && message.hasOwnProperty("ProtocalName"))
                        object.ProtocalName = message.ProtocalName;
                    if (message.BoldProtocolIdFk != null && message.hasOwnProperty("BoldProtocolIdFk"))
                        object.BoldProtocolIdFk = message.BoldProtocolIdFk;
                    if (message.ExperimentalcycleId != null && message.hasOwnProperty("ExperimentalcycleId"))
                        object.ExperimentalcycleId = message.ExperimentalcycleId;
                    if (message.GroupCount != null && message.hasOwnProperty("GroupCount"))
                        object.GroupCount = message.GroupCount;
                    if (message.IsDefault != null && message.hasOwnProperty("IsDefault"))
                        object.IsDefault = message.IsDefault;
                    if (message.BlockSize != null && message.hasOwnProperty("BlockSize"))
                        object.BlockSize = message.BlockSize;
                    if (message.ActiveTaskStartPoint != null && message.hasOwnProperty("ActiveTaskStartPoint"))
                        object.ActiveTaskStartPoint = options.json && !isFinite(message.ActiveTaskStartPoint) ? String(message.ActiveTaskStartPoint) : message.ActiveTaskStartPoint;
                    if (message.ActiveTaskSize != null && message.hasOwnProperty("ActiveTaskSize"))
                        object.ActiveTaskSize = options.json && !isFinite(message.ActiveTaskSize) ? String(message.ActiveTaskSize) : message.ActiveTaskSize;
                    if (message.IsRightAlign != null && message.hasOwnProperty("IsRightAlign"))
                        object.IsRightAlign = message.IsRightAlign;
                    if (message.StatisticsMethod != null && message.hasOwnProperty("StatisticsMethod"))
                        object.StatisticsMethod = message.StatisticsMethod;
                    if (message.IsSelected != null && message.hasOwnProperty("IsSelected"))
                        object.IsSelected = message.IsSelected;
                    if (message.StartOffsetValue != null && message.hasOwnProperty("StartOffsetValue"))
                        object.StartOffsetValue = message.StartOffsetValue;
                    if (message.StartOffsetIsEnabled != null && message.hasOwnProperty("StartOffsetIsEnabled"))
                        object.StartOffsetIsEnabled = message.StartOffsetIsEnabled;
                    if (message.StartOffsetIsChecked != null && message.hasOwnProperty("StartOffsetIsChecked"))
                        object.StartOffsetIsChecked = message.StartOffsetIsChecked;
                    if (message.SpatialFilterValue != null && message.hasOwnProperty("SpatialFilterValue"))
                        object.SpatialFilterValue = message.SpatialFilterValue;
                    if (message.SpatialFilterIsEnabled != null && message.hasOwnProperty("SpatialFilterIsEnabled"))
                        object.SpatialFilterIsEnabled = message.SpatialFilterIsEnabled;
                    if (message.SpatialFilterIsChecked != null && message.hasOwnProperty("SpatialFilterIsChecked"))
                        object.SpatialFilterIsChecked = message.SpatialFilterIsChecked;
                    if (message.SpatialFilterUnit != null && message.hasOwnProperty("SpatialFilterUnit"))
                        object.SpatialFilterUnit = message.SpatialFilterUnit;
                    if (message.TransitionSkipValue != null && message.hasOwnProperty("TransitionSkipValue"))
                        object.TransitionSkipValue = message.TransitionSkipValue;
                    if (message.TransitionSkipIsEnabled != null && message.hasOwnProperty("TransitionSkipIsEnabled"))
                        object.TransitionSkipIsEnabled = message.TransitionSkipIsEnabled;
                    if (message.TransitionSkipIsChecked != null && message.hasOwnProperty("TransitionSkipIsChecked"))
                        object.TransitionSkipIsChecked = message.TransitionSkipIsChecked;
                    if (message.TemporalFilterIsEnabled != null && message.hasOwnProperty("TemporalFilterIsEnabled"))
                        object.TemporalFilterIsEnabled = message.TemporalFilterIsEnabled;
                    if (message.TemporalFilterIsChecked != null && message.hasOwnProperty("TemporalFilterIsChecked"))
                        object.TemporalFilterIsChecked = message.TemporalFilterIsChecked;
                    if (message.HRFDeconvolutionIsEnabled != null && message.hasOwnProperty("HRFDeconvolutionIsEnabled"))
                        object.HRFDeconvolutionIsEnabled = message.HRFDeconvolutionIsEnabled;
                    if (message.HRFDeconvolutionIsChecked != null && message.hasOwnProperty("HRFDeconvolutionIsChecked"))
                        object.HRFDeconvolutionIsChecked = message.HRFDeconvolutionIsChecked;
                    if (message.InitialPvalue != null && message.hasOwnProperty("InitialPvalue"))
                        object.InitialPvalue = options.json && !isFinite(message.InitialPvalue) ? String(message.InitialPvalue) : message.InitialPvalue;
                    if (message.SeriseDescription != null && message.hasOwnProperty("SeriseDescription"))
                        object.SeriseDescription = message.SeriseDescription;
                    return object;
                };

                /**
                 * Converts this BoldCalAgreementInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BoldCalAgreementInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for BoldCalAgreementInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                BoldCalAgreementInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo";
                };

                return BoldCalAgreementInfo;
            })();

            ProtoBuf.BoldProtocolInfo = (function() {

                /**
                 * Properties of a BoldProtocolInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IBoldProtocolInfo
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IBoldCalAgreementInfo>|null} [protocolInfo] BoldProtocolInfo protocolInfo
                 */

                /**
                 * Constructs a new BoldProtocolInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a BoldProtocolInfo.
                 * @implements IBoldProtocolInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IBoldProtocolInfo=} [properties] Properties to set
                 */
                function BoldProtocolInfo(properties) {
                    this.protocolInfo = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BoldProtocolInfo protocolInfo.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IBoldCalAgreementInfo>} protocolInfo
                 * @memberof UIBot.UHOR.ProtoBuf.BoldProtocolInfo
                 * @instance
                 */
                BoldProtocolInfo.prototype.protocolInfo = $util.emptyArray;

                /**
                 * Creates a new BoldProtocolInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.BoldProtocolInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBoldProtocolInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.BoldProtocolInfo} BoldProtocolInfo instance
                 */
                BoldProtocolInfo.create = function create(properties) {
                    return new BoldProtocolInfo(properties);
                };

                /**
                 * Encodes the specified BoldProtocolInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.BoldProtocolInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.BoldProtocolInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBoldProtocolInfo} message BoldProtocolInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BoldProtocolInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.protocolInfo != null && message.protocolInfo.length)
                        for (var i = 0; i < message.protocolInfo.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo.encode(message.protocolInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified BoldProtocolInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.BoldProtocolInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.BoldProtocolInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBoldProtocolInfo} message BoldProtocolInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BoldProtocolInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BoldProtocolInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.BoldProtocolInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.BoldProtocolInfo} BoldProtocolInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BoldProtocolInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.BoldProtocolInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.protocolInfo && message.protocolInfo.length))
                                    message.protocolInfo = [];
                                message.protocolInfo.push($root.UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BoldProtocolInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.BoldProtocolInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.BoldProtocolInfo} BoldProtocolInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BoldProtocolInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BoldProtocolInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.BoldProtocolInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BoldProtocolInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.protocolInfo != null && message.hasOwnProperty("protocolInfo")) {
                        if (!Array.isArray(message.protocolInfo))
                            return "protocolInfo: array expected";
                        for (var i = 0; i < message.protocolInfo.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo.verify(message.protocolInfo[i]);
                            if (error)
                                return "protocolInfo." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a BoldProtocolInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.BoldProtocolInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.BoldProtocolInfo} BoldProtocolInfo
                 */
                BoldProtocolInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.BoldProtocolInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.BoldProtocolInfo();
                    if (object.protocolInfo) {
                        if (!Array.isArray(object.protocolInfo))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.BoldProtocolInfo.protocolInfo: array expected");
                        message.protocolInfo = [];
                        for (var i = 0; i < object.protocolInfo.length; ++i) {
                            if (typeof object.protocolInfo[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.BoldProtocolInfo.protocolInfo: object expected");
                            message.protocolInfo[i] = $root.UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo.fromObject(object.protocolInfo[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a BoldProtocolInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.BoldProtocolInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.BoldProtocolInfo} message BoldProtocolInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BoldProtocolInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.protocolInfo = [];
                    if (message.protocolInfo && message.protocolInfo.length) {
                        object.protocolInfo = [];
                        for (var j = 0; j < message.protocolInfo.length; ++j)
                            object.protocolInfo[j] = $root.UIBot.UHOR.ProtoBuf.BoldCalAgreementInfo.toObject(message.protocolInfo[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this BoldProtocolInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.BoldProtocolInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BoldProtocolInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for BoldProtocolInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.BoldProtocolInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                BoldProtocolInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.BoldProtocolInfo";
                };

                return BoldProtocolInfo;
            })();

            ProtoBuf.DTIProtocolInfo = (function() {

                /**
                 * Properties of a DTIProtocolInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IDTIProtocolInfo
                 * @property {number|null} [FAStartValue] DTIProtocolInfo FAStartValue
                 * @property {number|null} [FAEndValue] DTIProtocolInfo FAEndValue
                 * @property {number|null} [MaxLength] DTIProtocolInfo MaxLength
                 * @property {number|null} [MinLength] DTIProtocolInfo MinLength
                 * @property {number|null} [AngleValue] DTIProtocolInfo AngleValue
                 * @property {number|null} [TraceValue] DTIProtocolInfo TraceValue
                 */

                /**
                 * Constructs a new DTIProtocolInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a DTIProtocolInfo.
                 * @implements IDTIProtocolInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IDTIProtocolInfo=} [properties] Properties to set
                 */
                function DTIProtocolInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DTIProtocolInfo FAStartValue.
                 * @member {number} FAStartValue
                 * @memberof UIBot.UHOR.ProtoBuf.DTIProtocolInfo
                 * @instance
                 */
                DTIProtocolInfo.prototype.FAStartValue = 0;

                /**
                 * DTIProtocolInfo FAEndValue.
                 * @member {number} FAEndValue
                 * @memberof UIBot.UHOR.ProtoBuf.DTIProtocolInfo
                 * @instance
                 */
                DTIProtocolInfo.prototype.FAEndValue = 0;

                /**
                 * DTIProtocolInfo MaxLength.
                 * @member {number} MaxLength
                 * @memberof UIBot.UHOR.ProtoBuf.DTIProtocolInfo
                 * @instance
                 */
                DTIProtocolInfo.prototype.MaxLength = 0;

                /**
                 * DTIProtocolInfo MinLength.
                 * @member {number} MinLength
                 * @memberof UIBot.UHOR.ProtoBuf.DTIProtocolInfo
                 * @instance
                 */
                DTIProtocolInfo.prototype.MinLength = 0;

                /**
                 * DTIProtocolInfo AngleValue.
                 * @member {number} AngleValue
                 * @memberof UIBot.UHOR.ProtoBuf.DTIProtocolInfo
                 * @instance
                 */
                DTIProtocolInfo.prototype.AngleValue = 0;

                /**
                 * DTIProtocolInfo TraceValue.
                 * @member {number} TraceValue
                 * @memberof UIBot.UHOR.ProtoBuf.DTIProtocolInfo
                 * @instance
                 */
                DTIProtocolInfo.prototype.TraceValue = 0;

                /**
                 * Creates a new DTIProtocolInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.DTIProtocolInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IDTIProtocolInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.DTIProtocolInfo} DTIProtocolInfo instance
                 */
                DTIProtocolInfo.create = function create(properties) {
                    return new DTIProtocolInfo(properties);
                };

                /**
                 * Encodes the specified DTIProtocolInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.DTIProtocolInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.DTIProtocolInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IDTIProtocolInfo} message DTIProtocolInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DTIProtocolInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.FAStartValue != null && Object.hasOwnProperty.call(message, "FAStartValue"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.FAStartValue);
                    if (message.FAEndValue != null && Object.hasOwnProperty.call(message, "FAEndValue"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.FAEndValue);
                    if (message.MaxLength != null && Object.hasOwnProperty.call(message, "MaxLength"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.MaxLength);
                    if (message.MinLength != null && Object.hasOwnProperty.call(message, "MinLength"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.MinLength);
                    if (message.AngleValue != null && Object.hasOwnProperty.call(message, "AngleValue"))
                        writer.uint32(/* id 5, wireType 1 =*/41).double(message.AngleValue);
                    if (message.TraceValue != null && Object.hasOwnProperty.call(message, "TraceValue"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.TraceValue);
                    return writer;
                };

                /**
                 * Encodes the specified DTIProtocolInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.DTIProtocolInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.DTIProtocolInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IDTIProtocolInfo} message DTIProtocolInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DTIProtocolInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DTIProtocolInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.DTIProtocolInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.DTIProtocolInfo} DTIProtocolInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DTIProtocolInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.DTIProtocolInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.FAStartValue = reader.double();
                                break;
                            }
                        case 2: {
                                message.FAEndValue = reader.double();
                                break;
                            }
                        case 3: {
                                message.MaxLength = reader.double();
                                break;
                            }
                        case 4: {
                                message.MinLength = reader.double();
                                break;
                            }
                        case 5: {
                                message.AngleValue = reader.double();
                                break;
                            }
                        case 6: {
                                message.TraceValue = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DTIProtocolInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.DTIProtocolInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.DTIProtocolInfo} DTIProtocolInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DTIProtocolInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DTIProtocolInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.DTIProtocolInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DTIProtocolInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.FAStartValue != null && message.hasOwnProperty("FAStartValue"))
                        if (typeof message.FAStartValue !== "number")
                            return "FAStartValue: number expected";
                    if (message.FAEndValue != null && message.hasOwnProperty("FAEndValue"))
                        if (typeof message.FAEndValue !== "number")
                            return "FAEndValue: number expected";
                    if (message.MaxLength != null && message.hasOwnProperty("MaxLength"))
                        if (typeof message.MaxLength !== "number")
                            return "MaxLength: number expected";
                    if (message.MinLength != null && message.hasOwnProperty("MinLength"))
                        if (typeof message.MinLength !== "number")
                            return "MinLength: number expected";
                    if (message.AngleValue != null && message.hasOwnProperty("AngleValue"))
                        if (typeof message.AngleValue !== "number")
                            return "AngleValue: number expected";
                    if (message.TraceValue != null && message.hasOwnProperty("TraceValue"))
                        if (typeof message.TraceValue !== "number")
                            return "TraceValue: number expected";
                    return null;
                };

                /**
                 * Creates a DTIProtocolInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.DTIProtocolInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.DTIProtocolInfo} DTIProtocolInfo
                 */
                DTIProtocolInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.DTIProtocolInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.DTIProtocolInfo();
                    if (object.FAStartValue != null)
                        message.FAStartValue = Number(object.FAStartValue);
                    if (object.FAEndValue != null)
                        message.FAEndValue = Number(object.FAEndValue);
                    if (object.MaxLength != null)
                        message.MaxLength = Number(object.MaxLength);
                    if (object.MinLength != null)
                        message.MinLength = Number(object.MinLength);
                    if (object.AngleValue != null)
                        message.AngleValue = Number(object.AngleValue);
                    if (object.TraceValue != null)
                        message.TraceValue = Number(object.TraceValue);
                    return message;
                };

                /**
                 * Creates a plain object from a DTIProtocolInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.DTIProtocolInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.DTIProtocolInfo} message DTIProtocolInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DTIProtocolInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.FAStartValue = 0;
                        object.FAEndValue = 0;
                        object.MaxLength = 0;
                        object.MinLength = 0;
                        object.AngleValue = 0;
                        object.TraceValue = 0;
                    }
                    if (message.FAStartValue != null && message.hasOwnProperty("FAStartValue"))
                        object.FAStartValue = options.json && !isFinite(message.FAStartValue) ? String(message.FAStartValue) : message.FAStartValue;
                    if (message.FAEndValue != null && message.hasOwnProperty("FAEndValue"))
                        object.FAEndValue = options.json && !isFinite(message.FAEndValue) ? String(message.FAEndValue) : message.FAEndValue;
                    if (message.MaxLength != null && message.hasOwnProperty("MaxLength"))
                        object.MaxLength = options.json && !isFinite(message.MaxLength) ? String(message.MaxLength) : message.MaxLength;
                    if (message.MinLength != null && message.hasOwnProperty("MinLength"))
                        object.MinLength = options.json && !isFinite(message.MinLength) ? String(message.MinLength) : message.MinLength;
                    if (message.AngleValue != null && message.hasOwnProperty("AngleValue"))
                        object.AngleValue = options.json && !isFinite(message.AngleValue) ? String(message.AngleValue) : message.AngleValue;
                    if (message.TraceValue != null && message.hasOwnProperty("TraceValue"))
                        object.TraceValue = options.json && !isFinite(message.TraceValue) ? String(message.TraceValue) : message.TraceValue;
                    return object;
                };

                /**
                 * Converts this DTIProtocolInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.DTIProtocolInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DTIProtocolInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for DTIProtocolInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.DTIProtocolInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                DTIProtocolInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.DTIProtocolInfo";
                };

                return DTIProtocolInfo;
            })();

            ProtoBuf.SeriesTypeInfo = (function() {

                /**
                 * Properties of a SeriesTypeInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface ISeriesTypeInfo
                 * @property {string|null} [SeriesUID] SeriesTypeInfo SeriesUID
                 * @property {boolean|null} [IsRefSeries] SeriesTypeInfo IsRefSeries
                 * @property {UIBot.UHOR.ProtoBuf.SeriseType|null} [SeriseType] SeriesTypeInfo SeriseType
                 * @property {string|null} [pseudoPosName] SeriesTypeInfo pseudoPosName
                 * @property {string|null} [pseudoNegName] SeriesTypeInfo pseudoNegName
                 * @property {UIBot.UHOR.ProtoBuf.NeuroSeriseType|null} [NeuroSeriseType] SeriesTypeInfo NeuroSeriseType
                 * @property {string|null} [Thickness] SeriesTypeInfo Thickness
                 */

                /**
                 * Constructs a new SeriesTypeInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a SeriesTypeInfo.
                 * @implements ISeriesTypeInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.ISeriesTypeInfo=} [properties] Properties to set
                 */
                function SeriesTypeInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SeriesTypeInfo SeriesUID.
                 * @member {string} SeriesUID
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfo
                 * @instance
                 */
                SeriesTypeInfo.prototype.SeriesUID = "";

                /**
                 * SeriesTypeInfo IsRefSeries.
                 * @member {boolean} IsRefSeries
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfo
                 * @instance
                 */
                SeriesTypeInfo.prototype.IsRefSeries = false;

                /**
                 * SeriesTypeInfo SeriseType.
                 * @member {UIBot.UHOR.ProtoBuf.SeriseType} SeriseType
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfo
                 * @instance
                 */
                SeriesTypeInfo.prototype.SeriseType = 0;

                /**
                 * SeriesTypeInfo pseudoPosName.
                 * @member {string} pseudoPosName
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfo
                 * @instance
                 */
                SeriesTypeInfo.prototype.pseudoPosName = "";

                /**
                 * SeriesTypeInfo pseudoNegName.
                 * @member {string} pseudoNegName
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfo
                 * @instance
                 */
                SeriesTypeInfo.prototype.pseudoNegName = "";

                /**
                 * SeriesTypeInfo NeuroSeriseType.
                 * @member {UIBot.UHOR.ProtoBuf.NeuroSeriseType} NeuroSeriseType
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfo
                 * @instance
                 */
                SeriesTypeInfo.prototype.NeuroSeriseType = 0;

                /**
                 * SeriesTypeInfo Thickness.
                 * @member {string} Thickness
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfo
                 * @instance
                 */
                SeriesTypeInfo.prototype.Thickness = "";

                /**
                 * Creates a new SeriesTypeInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ISeriesTypeInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.SeriesTypeInfo} SeriesTypeInfo instance
                 */
                SeriesTypeInfo.create = function create(properties) {
                    return new SeriesTypeInfo(properties);
                };

                /**
                 * Encodes the specified SeriesTypeInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.SeriesTypeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ISeriesTypeInfo} message SeriesTypeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SeriesTypeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.SeriesUID != null && Object.hasOwnProperty.call(message, "SeriesUID"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.SeriesUID);
                    if (message.IsRefSeries != null && Object.hasOwnProperty.call(message, "IsRefSeries"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.IsRefSeries);
                    if (message.SeriseType != null && Object.hasOwnProperty.call(message, "SeriseType"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.SeriseType);
                    if (message.pseudoPosName != null && Object.hasOwnProperty.call(message, "pseudoPosName"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.pseudoPosName);
                    if (message.pseudoNegName != null && Object.hasOwnProperty.call(message, "pseudoNegName"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.pseudoNegName);
                    if (message.NeuroSeriseType != null && Object.hasOwnProperty.call(message, "NeuroSeriseType"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.NeuroSeriseType);
                    if (message.Thickness != null && Object.hasOwnProperty.call(message, "Thickness"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.Thickness);
                    return writer;
                };

                /**
                 * Encodes the specified SeriesTypeInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.SeriesTypeInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ISeriesTypeInfo} message SeriesTypeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SeriesTypeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SeriesTypeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.SeriesTypeInfo} SeriesTypeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SeriesTypeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.SeriesTypeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.SeriesUID = reader.string();
                                break;
                            }
                        case 2: {
                                message.IsRefSeries = reader.bool();
                                break;
                            }
                        case 3: {
                                message.SeriseType = reader.int32();
                                break;
                            }
                        case 4: {
                                message.pseudoPosName = reader.string();
                                break;
                            }
                        case 5: {
                                message.pseudoNegName = reader.string();
                                break;
                            }
                        case 6: {
                                message.NeuroSeriseType = reader.int32();
                                break;
                            }
                        case 7: {
                                message.Thickness = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SeriesTypeInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.SeriesTypeInfo} SeriesTypeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SeriesTypeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SeriesTypeInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SeriesTypeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.SeriesUID != null && message.hasOwnProperty("SeriesUID"))
                        if (!$util.isString(message.SeriesUID))
                            return "SeriesUID: string expected";
                    if (message.IsRefSeries != null && message.hasOwnProperty("IsRefSeries"))
                        if (typeof message.IsRefSeries !== "boolean")
                            return "IsRefSeries: boolean expected";
                    if (message.SeriseType != null && message.hasOwnProperty("SeriseType"))
                        switch (message.SeriseType) {
                        default:
                            return "SeriseType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.pseudoPosName != null && message.hasOwnProperty("pseudoPosName"))
                        if (!$util.isString(message.pseudoPosName))
                            return "pseudoPosName: string expected";
                    if (message.pseudoNegName != null && message.hasOwnProperty("pseudoNegName"))
                        if (!$util.isString(message.pseudoNegName))
                            return "pseudoNegName: string expected";
                    if (message.NeuroSeriseType != null && message.hasOwnProperty("NeuroSeriseType"))
                        switch (message.NeuroSeriseType) {
                        default:
                            return "NeuroSeriseType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                            break;
                        }
                    if (message.Thickness != null && message.hasOwnProperty("Thickness"))
                        if (!$util.isString(message.Thickness))
                            return "Thickness: string expected";
                    return null;
                };

                /**
                 * Creates a SeriesTypeInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.SeriesTypeInfo} SeriesTypeInfo
                 */
                SeriesTypeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.SeriesTypeInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.SeriesTypeInfo();
                    if (object.SeriesUID != null)
                        message.SeriesUID = String(object.SeriesUID);
                    if (object.IsRefSeries != null)
                        message.IsRefSeries = Boolean(object.IsRefSeries);
                    switch (object.SeriseType) {
                    default:
                        if (typeof object.SeriseType === "number") {
                            message.SeriseType = object.SeriseType;
                            break;
                        }
                        break;
                    case "SeriseT1":
                    case 0:
                        message.SeriseType = 0;
                        break;
                    case "SeriseT2":
                    case 1:
                        message.SeriseType = 1;
                        break;
                    case "SeriseBold":
                    case 2:
                        message.SeriseType = 2;
                        break;
                    case "SeriseDTI":
                    case 3:
                        message.SeriseType = 3;
                        break;
                    case "SeriseFlair":
                    case 4:
                        message.SeriseType = 4;
                        break;
                    case "SeriseSWI":
                    case 5:
                        message.SeriseType = 5;
                        break;
                    case "SeriseNone":
                    case 6:
                        message.SeriseType = 6;
                        break;
                    }
                    if (object.pseudoPosName != null)
                        message.pseudoPosName = String(object.pseudoPosName);
                    if (object.pseudoNegName != null)
                        message.pseudoNegName = String(object.pseudoNegName);
                    switch (object.NeuroSeriseType) {
                    default:
                        if (typeof object.NeuroSeriseType === "number") {
                            message.NeuroSeriseType = object.NeuroSeriseType;
                            break;
                        }
                        break;
                    case "NormalSerise":
                    case 0:
                        message.NeuroSeriseType = 0;
                        break;
                    case "DTIResultSerise":
                    case 1:
                        message.NeuroSeriseType = 1;
                        break;
                    case "BoldResultSerise":
                    case 2:
                        message.NeuroSeriseType = 2;
                        break;
                    case "PlanningResultSerise":
                    case 3:
                        message.NeuroSeriseType = 3;
                        break;
                    case "CTA":
                    case 4:
                        message.NeuroSeriseType = 4;
                        break;
                    case "PCA":
                    case 5:
                        message.NeuroSeriseType = 5;
                        break;
                    case "T1":
                    case 6:
                        message.NeuroSeriseType = 6;
                        break;
                    case "T2":
                    case 7:
                        message.NeuroSeriseType = 7;
                        break;
                    case "T1_Flair":
                    case 8:
                        message.NeuroSeriseType = 8;
                        break;
                    case "T2_Flair":
                    case 9:
                        message.NeuroSeriseType = 9;
                        break;
                    case "T1_C":
                    case 10:
                        message.NeuroSeriseType = 10;
                        break;
                    case "T2_C":
                    case 11:
                        message.NeuroSeriseType = 11;
                        break;
                    case "T1_Flair_C":
                    case 12:
                        message.NeuroSeriseType = 12;
                        break;
                    case "T2_Flair_C":
                    case 13:
                        message.NeuroSeriseType = 13;
                        break;
                    }
                    if (object.Thickness != null)
                        message.Thickness = String(object.Thickness);
                    return message;
                };

                /**
                 * Creates a plain object from a SeriesTypeInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.SeriesTypeInfo} message SeriesTypeInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SeriesTypeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.SeriesUID = "";
                        object.IsRefSeries = false;
                        object.SeriseType = options.enums === String ? "SeriseT1" : 0;
                        object.pseudoPosName = "";
                        object.pseudoNegName = "";
                        object.NeuroSeriseType = options.enums === String ? "NormalSerise" : 0;
                        object.Thickness = "";
                    }
                    if (message.SeriesUID != null && message.hasOwnProperty("SeriesUID"))
                        object.SeriesUID = message.SeriesUID;
                    if (message.IsRefSeries != null && message.hasOwnProperty("IsRefSeries"))
                        object.IsRefSeries = message.IsRefSeries;
                    if (message.SeriseType != null && message.hasOwnProperty("SeriseType"))
                        object.SeriseType = options.enums === String ? $root.UIBot.UHOR.ProtoBuf.SeriseType[message.SeriseType] === undefined ? message.SeriseType : $root.UIBot.UHOR.ProtoBuf.SeriseType[message.SeriseType] : message.SeriseType;
                    if (message.pseudoPosName != null && message.hasOwnProperty("pseudoPosName"))
                        object.pseudoPosName = message.pseudoPosName;
                    if (message.pseudoNegName != null && message.hasOwnProperty("pseudoNegName"))
                        object.pseudoNegName = message.pseudoNegName;
                    if (message.NeuroSeriseType != null && message.hasOwnProperty("NeuroSeriseType"))
                        object.NeuroSeriseType = options.enums === String ? $root.UIBot.UHOR.ProtoBuf.NeuroSeriseType[message.NeuroSeriseType] === undefined ? message.NeuroSeriseType : $root.UIBot.UHOR.ProtoBuf.NeuroSeriseType[message.NeuroSeriseType] : message.NeuroSeriseType;
                    if (message.Thickness != null && message.hasOwnProperty("Thickness"))
                        object.Thickness = message.Thickness;
                    return object;
                };

                /**
                 * Converts this SeriesTypeInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SeriesTypeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SeriesTypeInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SeriesTypeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.SeriesTypeInfo";
                };

                return SeriesTypeInfo;
            })();

            ProtoBuf.SeriesTypeInfoList = (function() {

                /**
                 * Properties of a SeriesTypeInfoList.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface ISeriesTypeInfoList
                 * @property {Array.<UIBot.UHOR.ProtoBuf.ISeriesTypeInfo>|null} [SeriesTypeInfoList] SeriesTypeInfoList SeriesTypeInfoList
                 * @property {string|null} [sName] SeriesTypeInfoList sName
                 * @property {string|null} [sSexType] SeriesTypeInfoList sSexType
                 * @property {string|null} [sBirthday] SeriesTypeInfoList sBirthday
                 * @property {string|null} [sStudyDate] SeriesTypeInfoList sStudyDate
                 */

                /**
                 * Constructs a new SeriesTypeInfoList.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a SeriesTypeInfoList.
                 * @implements ISeriesTypeInfoList
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.ISeriesTypeInfoList=} [properties] Properties to set
                 */
                function SeriesTypeInfoList(properties) {
                    this.SeriesTypeInfoList = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SeriesTypeInfoList SeriesTypeInfoList.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.ISeriesTypeInfo>} SeriesTypeInfoList
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfoList
                 * @instance
                 */
                SeriesTypeInfoList.prototype.SeriesTypeInfoList = $util.emptyArray;

                /**
                 * SeriesTypeInfoList sName.
                 * @member {string} sName
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfoList
                 * @instance
                 */
                SeriesTypeInfoList.prototype.sName = "";

                /**
                 * SeriesTypeInfoList sSexType.
                 * @member {string} sSexType
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfoList
                 * @instance
                 */
                SeriesTypeInfoList.prototype.sSexType = "";

                /**
                 * SeriesTypeInfoList sBirthday.
                 * @member {string} sBirthday
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfoList
                 * @instance
                 */
                SeriesTypeInfoList.prototype.sBirthday = "";

                /**
                 * SeriesTypeInfoList sStudyDate.
                 * @member {string} sStudyDate
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfoList
                 * @instance
                 */
                SeriesTypeInfoList.prototype.sStudyDate = "";

                /**
                 * Creates a new SeriesTypeInfoList instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfoList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ISeriesTypeInfoList=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.SeriesTypeInfoList} SeriesTypeInfoList instance
                 */
                SeriesTypeInfoList.create = function create(properties) {
                    return new SeriesTypeInfoList(properties);
                };

                /**
                 * Encodes the specified SeriesTypeInfoList message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.SeriesTypeInfoList.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfoList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ISeriesTypeInfoList} message SeriesTypeInfoList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SeriesTypeInfoList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.SeriesTypeInfoList != null && message.SeriesTypeInfoList.length)
                        for (var i = 0; i < message.SeriesTypeInfoList.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.SeriesTypeInfo.encode(message.SeriesTypeInfoList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.sName != null && Object.hasOwnProperty.call(message, "sName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.sName);
                    if (message.sSexType != null && Object.hasOwnProperty.call(message, "sSexType"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.sSexType);
                    if (message.sBirthday != null && Object.hasOwnProperty.call(message, "sBirthday"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.sBirthday);
                    if (message.sStudyDate != null && Object.hasOwnProperty.call(message, "sStudyDate"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.sStudyDate);
                    return writer;
                };

                /**
                 * Encodes the specified SeriesTypeInfoList message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.SeriesTypeInfoList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfoList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ISeriesTypeInfoList} message SeriesTypeInfoList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SeriesTypeInfoList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SeriesTypeInfoList message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfoList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.SeriesTypeInfoList} SeriesTypeInfoList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SeriesTypeInfoList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.SeriesTypeInfoList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.SeriesTypeInfoList && message.SeriesTypeInfoList.length))
                                    message.SeriesTypeInfoList = [];
                                message.SeriesTypeInfoList.push($root.UIBot.UHOR.ProtoBuf.SeriesTypeInfo.decode(reader, reader.uint32()));
                                break;
                            }
                        case 2: {
                                message.sName = reader.string();
                                break;
                            }
                        case 3: {
                                message.sSexType = reader.string();
                                break;
                            }
                        case 4: {
                                message.sBirthday = reader.string();
                                break;
                            }
                        case 5: {
                                message.sStudyDate = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SeriesTypeInfoList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfoList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.SeriesTypeInfoList} SeriesTypeInfoList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SeriesTypeInfoList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SeriesTypeInfoList message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfoList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SeriesTypeInfoList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.SeriesTypeInfoList != null && message.hasOwnProperty("SeriesTypeInfoList")) {
                        if (!Array.isArray(message.SeriesTypeInfoList))
                            return "SeriesTypeInfoList: array expected";
                        for (var i = 0; i < message.SeriesTypeInfoList.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.SeriesTypeInfo.verify(message.SeriesTypeInfoList[i]);
                            if (error)
                                return "SeriesTypeInfoList." + error;
                        }
                    }
                    if (message.sName != null && message.hasOwnProperty("sName"))
                        if (!$util.isString(message.sName))
                            return "sName: string expected";
                    if (message.sSexType != null && message.hasOwnProperty("sSexType"))
                        if (!$util.isString(message.sSexType))
                            return "sSexType: string expected";
                    if (message.sBirthday != null && message.hasOwnProperty("sBirthday"))
                        if (!$util.isString(message.sBirthday))
                            return "sBirthday: string expected";
                    if (message.sStudyDate != null && message.hasOwnProperty("sStudyDate"))
                        if (!$util.isString(message.sStudyDate))
                            return "sStudyDate: string expected";
                    return null;
                };

                /**
                 * Creates a SeriesTypeInfoList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfoList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.SeriesTypeInfoList} SeriesTypeInfoList
                 */
                SeriesTypeInfoList.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.SeriesTypeInfoList)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.SeriesTypeInfoList();
                    if (object.SeriesTypeInfoList) {
                        if (!Array.isArray(object.SeriesTypeInfoList))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.SeriesTypeInfoList.SeriesTypeInfoList: array expected");
                        message.SeriesTypeInfoList = [];
                        for (var i = 0; i < object.SeriesTypeInfoList.length; ++i) {
                            if (typeof object.SeriesTypeInfoList[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.SeriesTypeInfoList.SeriesTypeInfoList: object expected");
                            message.SeriesTypeInfoList[i] = $root.UIBot.UHOR.ProtoBuf.SeriesTypeInfo.fromObject(object.SeriesTypeInfoList[i]);
                        }
                    }
                    if (object.sName != null)
                        message.sName = String(object.sName);
                    if (object.sSexType != null)
                        message.sSexType = String(object.sSexType);
                    if (object.sBirthday != null)
                        message.sBirthday = String(object.sBirthday);
                    if (object.sStudyDate != null)
                        message.sStudyDate = String(object.sStudyDate);
                    return message;
                };

                /**
                 * Creates a plain object from a SeriesTypeInfoList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfoList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.SeriesTypeInfoList} message SeriesTypeInfoList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SeriesTypeInfoList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.SeriesTypeInfoList = [];
                    if (options.defaults) {
                        object.sName = "";
                        object.sSexType = "";
                        object.sBirthday = "";
                        object.sStudyDate = "";
                    }
                    if (message.SeriesTypeInfoList && message.SeriesTypeInfoList.length) {
                        object.SeriesTypeInfoList = [];
                        for (var j = 0; j < message.SeriesTypeInfoList.length; ++j)
                            object.SeriesTypeInfoList[j] = $root.UIBot.UHOR.ProtoBuf.SeriesTypeInfo.toObject(message.SeriesTypeInfoList[j], options);
                    }
                    if (message.sName != null && message.hasOwnProperty("sName"))
                        object.sName = message.sName;
                    if (message.sSexType != null && message.hasOwnProperty("sSexType"))
                        object.sSexType = message.sSexType;
                    if (message.sBirthday != null && message.hasOwnProperty("sBirthday"))
                        object.sBirthday = message.sBirthday;
                    if (message.sStudyDate != null && message.hasOwnProperty("sStudyDate"))
                        object.sStudyDate = message.sStudyDate;
                    return object;
                };

                /**
                 * Converts this SeriesTypeInfoList to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfoList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SeriesTypeInfoList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SeriesTypeInfoList
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.SeriesTypeInfoList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SeriesTypeInfoList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.SeriesTypeInfoList";
                };

                return SeriesTypeInfoList;
            })();

            ProtoBuf.MocoCurveInfo = (function() {

                /**
                 * Properties of a MocoCurveInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMocoCurveInfo
                 * @property {string} UID MocoCurveInfo UID
                 * @property {number} iSize MocoCurveInfo iSize
                 * @property {string} sRx MocoCurveInfo sRx
                 * @property {string} sRy MocoCurveInfo sRy
                 * @property {string} sRz MocoCurveInfo sRz
                 * @property {string} sTx MocoCurveInfo sTx
                 * @property {string} sTy MocoCurveInfo sTy
                 * @property {string} sTz MocoCurveInfo sTz
                 * @property {string} sParadigm MocoCurveInfo sParadigm
                 */

                /**
                 * Constructs a new MocoCurveInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MocoCurveInfo.
                 * @implements IMocoCurveInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMocoCurveInfo=} [properties] Properties to set
                 */
                function MocoCurveInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MocoCurveInfo UID.
                 * @member {string} UID
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @instance
                 */
                MocoCurveInfo.prototype.UID = "";

                /**
                 * MocoCurveInfo iSize.
                 * @member {number} iSize
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @instance
                 */
                MocoCurveInfo.prototype.iSize = 0;

                /**
                 * MocoCurveInfo sRx.
                 * @member {string} sRx
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @instance
                 */
                MocoCurveInfo.prototype.sRx = "";

                /**
                 * MocoCurveInfo sRy.
                 * @member {string} sRy
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @instance
                 */
                MocoCurveInfo.prototype.sRy = "";

                /**
                 * MocoCurveInfo sRz.
                 * @member {string} sRz
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @instance
                 */
                MocoCurveInfo.prototype.sRz = "";

                /**
                 * MocoCurveInfo sTx.
                 * @member {string} sTx
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @instance
                 */
                MocoCurveInfo.prototype.sTx = "";

                /**
                 * MocoCurveInfo sTy.
                 * @member {string} sTy
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @instance
                 */
                MocoCurveInfo.prototype.sTy = "";

                /**
                 * MocoCurveInfo sTz.
                 * @member {string} sTz
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @instance
                 */
                MocoCurveInfo.prototype.sTz = "";

                /**
                 * MocoCurveInfo sParadigm.
                 * @member {string} sParadigm
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @instance
                 */
                MocoCurveInfo.prototype.sParadigm = "";

                /**
                 * Creates a new MocoCurveInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMocoCurveInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MocoCurveInfo} MocoCurveInfo instance
                 */
                MocoCurveInfo.create = function create(properties) {
                    return new MocoCurveInfo(properties);
                };

                /**
                 * Encodes the specified MocoCurveInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MocoCurveInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMocoCurveInfo} message MocoCurveInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MocoCurveInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.UID);
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.iSize);
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.sRx);
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.sRy);
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.sRz);
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.sTx);
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.sTy);
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.sTz);
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.sParadigm);
                    return writer;
                };

                /**
                 * Encodes the specified MocoCurveInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MocoCurveInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMocoCurveInfo} message MocoCurveInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MocoCurveInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MocoCurveInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MocoCurveInfo} MocoCurveInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MocoCurveInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MocoCurveInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.UID = reader.string();
                                break;
                            }
                        case 2: {
                                message.iSize = reader.int32();
                                break;
                            }
                        case 3: {
                                message.sRx = reader.string();
                                break;
                            }
                        case 4: {
                                message.sRy = reader.string();
                                break;
                            }
                        case 5: {
                                message.sRz = reader.string();
                                break;
                            }
                        case 6: {
                                message.sTx = reader.string();
                                break;
                            }
                        case 7: {
                                message.sTy = reader.string();
                                break;
                            }
                        case 8: {
                                message.sTz = reader.string();
                                break;
                            }
                        case 9: {
                                message.sParadigm = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("UID"))
                        throw $util.ProtocolError("missing required 'UID'", { instance: message });
                    if (!message.hasOwnProperty("iSize"))
                        throw $util.ProtocolError("missing required 'iSize'", { instance: message });
                    if (!message.hasOwnProperty("sRx"))
                        throw $util.ProtocolError("missing required 'sRx'", { instance: message });
                    if (!message.hasOwnProperty("sRy"))
                        throw $util.ProtocolError("missing required 'sRy'", { instance: message });
                    if (!message.hasOwnProperty("sRz"))
                        throw $util.ProtocolError("missing required 'sRz'", { instance: message });
                    if (!message.hasOwnProperty("sTx"))
                        throw $util.ProtocolError("missing required 'sTx'", { instance: message });
                    if (!message.hasOwnProperty("sTy"))
                        throw $util.ProtocolError("missing required 'sTy'", { instance: message });
                    if (!message.hasOwnProperty("sTz"))
                        throw $util.ProtocolError("missing required 'sTz'", { instance: message });
                    if (!message.hasOwnProperty("sParadigm"))
                        throw $util.ProtocolError("missing required 'sParadigm'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a MocoCurveInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MocoCurveInfo} MocoCurveInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MocoCurveInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MocoCurveInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MocoCurveInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.UID))
                        return "UID: string expected";
                    if (!$util.isInteger(message.iSize))
                        return "iSize: integer expected";
                    if (!$util.isString(message.sRx))
                        return "sRx: string expected";
                    if (!$util.isString(message.sRy))
                        return "sRy: string expected";
                    if (!$util.isString(message.sRz))
                        return "sRz: string expected";
                    if (!$util.isString(message.sTx))
                        return "sTx: string expected";
                    if (!$util.isString(message.sTy))
                        return "sTy: string expected";
                    if (!$util.isString(message.sTz))
                        return "sTz: string expected";
                    if (!$util.isString(message.sParadigm))
                        return "sParadigm: string expected";
                    return null;
                };

                /**
                 * Creates a MocoCurveInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MocoCurveInfo} MocoCurveInfo
                 */
                MocoCurveInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MocoCurveInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MocoCurveInfo();
                    if (object.UID != null)
                        message.UID = String(object.UID);
                    if (object.iSize != null)
                        message.iSize = object.iSize | 0;
                    if (object.sRx != null)
                        message.sRx = String(object.sRx);
                    if (object.sRy != null)
                        message.sRy = String(object.sRy);
                    if (object.sRz != null)
                        message.sRz = String(object.sRz);
                    if (object.sTx != null)
                        message.sTx = String(object.sTx);
                    if (object.sTy != null)
                        message.sTy = String(object.sTy);
                    if (object.sTz != null)
                        message.sTz = String(object.sTz);
                    if (object.sParadigm != null)
                        message.sParadigm = String(object.sParadigm);
                    return message;
                };

                /**
                 * Creates a plain object from a MocoCurveInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MocoCurveInfo} message MocoCurveInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MocoCurveInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.UID = "";
                        object.iSize = 0;
                        object.sRx = "";
                        object.sRy = "";
                        object.sRz = "";
                        object.sTx = "";
                        object.sTy = "";
                        object.sTz = "";
                        object.sParadigm = "";
                    }
                    if (message.UID != null && message.hasOwnProperty("UID"))
                        object.UID = message.UID;
                    if (message.iSize != null && message.hasOwnProperty("iSize"))
                        object.iSize = message.iSize;
                    if (message.sRx != null && message.hasOwnProperty("sRx"))
                        object.sRx = message.sRx;
                    if (message.sRy != null && message.hasOwnProperty("sRy"))
                        object.sRy = message.sRy;
                    if (message.sRz != null && message.hasOwnProperty("sRz"))
                        object.sRz = message.sRz;
                    if (message.sTx != null && message.hasOwnProperty("sTx"))
                        object.sTx = message.sTx;
                    if (message.sTy != null && message.hasOwnProperty("sTy"))
                        object.sTy = message.sTy;
                    if (message.sTz != null && message.hasOwnProperty("sTz"))
                        object.sTz = message.sTz;
                    if (message.sParadigm != null && message.hasOwnProperty("sParadigm"))
                        object.sParadigm = message.sParadigm;
                    return object;
                };

                /**
                 * Converts this MocoCurveInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MocoCurveInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MocoCurveInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MocoCurveInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MocoCurveInfo";
                };

                return MocoCurveInfo;
            })();

            ProtoBuf.MocoCurveInfoList = (function() {

                /**
                 * Properties of a MocoCurveInfoList.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMocoCurveInfoList
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IMocoCurveInfo>|null} [MocoCurveInfoList] MocoCurveInfoList MocoCurveInfoList
                 */

                /**
                 * Constructs a new MocoCurveInfoList.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MocoCurveInfoList.
                 * @implements IMocoCurveInfoList
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMocoCurveInfoList=} [properties] Properties to set
                 */
                function MocoCurveInfoList(properties) {
                    this.MocoCurveInfoList = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MocoCurveInfoList MocoCurveInfoList.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IMocoCurveInfo>} MocoCurveInfoList
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfoList
                 * @instance
                 */
                MocoCurveInfoList.prototype.MocoCurveInfoList = $util.emptyArray;

                /**
                 * Creates a new MocoCurveInfoList instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfoList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMocoCurveInfoList=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MocoCurveInfoList} MocoCurveInfoList instance
                 */
                MocoCurveInfoList.create = function create(properties) {
                    return new MocoCurveInfoList(properties);
                };

                /**
                 * Encodes the specified MocoCurveInfoList message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MocoCurveInfoList.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfoList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMocoCurveInfoList} message MocoCurveInfoList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MocoCurveInfoList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.MocoCurveInfoList != null && message.MocoCurveInfoList.length)
                        for (var i = 0; i < message.MocoCurveInfoList.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.MocoCurveInfo.encode(message.MocoCurveInfoList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MocoCurveInfoList message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MocoCurveInfoList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfoList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMocoCurveInfoList} message MocoCurveInfoList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MocoCurveInfoList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MocoCurveInfoList message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfoList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MocoCurveInfoList} MocoCurveInfoList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MocoCurveInfoList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MocoCurveInfoList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.MocoCurveInfoList && message.MocoCurveInfoList.length))
                                    message.MocoCurveInfoList = [];
                                message.MocoCurveInfoList.push($root.UIBot.UHOR.ProtoBuf.MocoCurveInfo.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MocoCurveInfoList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfoList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MocoCurveInfoList} MocoCurveInfoList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MocoCurveInfoList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MocoCurveInfoList message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfoList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MocoCurveInfoList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.MocoCurveInfoList != null && message.hasOwnProperty("MocoCurveInfoList")) {
                        if (!Array.isArray(message.MocoCurveInfoList))
                            return "MocoCurveInfoList: array expected";
                        for (var i = 0; i < message.MocoCurveInfoList.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.MocoCurveInfo.verify(message.MocoCurveInfoList[i]);
                            if (error)
                                return "MocoCurveInfoList." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MocoCurveInfoList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfoList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MocoCurveInfoList} MocoCurveInfoList
                 */
                MocoCurveInfoList.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MocoCurveInfoList)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MocoCurveInfoList();
                    if (object.MocoCurveInfoList) {
                        if (!Array.isArray(object.MocoCurveInfoList))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MocoCurveInfoList.MocoCurveInfoList: array expected");
                        message.MocoCurveInfoList = [];
                        for (var i = 0; i < object.MocoCurveInfoList.length; ++i) {
                            if (typeof object.MocoCurveInfoList[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MocoCurveInfoList.MocoCurveInfoList: object expected");
                            message.MocoCurveInfoList[i] = $root.UIBot.UHOR.ProtoBuf.MocoCurveInfo.fromObject(object.MocoCurveInfoList[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MocoCurveInfoList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfoList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MocoCurveInfoList} message MocoCurveInfoList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MocoCurveInfoList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.MocoCurveInfoList = [];
                    if (message.MocoCurveInfoList && message.MocoCurveInfoList.length) {
                        object.MocoCurveInfoList = [];
                        for (var j = 0; j < message.MocoCurveInfoList.length; ++j)
                            object.MocoCurveInfoList[j] = $root.UIBot.UHOR.ProtoBuf.MocoCurveInfo.toObject(message.MocoCurveInfoList[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MocoCurveInfoList to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfoList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MocoCurveInfoList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MocoCurveInfoList
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MocoCurveInfoList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MocoCurveInfoList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MocoCurveInfoList";
                };

                return MocoCurveInfoList;
            })();

            ProtoBuf.MsgTrajectoryOper = (function() {

                /**
                 * Properties of a MsgTrajectoryOper.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMsgTrajectoryOper
                 * @property {string} operType MsgTrajectoryOper operType
                 * @property {number|null} [index] MsgTrajectoryOper index
                 * @property {Uint8Array|null} [operValue] MsgTrajectoryOper operValue
                 */

                /**
                 * Constructs a new MsgTrajectoryOper.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MsgTrajectoryOper.
                 * @implements IMsgTrajectoryOper
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMsgTrajectoryOper=} [properties] Properties to set
                 */
                function MsgTrajectoryOper(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MsgTrajectoryOper operType.
                 * @member {string} operType
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTrajectoryOper
                 * @instance
                 */
                MsgTrajectoryOper.prototype.operType = "";

                /**
                 * MsgTrajectoryOper index.
                 * @member {number} index
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTrajectoryOper
                 * @instance
                 */
                MsgTrajectoryOper.prototype.index = 0;

                /**
                 * MsgTrajectoryOper operValue.
                 * @member {Uint8Array} operValue
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTrajectoryOper
                 * @instance
                 */
                MsgTrajectoryOper.prototype.operValue = $util.newBuffer([]);

                /**
                 * Creates a new MsgTrajectoryOper instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTrajectoryOper
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgTrajectoryOper=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MsgTrajectoryOper} MsgTrajectoryOper instance
                 */
                MsgTrajectoryOper.create = function create(properties) {
                    return new MsgTrajectoryOper(properties);
                };

                /**
                 * Encodes the specified MsgTrajectoryOper message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgTrajectoryOper.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTrajectoryOper
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgTrajectoryOper} message MsgTrajectoryOper message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgTrajectoryOper.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.operType);
                    if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
                    if (message.operValue != null && Object.hasOwnProperty.call(message, "operValue"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.operValue);
                    return writer;
                };

                /**
                 * Encodes the specified MsgTrajectoryOper message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgTrajectoryOper.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTrajectoryOper
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgTrajectoryOper} message MsgTrajectoryOper message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgTrajectoryOper.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MsgTrajectoryOper message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTrajectoryOper
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MsgTrajectoryOper} MsgTrajectoryOper
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgTrajectoryOper.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MsgTrajectoryOper();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.operType = reader.string();
                                break;
                            }
                        case 2: {
                                message.index = reader.int32();
                                break;
                            }
                        case 3: {
                                message.operValue = reader.bytes();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("operType"))
                        throw $util.ProtocolError("missing required 'operType'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a MsgTrajectoryOper message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTrajectoryOper
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MsgTrajectoryOper} MsgTrajectoryOper
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgTrajectoryOper.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MsgTrajectoryOper message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTrajectoryOper
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgTrajectoryOper.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.operType))
                        return "operType: string expected";
                    if (message.index != null && message.hasOwnProperty("index"))
                        if (!$util.isInteger(message.index))
                            return "index: integer expected";
                    if (message.operValue != null && message.hasOwnProperty("operValue"))
                        if (!(message.operValue && typeof message.operValue.length === "number" || $util.isString(message.operValue)))
                            return "operValue: buffer expected";
                    return null;
                };

                /**
                 * Creates a MsgTrajectoryOper message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTrajectoryOper
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MsgTrajectoryOper} MsgTrajectoryOper
                 */
                MsgTrajectoryOper.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MsgTrajectoryOper)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MsgTrajectoryOper();
                    if (object.operType != null)
                        message.operType = String(object.operType);
                    if (object.index != null)
                        message.index = object.index | 0;
                    if (object.operValue != null)
                        if (typeof object.operValue === "string")
                            $util.base64.decode(object.operValue, message.operValue = $util.newBuffer($util.base64.length(object.operValue)), 0);
                        else if (object.operValue.length >= 0)
                            message.operValue = object.operValue;
                    return message;
                };

                /**
                 * Creates a plain object from a MsgTrajectoryOper message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTrajectoryOper
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MsgTrajectoryOper} message MsgTrajectoryOper
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgTrajectoryOper.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.operType = "";
                        object.index = 0;
                        if (options.bytes === String)
                            object.operValue = "";
                        else {
                            object.operValue = [];
                            if (options.bytes !== Array)
                                object.operValue = $util.newBuffer(object.operValue);
                        }
                    }
                    if (message.operType != null && message.hasOwnProperty("operType"))
                        object.operType = message.operType;
                    if (message.index != null && message.hasOwnProperty("index"))
                        object.index = message.index;
                    if (message.operValue != null && message.hasOwnProperty("operValue"))
                        object.operValue = options.bytes === String ? $util.base64.encode(message.operValue, 0, message.operValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.operValue) : message.operValue;
                    return object;
                };

                /**
                 * Converts this MsgTrajectoryOper to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTrajectoryOper
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgTrajectoryOper.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MsgTrajectoryOper
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTrajectoryOper
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MsgTrajectoryOper.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MsgTrajectoryOper";
                };

                return MsgTrajectoryOper;
            })();

            ProtoBuf.MsgSetTrajectoryViewInfo = (function() {

                /**
                 * Properties of a MsgSetTrajectoryViewInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMsgSetTrajectoryViewInfo
                 * @property {string|null} [CellName] MsgSetTrajectoryViewInfo CellName
                 */

                /**
                 * Constructs a new MsgSetTrajectoryViewInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MsgSetTrajectoryViewInfo.
                 * @implements IMsgSetTrajectoryViewInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMsgSetTrajectoryViewInfo=} [properties] Properties to set
                 */
                function MsgSetTrajectoryViewInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MsgSetTrajectoryViewInfo CellName.
                 * @member {string} CellName
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo
                 * @instance
                 */
                MsgSetTrajectoryViewInfo.prototype.CellName = "";

                /**
                 * Creates a new MsgSetTrajectoryViewInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgSetTrajectoryViewInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo} MsgSetTrajectoryViewInfo instance
                 */
                MsgSetTrajectoryViewInfo.create = function create(properties) {
                    return new MsgSetTrajectoryViewInfo(properties);
                };

                /**
                 * Encodes the specified MsgSetTrajectoryViewInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgSetTrajectoryViewInfo} message MsgSetTrajectoryViewInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgSetTrajectoryViewInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.CellName != null && Object.hasOwnProperty.call(message, "CellName"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.CellName);
                    return writer;
                };

                /**
                 * Encodes the specified MsgSetTrajectoryViewInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgSetTrajectoryViewInfo} message MsgSetTrajectoryViewInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgSetTrajectoryViewInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MsgSetTrajectoryViewInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo} MsgSetTrajectoryViewInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgSetTrajectoryViewInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.CellName = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MsgSetTrajectoryViewInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo} MsgSetTrajectoryViewInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgSetTrajectoryViewInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MsgSetTrajectoryViewInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgSetTrajectoryViewInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.CellName != null && message.hasOwnProperty("CellName"))
                        if (!$util.isString(message.CellName))
                            return "CellName: string expected";
                    return null;
                };

                /**
                 * Creates a MsgSetTrajectoryViewInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo} MsgSetTrajectoryViewInfo
                 */
                MsgSetTrajectoryViewInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo();
                    if (object.CellName != null)
                        message.CellName = String(object.CellName);
                    return message;
                };

                /**
                 * Creates a plain object from a MsgSetTrajectoryViewInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo} message MsgSetTrajectoryViewInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgSetTrajectoryViewInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.CellName = "";
                    if (message.CellName != null && message.hasOwnProperty("CellName"))
                        object.CellName = message.CellName;
                    return object;
                };

                /**
                 * Converts this MsgSetTrajectoryViewInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgSetTrajectoryViewInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MsgSetTrajectoryViewInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MsgSetTrajectoryViewInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MsgSetTrajectoryViewInfo";
                };

                return MsgSetTrajectoryViewInfo;
            })();

            ProtoBuf.MsgNeuroTrajectoryOtherInfo = (function() {

                /**
                 * Properties of a MsgNeuroTrajectoryOtherInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMsgNeuroTrajectoryOtherInfo
                 * @property {boolean|null} [hasInterference] MsgNeuroTrajectoryOtherInfo hasInterference
                 * @property {number|null} [countInterference_Blood] MsgNeuroTrajectoryOtherInfo countInterference_Blood
                 * @property {number|null} [countInterference_Traj] MsgNeuroTrajectoryOtherInfo countInterference_Traj
                 * @property {Array.<string>|null} [idsInterference_Traj] MsgNeuroTrajectoryOtherInfo idsInterference_Traj
                 * @property {Array.<UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.IMsgElectrode>|null} [elecGroup] MsgNeuroTrajectoryOtherInfo elecGroup
                 * @property {number|null} [elecDiameter] MsgNeuroTrajectoryOtherInfo elecDiameter
                 * @property {boolean|null} [isElecEnable] MsgNeuroTrajectoryOtherInfo isElecEnable
                 */

                /**
                 * Constructs a new MsgNeuroTrajectoryOtherInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MsgNeuroTrajectoryOtherInfo.
                 * @implements IMsgNeuroTrajectoryOtherInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMsgNeuroTrajectoryOtherInfo=} [properties] Properties to set
                 */
                function MsgNeuroTrajectoryOtherInfo(properties) {
                    this.idsInterference_Traj = [];
                    this.elecGroup = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MsgNeuroTrajectoryOtherInfo hasInterference.
                 * @member {boolean} hasInterference
                 * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                 * @instance
                 */
                MsgNeuroTrajectoryOtherInfo.prototype.hasInterference = false;

                /**
                 * MsgNeuroTrajectoryOtherInfo countInterference_Blood.
                 * @member {number} countInterference_Blood
                 * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                 * @instance
                 */
                MsgNeuroTrajectoryOtherInfo.prototype.countInterference_Blood = 0;

                /**
                 * MsgNeuroTrajectoryOtherInfo countInterference_Traj.
                 * @member {number} countInterference_Traj
                 * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                 * @instance
                 */
                MsgNeuroTrajectoryOtherInfo.prototype.countInterference_Traj = 0;

                /**
                 * MsgNeuroTrajectoryOtherInfo idsInterference_Traj.
                 * @member {Array.<string>} idsInterference_Traj
                 * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                 * @instance
                 */
                MsgNeuroTrajectoryOtherInfo.prototype.idsInterference_Traj = $util.emptyArray;

                /**
                 * MsgNeuroTrajectoryOtherInfo elecGroup.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.IMsgElectrode>} elecGroup
                 * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                 * @instance
                 */
                MsgNeuroTrajectoryOtherInfo.prototype.elecGroup = $util.emptyArray;

                /**
                 * MsgNeuroTrajectoryOtherInfo elecDiameter.
                 * @member {number} elecDiameter
                 * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                 * @instance
                 */
                MsgNeuroTrajectoryOtherInfo.prototype.elecDiameter = 0;

                /**
                 * MsgNeuroTrajectoryOtherInfo isElecEnable.
                 * @member {boolean} isElecEnable
                 * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                 * @instance
                 */
                MsgNeuroTrajectoryOtherInfo.prototype.isElecEnable = false;

                /**
                 * Creates a new MsgNeuroTrajectoryOtherInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgNeuroTrajectoryOtherInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo} MsgNeuroTrajectoryOtherInfo instance
                 */
                MsgNeuroTrajectoryOtherInfo.create = function create(properties) {
                    return new MsgNeuroTrajectoryOtherInfo(properties);
                };

                /**
                 * Encodes the specified MsgNeuroTrajectoryOtherInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgNeuroTrajectoryOtherInfo} message MsgNeuroTrajectoryOtherInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgNeuroTrajectoryOtherInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.hasInterference != null && Object.hasOwnProperty.call(message, "hasInterference"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.hasInterference);
                    if (message.countInterference_Blood != null && Object.hasOwnProperty.call(message, "countInterference_Blood"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.countInterference_Blood);
                    if (message.countInterference_Traj != null && Object.hasOwnProperty.call(message, "countInterference_Traj"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.countInterference_Traj);
                    if (message.idsInterference_Traj != null && message.idsInterference_Traj.length)
                        for (var i = 0; i < message.idsInterference_Traj.length; ++i)
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.idsInterference_Traj[i]);
                    if (message.elecGroup != null && message.elecGroup.length)
                        for (var i = 0; i < message.elecGroup.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode.encode(message.elecGroup[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.elecDiameter != null && Object.hasOwnProperty.call(message, "elecDiameter"))
                        writer.uint32(/* id 6, wireType 5 =*/53).float(message.elecDiameter);
                    if (message.isElecEnable != null && Object.hasOwnProperty.call(message, "isElecEnable"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isElecEnable);
                    return writer;
                };

                /**
                 * Encodes the specified MsgNeuroTrajectoryOtherInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgNeuroTrajectoryOtherInfo} message MsgNeuroTrajectoryOtherInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgNeuroTrajectoryOtherInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MsgNeuroTrajectoryOtherInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo} MsgNeuroTrajectoryOtherInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgNeuroTrajectoryOtherInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.hasInterference = reader.bool();
                                break;
                            }
                        case 2: {
                                message.countInterference_Blood = reader.int32();
                                break;
                            }
                        case 3: {
                                message.countInterference_Traj = reader.int32();
                                break;
                            }
                        case 4: {
                                if (!(message.idsInterference_Traj && message.idsInterference_Traj.length))
                                    message.idsInterference_Traj = [];
                                message.idsInterference_Traj.push(reader.string());
                                break;
                            }
                        case 5: {
                                if (!(message.elecGroup && message.elecGroup.length))
                                    message.elecGroup = [];
                                message.elecGroup.push($root.UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode.decode(reader, reader.uint32()));
                                break;
                            }
                        case 6: {
                                message.elecDiameter = reader.float();
                                break;
                            }
                        case 7: {
                                message.isElecEnable = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MsgNeuroTrajectoryOtherInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo} MsgNeuroTrajectoryOtherInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgNeuroTrajectoryOtherInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MsgNeuroTrajectoryOtherInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgNeuroTrajectoryOtherInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.hasInterference != null && message.hasOwnProperty("hasInterference"))
                        if (typeof message.hasInterference !== "boolean")
                            return "hasInterference: boolean expected";
                    if (message.countInterference_Blood != null && message.hasOwnProperty("countInterference_Blood"))
                        if (!$util.isInteger(message.countInterference_Blood))
                            return "countInterference_Blood: integer expected";
                    if (message.countInterference_Traj != null && message.hasOwnProperty("countInterference_Traj"))
                        if (!$util.isInteger(message.countInterference_Traj))
                            return "countInterference_Traj: integer expected";
                    if (message.idsInterference_Traj != null && message.hasOwnProperty("idsInterference_Traj")) {
                        if (!Array.isArray(message.idsInterference_Traj))
                            return "idsInterference_Traj: array expected";
                        for (var i = 0; i < message.idsInterference_Traj.length; ++i)
                            if (!$util.isString(message.idsInterference_Traj[i]))
                                return "idsInterference_Traj: string[] expected";
                    }
                    if (message.elecGroup != null && message.hasOwnProperty("elecGroup")) {
                        if (!Array.isArray(message.elecGroup))
                            return "elecGroup: array expected";
                        for (var i = 0; i < message.elecGroup.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode.verify(message.elecGroup[i]);
                            if (error)
                                return "elecGroup." + error;
                        }
                    }
                    if (message.elecDiameter != null && message.hasOwnProperty("elecDiameter"))
                        if (typeof message.elecDiameter !== "number")
                            return "elecDiameter: number expected";
                    if (message.isElecEnable != null && message.hasOwnProperty("isElecEnable"))
                        if (typeof message.isElecEnable !== "boolean")
                            return "isElecEnable: boolean expected";
                    return null;
                };

                /**
                 * Creates a MsgNeuroTrajectoryOtherInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo} MsgNeuroTrajectoryOtherInfo
                 */
                MsgNeuroTrajectoryOtherInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo();
                    if (object.hasInterference != null)
                        message.hasInterference = Boolean(object.hasInterference);
                    if (object.countInterference_Blood != null)
                        message.countInterference_Blood = object.countInterference_Blood | 0;
                    if (object.countInterference_Traj != null)
                        message.countInterference_Traj = object.countInterference_Traj | 0;
                    if (object.idsInterference_Traj) {
                        if (!Array.isArray(object.idsInterference_Traj))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.idsInterference_Traj: array expected");
                        message.idsInterference_Traj = [];
                        for (var i = 0; i < object.idsInterference_Traj.length; ++i)
                            message.idsInterference_Traj[i] = String(object.idsInterference_Traj[i]);
                    }
                    if (object.elecGroup) {
                        if (!Array.isArray(object.elecGroup))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.elecGroup: array expected");
                        message.elecGroup = [];
                        for (var i = 0; i < object.elecGroup.length; ++i) {
                            if (typeof object.elecGroup[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.elecGroup: object expected");
                            message.elecGroup[i] = $root.UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode.fromObject(object.elecGroup[i]);
                        }
                    }
                    if (object.elecDiameter != null)
                        message.elecDiameter = Number(object.elecDiameter);
                    if (object.isElecEnable != null)
                        message.isElecEnable = Boolean(object.isElecEnable);
                    return message;
                };

                /**
                 * Creates a plain object from a MsgNeuroTrajectoryOtherInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo} message MsgNeuroTrajectoryOtherInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgNeuroTrajectoryOtherInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.idsInterference_Traj = [];
                        object.elecGroup = [];
                    }
                    if (options.defaults) {
                        object.hasInterference = false;
                        object.countInterference_Blood = 0;
                        object.countInterference_Traj = 0;
                        object.elecDiameter = 0;
                        object.isElecEnable = false;
                    }
                    if (message.hasInterference != null && message.hasOwnProperty("hasInterference"))
                        object.hasInterference = message.hasInterference;
                    if (message.countInterference_Blood != null && message.hasOwnProperty("countInterference_Blood"))
                        object.countInterference_Blood = message.countInterference_Blood;
                    if (message.countInterference_Traj != null && message.hasOwnProperty("countInterference_Traj"))
                        object.countInterference_Traj = message.countInterference_Traj;
                    if (message.idsInterference_Traj && message.idsInterference_Traj.length) {
                        object.idsInterference_Traj = [];
                        for (var j = 0; j < message.idsInterference_Traj.length; ++j)
                            object.idsInterference_Traj[j] = message.idsInterference_Traj[j];
                    }
                    if (message.elecGroup && message.elecGroup.length) {
                        object.elecGroup = [];
                        for (var j = 0; j < message.elecGroup.length; ++j)
                            object.elecGroup[j] = $root.UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode.toObject(message.elecGroup[j], options);
                    }
                    if (message.elecDiameter != null && message.hasOwnProperty("elecDiameter"))
                        object.elecDiameter = options.json && !isFinite(message.elecDiameter) ? String(message.elecDiameter) : message.elecDiameter;
                    if (message.isElecEnable != null && message.hasOwnProperty("isElecEnable"))
                        object.isElecEnable = message.isElecEnable;
                    return object;
                };

                /**
                 * Converts this MsgNeuroTrajectoryOtherInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgNeuroTrajectoryOtherInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MsgNeuroTrajectoryOtherInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MsgNeuroTrajectoryOtherInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo";
                };

                MsgNeuroTrajectoryOtherInfo.MsgElectrode = (function() {

                    /**
                     * Properties of a MsgElectrode.
                     * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                     * @interface IMsgElectrode
                     * @property {number} elecLength MsgElectrode elecLength
                     * @property {number} elecSpacing MsgElectrode elecSpacing
                     */

                    /**
                     * Constructs a new MsgElectrode.
                     * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo
                     * @classdesc Represents a MsgElectrode.
                     * @implements IMsgElectrode
                     * @constructor
                     * @param {UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.IMsgElectrode=} [properties] Properties to set
                     */
                    function MsgElectrode(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * MsgElectrode elecLength.
                     * @member {number} elecLength
                     * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode
                     * @instance
                     */
                    MsgElectrode.prototype.elecLength = 0;

                    /**
                     * MsgElectrode elecSpacing.
                     * @member {number} elecSpacing
                     * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode
                     * @instance
                     */
                    MsgElectrode.prototype.elecSpacing = 0;

                    /**
                     * Creates a new MsgElectrode instance using the specified properties.
                     * @function create
                     * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode
                     * @static
                     * @param {UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.IMsgElectrode=} [properties] Properties to set
                     * @returns {UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode} MsgElectrode instance
                     */
                    MsgElectrode.create = function create(properties) {
                        return new MsgElectrode(properties);
                    };

                    /**
                     * Encodes the specified MsgElectrode message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode.verify|verify} messages.
                     * @function encode
                     * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode
                     * @static
                     * @param {UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.IMsgElectrode} message MsgElectrode message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MsgElectrode.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.elecLength);
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.elecSpacing);
                        return writer;
                    };

                    /**
                     * Encodes the specified MsgElectrode message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode
                     * @static
                     * @param {UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.IMsgElectrode} message MsgElectrode message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MsgElectrode.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a MsgElectrode message from the specified reader or buffer.
                     * @function decode
                     * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode} MsgElectrode
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MsgElectrode.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.elecLength = reader.float();
                                    break;
                                }
                            case 2: {
                                    message.elecSpacing = reader.float();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        if (!message.hasOwnProperty("elecLength"))
                            throw $util.ProtocolError("missing required 'elecLength'", { instance: message });
                        if (!message.hasOwnProperty("elecSpacing"))
                            throw $util.ProtocolError("missing required 'elecSpacing'", { instance: message });
                        return message;
                    };

                    /**
                     * Decodes a MsgElectrode message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode} MsgElectrode
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MsgElectrode.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a MsgElectrode message.
                     * @function verify
                     * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MsgElectrode.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (typeof message.elecLength !== "number")
                            return "elecLength: number expected";
                        if (typeof message.elecSpacing !== "number")
                            return "elecSpacing: number expected";
                        return null;
                    };

                    /**
                     * Creates a MsgElectrode message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode} MsgElectrode
                     */
                    MsgElectrode.fromObject = function fromObject(object) {
                        if (object instanceof $root.UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode)
                            return object;
                        var message = new $root.UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode();
                        if (object.elecLength != null)
                            message.elecLength = Number(object.elecLength);
                        if (object.elecSpacing != null)
                            message.elecSpacing = Number(object.elecSpacing);
                        return message;
                    };

                    /**
                     * Creates a plain object from a MsgElectrode message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode
                     * @static
                     * @param {UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode} message MsgElectrode
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MsgElectrode.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.elecLength = 0;
                            object.elecSpacing = 0;
                        }
                        if (message.elecLength != null && message.hasOwnProperty("elecLength"))
                            object.elecLength = options.json && !isFinite(message.elecLength) ? String(message.elecLength) : message.elecLength;
                        if (message.elecSpacing != null && message.hasOwnProperty("elecSpacing"))
                            object.elecSpacing = options.json && !isFinite(message.elecSpacing) ? String(message.elecSpacing) : message.elecSpacing;
                        return object;
                    };

                    /**
                     * Converts this MsgElectrode to JSON.
                     * @function toJSON
                     * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MsgElectrode.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for MsgElectrode
                     * @function getTypeUrl
                     * @memberof UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    MsgElectrode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MsgNeuroTrajectoryOtherInfo.MsgElectrode";
                    };

                    return MsgElectrode;
                })();

                return MsgNeuroTrajectoryOtherInfo;
            })();

            ProtoBuf.BoldRegionInfo = (function() {

                /**
                 * Properties of a BoldRegionInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IBoldRegionInfo
                 * @property {number} iIdx BoldRegionInfo iIdx
                 * @property {number|null} [fArea] BoldRegionInfo fArea
                 * @property {number|null} [sActiveType] BoldRegionInfo sActiveType
                 * @property {string|null} [BrainArea] BoldRegionInfo BrainArea
                 * @property {string|null} [BrodmanArea] BoldRegionInfo BrodmanArea
                 * @property {Array.<number>|null} [BrainAreaIdxs] BoldRegionInfo BrainAreaIdxs
                 */

                /**
                 * Constructs a new BoldRegionInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a BoldRegionInfo.
                 * @implements IBoldRegionInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IBoldRegionInfo=} [properties] Properties to set
                 */
                function BoldRegionInfo(properties) {
                    this.BrainAreaIdxs = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BoldRegionInfo iIdx.
                 * @member {number} iIdx
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionInfo
                 * @instance
                 */
                BoldRegionInfo.prototype.iIdx = 0;

                /**
                 * BoldRegionInfo fArea.
                 * @member {number} fArea
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionInfo
                 * @instance
                 */
                BoldRegionInfo.prototype.fArea = 0;

                /**
                 * BoldRegionInfo sActiveType.
                 * @member {number} sActiveType
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionInfo
                 * @instance
                 */
                BoldRegionInfo.prototype.sActiveType = 0;

                /**
                 * BoldRegionInfo BrainArea.
                 * @member {string} BrainArea
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionInfo
                 * @instance
                 */
                BoldRegionInfo.prototype.BrainArea = "";

                /**
                 * BoldRegionInfo BrodmanArea.
                 * @member {string} BrodmanArea
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionInfo
                 * @instance
                 */
                BoldRegionInfo.prototype.BrodmanArea = "";

                /**
                 * BoldRegionInfo BrainAreaIdxs.
                 * @member {Array.<number>} BrainAreaIdxs
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionInfo
                 * @instance
                 */
                BoldRegionInfo.prototype.BrainAreaIdxs = $util.emptyArray;

                /**
                 * Creates a new BoldRegionInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBoldRegionInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.BoldRegionInfo} BoldRegionInfo instance
                 */
                BoldRegionInfo.create = function create(properties) {
                    return new BoldRegionInfo(properties);
                };

                /**
                 * Encodes the specified BoldRegionInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.BoldRegionInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBoldRegionInfo} message BoldRegionInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BoldRegionInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.iIdx);
                    if (message.fArea != null && Object.hasOwnProperty.call(message, "fArea"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.fArea);
                    if (message.sActiveType != null && Object.hasOwnProperty.call(message, "sActiveType"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sActiveType);
                    if (message.BrainArea != null && Object.hasOwnProperty.call(message, "BrainArea"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.BrainArea);
                    if (message.BrodmanArea != null && Object.hasOwnProperty.call(message, "BrodmanArea"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.BrodmanArea);
                    if (message.BrainAreaIdxs != null && message.BrainAreaIdxs.length)
                        for (var i = 0; i < message.BrainAreaIdxs.length; ++i)
                            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.BrainAreaIdxs[i]);
                    return writer;
                };

                /**
                 * Encodes the specified BoldRegionInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.BoldRegionInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBoldRegionInfo} message BoldRegionInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BoldRegionInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BoldRegionInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.BoldRegionInfo} BoldRegionInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BoldRegionInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.BoldRegionInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.iIdx = reader.int32();
                                break;
                            }
                        case 2: {
                                message.fArea = reader.double();
                                break;
                            }
                        case 3: {
                                message.sActiveType = reader.int32();
                                break;
                            }
                        case 4: {
                                message.BrainArea = reader.string();
                                break;
                            }
                        case 5: {
                                message.BrodmanArea = reader.string();
                                break;
                            }
                        case 6: {
                                if (!(message.BrainAreaIdxs && message.BrainAreaIdxs.length))
                                    message.BrainAreaIdxs = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.BrainAreaIdxs.push(reader.int32());
                                } else
                                    message.BrainAreaIdxs.push(reader.int32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("iIdx"))
                        throw $util.ProtocolError("missing required 'iIdx'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a BoldRegionInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.BoldRegionInfo} BoldRegionInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BoldRegionInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BoldRegionInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BoldRegionInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isInteger(message.iIdx))
                        return "iIdx: integer expected";
                    if (message.fArea != null && message.hasOwnProperty("fArea"))
                        if (typeof message.fArea !== "number")
                            return "fArea: number expected";
                    if (message.sActiveType != null && message.hasOwnProperty("sActiveType"))
                        if (!$util.isInteger(message.sActiveType))
                            return "sActiveType: integer expected";
                    if (message.BrainArea != null && message.hasOwnProperty("BrainArea"))
                        if (!$util.isString(message.BrainArea))
                            return "BrainArea: string expected";
                    if (message.BrodmanArea != null && message.hasOwnProperty("BrodmanArea"))
                        if (!$util.isString(message.BrodmanArea))
                            return "BrodmanArea: string expected";
                    if (message.BrainAreaIdxs != null && message.hasOwnProperty("BrainAreaIdxs")) {
                        if (!Array.isArray(message.BrainAreaIdxs))
                            return "BrainAreaIdxs: array expected";
                        for (var i = 0; i < message.BrainAreaIdxs.length; ++i)
                            if (!$util.isInteger(message.BrainAreaIdxs[i]))
                                return "BrainAreaIdxs: integer[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a BoldRegionInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.BoldRegionInfo} BoldRegionInfo
                 */
                BoldRegionInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.BoldRegionInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.BoldRegionInfo();
                    if (object.iIdx != null)
                        message.iIdx = object.iIdx | 0;
                    if (object.fArea != null)
                        message.fArea = Number(object.fArea);
                    if (object.sActiveType != null)
                        message.sActiveType = object.sActiveType | 0;
                    if (object.BrainArea != null)
                        message.BrainArea = String(object.BrainArea);
                    if (object.BrodmanArea != null)
                        message.BrodmanArea = String(object.BrodmanArea);
                    if (object.BrainAreaIdxs) {
                        if (!Array.isArray(object.BrainAreaIdxs))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.BoldRegionInfo.BrainAreaIdxs: array expected");
                        message.BrainAreaIdxs = [];
                        for (var i = 0; i < object.BrainAreaIdxs.length; ++i)
                            message.BrainAreaIdxs[i] = object.BrainAreaIdxs[i] | 0;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a BoldRegionInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.BoldRegionInfo} message BoldRegionInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BoldRegionInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.BrainAreaIdxs = [];
                    if (options.defaults) {
                        object.iIdx = 0;
                        object.fArea = 0;
                        object.sActiveType = 0;
                        object.BrainArea = "";
                        object.BrodmanArea = "";
                    }
                    if (message.iIdx != null && message.hasOwnProperty("iIdx"))
                        object.iIdx = message.iIdx;
                    if (message.fArea != null && message.hasOwnProperty("fArea"))
                        object.fArea = options.json && !isFinite(message.fArea) ? String(message.fArea) : message.fArea;
                    if (message.sActiveType != null && message.hasOwnProperty("sActiveType"))
                        object.sActiveType = message.sActiveType;
                    if (message.BrainArea != null && message.hasOwnProperty("BrainArea"))
                        object.BrainArea = message.BrainArea;
                    if (message.BrodmanArea != null && message.hasOwnProperty("BrodmanArea"))
                        object.BrodmanArea = message.BrodmanArea;
                    if (message.BrainAreaIdxs && message.BrainAreaIdxs.length) {
                        object.BrainAreaIdxs = [];
                        for (var j = 0; j < message.BrainAreaIdxs.length; ++j)
                            object.BrainAreaIdxs[j] = message.BrainAreaIdxs[j];
                    }
                    return object;
                };

                /**
                 * Converts this BoldRegionInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BoldRegionInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for BoldRegionInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                BoldRegionInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.BoldRegionInfo";
                };

                return BoldRegionInfo;
            })();

            ProtoBuf.BoldRegionListInfo = (function() {

                /**
                 * Properties of a BoldRegionListInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IBoldRegionListInfo
                 * @property {string} UID BoldRegionListInfo UID
                 * @property {number} clusterSize BoldRegionListInfo clusterSize
                 * @property {boolean} RegionVisibility BoldRegionListInfo RegionVisibility
                 * @property {number} RegionOpacity BoldRegionListInfo RegionOpacity
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IBoldRegionInfo>|null} [BoldRegion] BoldRegionListInfo BoldRegion
                 */

                /**
                 * Constructs a new BoldRegionListInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a BoldRegionListInfo.
                 * @implements IBoldRegionListInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IBoldRegionListInfo=} [properties] Properties to set
                 */
                function BoldRegionListInfo(properties) {
                    this.BoldRegion = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BoldRegionListInfo UID.
                 * @member {string} UID
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionListInfo
                 * @instance
                 */
                BoldRegionListInfo.prototype.UID = "";

                /**
                 * BoldRegionListInfo clusterSize.
                 * @member {number} clusterSize
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionListInfo
                 * @instance
                 */
                BoldRegionListInfo.prototype.clusterSize = 0;

                /**
                 * BoldRegionListInfo RegionVisibility.
                 * @member {boolean} RegionVisibility
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionListInfo
                 * @instance
                 */
                BoldRegionListInfo.prototype.RegionVisibility = false;

                /**
                 * BoldRegionListInfo RegionOpacity.
                 * @member {number} RegionOpacity
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionListInfo
                 * @instance
                 */
                BoldRegionListInfo.prototype.RegionOpacity = 0;

                /**
                 * BoldRegionListInfo BoldRegion.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IBoldRegionInfo>} BoldRegion
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionListInfo
                 * @instance
                 */
                BoldRegionListInfo.prototype.BoldRegion = $util.emptyArray;

                /**
                 * Creates a new BoldRegionListInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionListInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBoldRegionListInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.BoldRegionListInfo} BoldRegionListInfo instance
                 */
                BoldRegionListInfo.create = function create(properties) {
                    return new BoldRegionListInfo(properties);
                };

                /**
                 * Encodes the specified BoldRegionListInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.BoldRegionListInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionListInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBoldRegionListInfo} message BoldRegionListInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BoldRegionListInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.UID);
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.clusterSize);
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.RegionVisibility);
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.RegionOpacity);
                    if (message.BoldRegion != null && message.BoldRegion.length)
                        for (var i = 0; i < message.BoldRegion.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.BoldRegionInfo.encode(message.BoldRegion[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified BoldRegionListInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.BoldRegionListInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionListInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBoldRegionListInfo} message BoldRegionListInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BoldRegionListInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BoldRegionListInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionListInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.BoldRegionListInfo} BoldRegionListInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BoldRegionListInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.BoldRegionListInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.UID = reader.string();
                                break;
                            }
                        case 2: {
                                message.clusterSize = reader.int32();
                                break;
                            }
                        case 3: {
                                message.RegionVisibility = reader.bool();
                                break;
                            }
                        case 4: {
                                message.RegionOpacity = reader.double();
                                break;
                            }
                        case 5: {
                                if (!(message.BoldRegion && message.BoldRegion.length))
                                    message.BoldRegion = [];
                                message.BoldRegion.push($root.UIBot.UHOR.ProtoBuf.BoldRegionInfo.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("UID"))
                        throw $util.ProtocolError("missing required 'UID'", { instance: message });
                    if (!message.hasOwnProperty("clusterSize"))
                        throw $util.ProtocolError("missing required 'clusterSize'", { instance: message });
                    if (!message.hasOwnProperty("RegionVisibility"))
                        throw $util.ProtocolError("missing required 'RegionVisibility'", { instance: message });
                    if (!message.hasOwnProperty("RegionOpacity"))
                        throw $util.ProtocolError("missing required 'RegionOpacity'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a BoldRegionListInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionListInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.BoldRegionListInfo} BoldRegionListInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BoldRegionListInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BoldRegionListInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionListInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BoldRegionListInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.UID))
                        return "UID: string expected";
                    if (!$util.isInteger(message.clusterSize))
                        return "clusterSize: integer expected";
                    if (typeof message.RegionVisibility !== "boolean")
                        return "RegionVisibility: boolean expected";
                    if (typeof message.RegionOpacity !== "number")
                        return "RegionOpacity: number expected";
                    if (message.BoldRegion != null && message.hasOwnProperty("BoldRegion")) {
                        if (!Array.isArray(message.BoldRegion))
                            return "BoldRegion: array expected";
                        for (var i = 0; i < message.BoldRegion.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.BoldRegionInfo.verify(message.BoldRegion[i]);
                            if (error)
                                return "BoldRegion." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a BoldRegionListInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionListInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.BoldRegionListInfo} BoldRegionListInfo
                 */
                BoldRegionListInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.BoldRegionListInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.BoldRegionListInfo();
                    if (object.UID != null)
                        message.UID = String(object.UID);
                    if (object.clusterSize != null)
                        message.clusterSize = object.clusterSize | 0;
                    if (object.RegionVisibility != null)
                        message.RegionVisibility = Boolean(object.RegionVisibility);
                    if (object.RegionOpacity != null)
                        message.RegionOpacity = Number(object.RegionOpacity);
                    if (object.BoldRegion) {
                        if (!Array.isArray(object.BoldRegion))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.BoldRegionListInfo.BoldRegion: array expected");
                        message.BoldRegion = [];
                        for (var i = 0; i < object.BoldRegion.length; ++i) {
                            if (typeof object.BoldRegion[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.BoldRegionListInfo.BoldRegion: object expected");
                            message.BoldRegion[i] = $root.UIBot.UHOR.ProtoBuf.BoldRegionInfo.fromObject(object.BoldRegion[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a BoldRegionListInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionListInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.BoldRegionListInfo} message BoldRegionListInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BoldRegionListInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.BoldRegion = [];
                    if (options.defaults) {
                        object.UID = "";
                        object.clusterSize = 0;
                        object.RegionVisibility = false;
                        object.RegionOpacity = 0;
                    }
                    if (message.UID != null && message.hasOwnProperty("UID"))
                        object.UID = message.UID;
                    if (message.clusterSize != null && message.hasOwnProperty("clusterSize"))
                        object.clusterSize = message.clusterSize;
                    if (message.RegionVisibility != null && message.hasOwnProperty("RegionVisibility"))
                        object.RegionVisibility = message.RegionVisibility;
                    if (message.RegionOpacity != null && message.hasOwnProperty("RegionOpacity"))
                        object.RegionOpacity = options.json && !isFinite(message.RegionOpacity) ? String(message.RegionOpacity) : message.RegionOpacity;
                    if (message.BoldRegion && message.BoldRegion.length) {
                        object.BoldRegion = [];
                        for (var j = 0; j < message.BoldRegion.length; ++j)
                            object.BoldRegion[j] = $root.UIBot.UHOR.ProtoBuf.BoldRegionInfo.toObject(message.BoldRegion[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this BoldRegionListInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionListInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BoldRegionListInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for BoldRegionListInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.BoldRegionListInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                BoldRegionListInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.BoldRegionListInfo";
                };

                return BoldRegionListInfo;
            })();

            ProtoBuf.MultiBoldRegionInfo = (function() {

                /**
                 * Properties of a MultiBoldRegionInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMultiBoldRegionInfo
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IBoldRegionListInfo>|null} [BoldRegionList] MultiBoldRegionInfo BoldRegionList
                 */

                /**
                 * Constructs a new MultiBoldRegionInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MultiBoldRegionInfo.
                 * @implements IMultiBoldRegionInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMultiBoldRegionInfo=} [properties] Properties to set
                 */
                function MultiBoldRegionInfo(properties) {
                    this.BoldRegionList = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MultiBoldRegionInfo BoldRegionList.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IBoldRegionListInfo>} BoldRegionList
                 * @memberof UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo
                 * @instance
                 */
                MultiBoldRegionInfo.prototype.BoldRegionList = $util.emptyArray;

                /**
                 * Creates a new MultiBoldRegionInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMultiBoldRegionInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo} MultiBoldRegionInfo instance
                 */
                MultiBoldRegionInfo.create = function create(properties) {
                    return new MultiBoldRegionInfo(properties);
                };

                /**
                 * Encodes the specified MultiBoldRegionInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMultiBoldRegionInfo} message MultiBoldRegionInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MultiBoldRegionInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.BoldRegionList != null && message.BoldRegionList.length)
                        for (var i = 0; i < message.BoldRegionList.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.BoldRegionListInfo.encode(message.BoldRegionList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MultiBoldRegionInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMultiBoldRegionInfo} message MultiBoldRegionInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MultiBoldRegionInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MultiBoldRegionInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo} MultiBoldRegionInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MultiBoldRegionInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.BoldRegionList && message.BoldRegionList.length))
                                    message.BoldRegionList = [];
                                message.BoldRegionList.push($root.UIBot.UHOR.ProtoBuf.BoldRegionListInfo.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MultiBoldRegionInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo} MultiBoldRegionInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MultiBoldRegionInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MultiBoldRegionInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MultiBoldRegionInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.BoldRegionList != null && message.hasOwnProperty("BoldRegionList")) {
                        if (!Array.isArray(message.BoldRegionList))
                            return "BoldRegionList: array expected";
                        for (var i = 0; i < message.BoldRegionList.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.BoldRegionListInfo.verify(message.BoldRegionList[i]);
                            if (error)
                                return "BoldRegionList." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MultiBoldRegionInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo} MultiBoldRegionInfo
                 */
                MultiBoldRegionInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo();
                    if (object.BoldRegionList) {
                        if (!Array.isArray(object.BoldRegionList))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo.BoldRegionList: array expected");
                        message.BoldRegionList = [];
                        for (var i = 0; i < object.BoldRegionList.length; ++i) {
                            if (typeof object.BoldRegionList[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo.BoldRegionList: object expected");
                            message.BoldRegionList[i] = $root.UIBot.UHOR.ProtoBuf.BoldRegionListInfo.fromObject(object.BoldRegionList[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MultiBoldRegionInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo} message MultiBoldRegionInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MultiBoldRegionInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.BoldRegionList = [];
                    if (message.BoldRegionList && message.BoldRegionList.length) {
                        object.BoldRegionList = [];
                        for (var j = 0; j < message.BoldRegionList.length; ++j)
                            object.BoldRegionList[j] = $root.UIBot.UHOR.ProtoBuf.BoldRegionListInfo.toObject(message.BoldRegionList[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MultiBoldRegionInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MultiBoldRegionInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MultiBoldRegionInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MultiBoldRegionInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MultiBoldRegionInfo";
                };

                return MultiBoldRegionInfo;
            })();

            ProtoBuf.MsgMaskInfo = (function() {

                /**
                 * Properties of a MsgMaskInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMsgMaskInfo
                 * @property {number|null} [length] MsgMaskInfo length
                 * @property {Array.<number>|null} [DimItem] MsgMaskInfo DimItem
                 * @property {Array.<number>|null} [spacingItem] MsgMaskInfo spacingItem
                 * @property {Array.<number>|null} [imageRowOrientation] MsgMaskInfo imageRowOrientation
                 * @property {Array.<number>|null} [imageColOrientation] MsgMaskInfo imageColOrientation
                 * @property {Array.<number>|null} [sliceOrientation] MsgMaskInfo sliceOrientation
                 * @property {Array.<number>|null} [imageOrigin] MsgMaskInfo imageOrigin
                 * @property {Array.<number>|null} [gradient] MsgMaskInfo gradient
                 * @property {number|null} [intercept] MsgMaskInfo intercept
                 * @property {number|null} [slope] MsgMaskInfo slope
                 * @property {number|null} [fMaxGray] MsgMaskInfo fMaxGray
                 * @property {number|null} [fMinGray] MsgMaskInfo fMinGray
                 * @property {number|null} [windowLevel] MsgMaskInfo windowLevel
                 * @property {number|null} [windowWidth] MsgMaskInfo windowWidth
                 * @property {Uint8Array|null} [data] MsgMaskInfo data
                 */

                /**
                 * Constructs a new MsgMaskInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MsgMaskInfo.
                 * @implements IMsgMaskInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMsgMaskInfo=} [properties] Properties to set
                 */
                function MsgMaskInfo(properties) {
                    this.DimItem = [];
                    this.spacingItem = [];
                    this.imageRowOrientation = [];
                    this.imageColOrientation = [];
                    this.sliceOrientation = [];
                    this.imageOrigin = [];
                    this.gradient = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MsgMaskInfo length.
                 * @member {number} length
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @instance
                 */
                MsgMaskInfo.prototype.length = 0;

                /**
                 * MsgMaskInfo DimItem.
                 * @member {Array.<number>} DimItem
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @instance
                 */
                MsgMaskInfo.prototype.DimItem = $util.emptyArray;

                /**
                 * MsgMaskInfo spacingItem.
                 * @member {Array.<number>} spacingItem
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @instance
                 */
                MsgMaskInfo.prototype.spacingItem = $util.emptyArray;

                /**
                 * MsgMaskInfo imageRowOrientation.
                 * @member {Array.<number>} imageRowOrientation
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @instance
                 */
                MsgMaskInfo.prototype.imageRowOrientation = $util.emptyArray;

                /**
                 * MsgMaskInfo imageColOrientation.
                 * @member {Array.<number>} imageColOrientation
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @instance
                 */
                MsgMaskInfo.prototype.imageColOrientation = $util.emptyArray;

                /**
                 * MsgMaskInfo sliceOrientation.
                 * @member {Array.<number>} sliceOrientation
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @instance
                 */
                MsgMaskInfo.prototype.sliceOrientation = $util.emptyArray;

                /**
                 * MsgMaskInfo imageOrigin.
                 * @member {Array.<number>} imageOrigin
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @instance
                 */
                MsgMaskInfo.prototype.imageOrigin = $util.emptyArray;

                /**
                 * MsgMaskInfo gradient.
                 * @member {Array.<number>} gradient
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @instance
                 */
                MsgMaskInfo.prototype.gradient = $util.emptyArray;

                /**
                 * MsgMaskInfo intercept.
                 * @member {number} intercept
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @instance
                 */
                MsgMaskInfo.prototype.intercept = 0;

                /**
                 * MsgMaskInfo slope.
                 * @member {number} slope
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @instance
                 */
                MsgMaskInfo.prototype.slope = 0;

                /**
                 * MsgMaskInfo fMaxGray.
                 * @member {number} fMaxGray
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @instance
                 */
                MsgMaskInfo.prototype.fMaxGray = 0;

                /**
                 * MsgMaskInfo fMinGray.
                 * @member {number} fMinGray
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @instance
                 */
                MsgMaskInfo.prototype.fMinGray = 0;

                /**
                 * MsgMaskInfo windowLevel.
                 * @member {number} windowLevel
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @instance
                 */
                MsgMaskInfo.prototype.windowLevel = 0;

                /**
                 * MsgMaskInfo windowWidth.
                 * @member {number} windowWidth
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @instance
                 */
                MsgMaskInfo.prototype.windowWidth = 0;

                /**
                 * MsgMaskInfo data.
                 * @member {Uint8Array} data
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @instance
                 */
                MsgMaskInfo.prototype.data = $util.newBuffer([]);

                /**
                 * Creates a new MsgMaskInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgMaskInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MsgMaskInfo} MsgMaskInfo instance
                 */
                MsgMaskInfo.create = function create(properties) {
                    return new MsgMaskInfo(properties);
                };

                /**
                 * Encodes the specified MsgMaskInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgMaskInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgMaskInfo} message MsgMaskInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgMaskInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.length);
                    if (message.DimItem != null && message.DimItem.length)
                        for (var i = 0; i < message.DimItem.length; ++i)
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.DimItem[i]);
                    if (message.spacingItem != null && message.spacingItem.length)
                        for (var i = 0; i < message.spacingItem.length; ++i)
                            writer.uint32(/* id 3, wireType 1 =*/25).double(message.spacingItem[i]);
                    if (message.imageRowOrientation != null && message.imageRowOrientation.length)
                        for (var i = 0; i < message.imageRowOrientation.length; ++i)
                            writer.uint32(/* id 4, wireType 1 =*/33).double(message.imageRowOrientation[i]);
                    if (message.imageColOrientation != null && message.imageColOrientation.length)
                        for (var i = 0; i < message.imageColOrientation.length; ++i)
                            writer.uint32(/* id 5, wireType 1 =*/41).double(message.imageColOrientation[i]);
                    if (message.sliceOrientation != null && message.sliceOrientation.length)
                        for (var i = 0; i < message.sliceOrientation.length; ++i)
                            writer.uint32(/* id 6, wireType 1 =*/49).double(message.sliceOrientation[i]);
                    if (message.imageOrigin != null && message.imageOrigin.length)
                        for (var i = 0; i < message.imageOrigin.length; ++i)
                            writer.uint32(/* id 7, wireType 1 =*/57).double(message.imageOrigin[i]);
                    if (message.gradient != null && message.gradient.length)
                        for (var i = 0; i < message.gradient.length; ++i)
                            writer.uint32(/* id 8, wireType 1 =*/65).double(message.gradient[i]);
                    if (message.intercept != null && Object.hasOwnProperty.call(message, "intercept"))
                        writer.uint32(/* id 9, wireType 1 =*/73).double(message.intercept);
                    if (message.slope != null && Object.hasOwnProperty.call(message, "slope"))
                        writer.uint32(/* id 10, wireType 1 =*/81).double(message.slope);
                    if (message.fMaxGray != null && Object.hasOwnProperty.call(message, "fMaxGray"))
                        writer.uint32(/* id 11, wireType 5 =*/93).float(message.fMaxGray);
                    if (message.fMinGray != null && Object.hasOwnProperty.call(message, "fMinGray"))
                        writer.uint32(/* id 12, wireType 5 =*/101).float(message.fMinGray);
                    if (message.windowLevel != null && Object.hasOwnProperty.call(message, "windowLevel"))
                        writer.uint32(/* id 13, wireType 1 =*/105).double(message.windowLevel);
                    if (message.windowWidth != null && Object.hasOwnProperty.call(message, "windowWidth"))
                        writer.uint32(/* id 14, wireType 1 =*/113).double(message.windowWidth);
                    if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                        writer.uint32(/* id 15, wireType 2 =*/122).bytes(message.data);
                    return writer;
                };

                /**
                 * Encodes the specified MsgMaskInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgMaskInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgMaskInfo} message MsgMaskInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgMaskInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MsgMaskInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MsgMaskInfo} MsgMaskInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgMaskInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MsgMaskInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.length = reader.int32();
                                break;
                            }
                        case 2: {
                                if (!(message.DimItem && message.DimItem.length))
                                    message.DimItem = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.DimItem.push(reader.int32());
                                } else
                                    message.DimItem.push(reader.int32());
                                break;
                            }
                        case 3: {
                                if (!(message.spacingItem && message.spacingItem.length))
                                    message.spacingItem = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.spacingItem.push(reader.double());
                                } else
                                    message.spacingItem.push(reader.double());
                                break;
                            }
                        case 4: {
                                if (!(message.imageRowOrientation && message.imageRowOrientation.length))
                                    message.imageRowOrientation = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.imageRowOrientation.push(reader.double());
                                } else
                                    message.imageRowOrientation.push(reader.double());
                                break;
                            }
                        case 5: {
                                if (!(message.imageColOrientation && message.imageColOrientation.length))
                                    message.imageColOrientation = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.imageColOrientation.push(reader.double());
                                } else
                                    message.imageColOrientation.push(reader.double());
                                break;
                            }
                        case 6: {
                                if (!(message.sliceOrientation && message.sliceOrientation.length))
                                    message.sliceOrientation = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.sliceOrientation.push(reader.double());
                                } else
                                    message.sliceOrientation.push(reader.double());
                                break;
                            }
                        case 7: {
                                if (!(message.imageOrigin && message.imageOrigin.length))
                                    message.imageOrigin = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.imageOrigin.push(reader.double());
                                } else
                                    message.imageOrigin.push(reader.double());
                                break;
                            }
                        case 8: {
                                if (!(message.gradient && message.gradient.length))
                                    message.gradient = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.gradient.push(reader.double());
                                } else
                                    message.gradient.push(reader.double());
                                break;
                            }
                        case 9: {
                                message.intercept = reader.double();
                                break;
                            }
                        case 10: {
                                message.slope = reader.double();
                                break;
                            }
                        case 11: {
                                message.fMaxGray = reader.float();
                                break;
                            }
                        case 12: {
                                message.fMinGray = reader.float();
                                break;
                            }
                        case 13: {
                                message.windowLevel = reader.double();
                                break;
                            }
                        case 14: {
                                message.windowWidth = reader.double();
                                break;
                            }
                        case 15: {
                                message.data = reader.bytes();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MsgMaskInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MsgMaskInfo} MsgMaskInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgMaskInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MsgMaskInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgMaskInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.length != null && message.hasOwnProperty("length"))
                        if (!$util.isInteger(message.length))
                            return "length: integer expected";
                    if (message.DimItem != null && message.hasOwnProperty("DimItem")) {
                        if (!Array.isArray(message.DimItem))
                            return "DimItem: array expected";
                        for (var i = 0; i < message.DimItem.length; ++i)
                            if (!$util.isInteger(message.DimItem[i]))
                                return "DimItem: integer[] expected";
                    }
                    if (message.spacingItem != null && message.hasOwnProperty("spacingItem")) {
                        if (!Array.isArray(message.spacingItem))
                            return "spacingItem: array expected";
                        for (var i = 0; i < message.spacingItem.length; ++i)
                            if (typeof message.spacingItem[i] !== "number")
                                return "spacingItem: number[] expected";
                    }
                    if (message.imageRowOrientation != null && message.hasOwnProperty("imageRowOrientation")) {
                        if (!Array.isArray(message.imageRowOrientation))
                            return "imageRowOrientation: array expected";
                        for (var i = 0; i < message.imageRowOrientation.length; ++i)
                            if (typeof message.imageRowOrientation[i] !== "number")
                                return "imageRowOrientation: number[] expected";
                    }
                    if (message.imageColOrientation != null && message.hasOwnProperty("imageColOrientation")) {
                        if (!Array.isArray(message.imageColOrientation))
                            return "imageColOrientation: array expected";
                        for (var i = 0; i < message.imageColOrientation.length; ++i)
                            if (typeof message.imageColOrientation[i] !== "number")
                                return "imageColOrientation: number[] expected";
                    }
                    if (message.sliceOrientation != null && message.hasOwnProperty("sliceOrientation")) {
                        if (!Array.isArray(message.sliceOrientation))
                            return "sliceOrientation: array expected";
                        for (var i = 0; i < message.sliceOrientation.length; ++i)
                            if (typeof message.sliceOrientation[i] !== "number")
                                return "sliceOrientation: number[] expected";
                    }
                    if (message.imageOrigin != null && message.hasOwnProperty("imageOrigin")) {
                        if (!Array.isArray(message.imageOrigin))
                            return "imageOrigin: array expected";
                        for (var i = 0; i < message.imageOrigin.length; ++i)
                            if (typeof message.imageOrigin[i] !== "number")
                                return "imageOrigin: number[] expected";
                    }
                    if (message.gradient != null && message.hasOwnProperty("gradient")) {
                        if (!Array.isArray(message.gradient))
                            return "gradient: array expected";
                        for (var i = 0; i < message.gradient.length; ++i)
                            if (typeof message.gradient[i] !== "number")
                                return "gradient: number[] expected";
                    }
                    if (message.intercept != null && message.hasOwnProperty("intercept"))
                        if (typeof message.intercept !== "number")
                            return "intercept: number expected";
                    if (message.slope != null && message.hasOwnProperty("slope"))
                        if (typeof message.slope !== "number")
                            return "slope: number expected";
                    if (message.fMaxGray != null && message.hasOwnProperty("fMaxGray"))
                        if (typeof message.fMaxGray !== "number")
                            return "fMaxGray: number expected";
                    if (message.fMinGray != null && message.hasOwnProperty("fMinGray"))
                        if (typeof message.fMinGray !== "number")
                            return "fMinGray: number expected";
                    if (message.windowLevel != null && message.hasOwnProperty("windowLevel"))
                        if (typeof message.windowLevel !== "number")
                            return "windowLevel: number expected";
                    if (message.windowWidth != null && message.hasOwnProperty("windowWidth"))
                        if (typeof message.windowWidth !== "number")
                            return "windowWidth: number expected";
                    if (message.data != null && message.hasOwnProperty("data"))
                        if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                            return "data: buffer expected";
                    return null;
                };

                /**
                 * Creates a MsgMaskInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MsgMaskInfo} MsgMaskInfo
                 */
                MsgMaskInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MsgMaskInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MsgMaskInfo();
                    if (object.length != null)
                        message.length = object.length | 0;
                    if (object.DimItem) {
                        if (!Array.isArray(object.DimItem))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgMaskInfo.DimItem: array expected");
                        message.DimItem = [];
                        for (var i = 0; i < object.DimItem.length; ++i)
                            message.DimItem[i] = object.DimItem[i] | 0;
                    }
                    if (object.spacingItem) {
                        if (!Array.isArray(object.spacingItem))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgMaskInfo.spacingItem: array expected");
                        message.spacingItem = [];
                        for (var i = 0; i < object.spacingItem.length; ++i)
                            message.spacingItem[i] = Number(object.spacingItem[i]);
                    }
                    if (object.imageRowOrientation) {
                        if (!Array.isArray(object.imageRowOrientation))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgMaskInfo.imageRowOrientation: array expected");
                        message.imageRowOrientation = [];
                        for (var i = 0; i < object.imageRowOrientation.length; ++i)
                            message.imageRowOrientation[i] = Number(object.imageRowOrientation[i]);
                    }
                    if (object.imageColOrientation) {
                        if (!Array.isArray(object.imageColOrientation))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgMaskInfo.imageColOrientation: array expected");
                        message.imageColOrientation = [];
                        for (var i = 0; i < object.imageColOrientation.length; ++i)
                            message.imageColOrientation[i] = Number(object.imageColOrientation[i]);
                    }
                    if (object.sliceOrientation) {
                        if (!Array.isArray(object.sliceOrientation))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgMaskInfo.sliceOrientation: array expected");
                        message.sliceOrientation = [];
                        for (var i = 0; i < object.sliceOrientation.length; ++i)
                            message.sliceOrientation[i] = Number(object.sliceOrientation[i]);
                    }
                    if (object.imageOrigin) {
                        if (!Array.isArray(object.imageOrigin))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgMaskInfo.imageOrigin: array expected");
                        message.imageOrigin = [];
                        for (var i = 0; i < object.imageOrigin.length; ++i)
                            message.imageOrigin[i] = Number(object.imageOrigin[i]);
                    }
                    if (object.gradient) {
                        if (!Array.isArray(object.gradient))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgMaskInfo.gradient: array expected");
                        message.gradient = [];
                        for (var i = 0; i < object.gradient.length; ++i)
                            message.gradient[i] = Number(object.gradient[i]);
                    }
                    if (object.intercept != null)
                        message.intercept = Number(object.intercept);
                    if (object.slope != null)
                        message.slope = Number(object.slope);
                    if (object.fMaxGray != null)
                        message.fMaxGray = Number(object.fMaxGray);
                    if (object.fMinGray != null)
                        message.fMinGray = Number(object.fMinGray);
                    if (object.windowLevel != null)
                        message.windowLevel = Number(object.windowLevel);
                    if (object.windowWidth != null)
                        message.windowWidth = Number(object.windowWidth);
                    if (object.data != null)
                        if (typeof object.data === "string")
                            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                        else if (object.data.length >= 0)
                            message.data = object.data;
                    return message;
                };

                /**
                 * Creates a plain object from a MsgMaskInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MsgMaskInfo} message MsgMaskInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgMaskInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.DimItem = [];
                        object.spacingItem = [];
                        object.imageRowOrientation = [];
                        object.imageColOrientation = [];
                        object.sliceOrientation = [];
                        object.imageOrigin = [];
                        object.gradient = [];
                    }
                    if (options.defaults) {
                        object.length = 0;
                        object.intercept = 0;
                        object.slope = 0;
                        object.fMaxGray = 0;
                        object.fMinGray = 0;
                        object.windowLevel = 0;
                        object.windowWidth = 0;
                        if (options.bytes === String)
                            object.data = "";
                        else {
                            object.data = [];
                            if (options.bytes !== Array)
                                object.data = $util.newBuffer(object.data);
                        }
                    }
                    if (message.length != null && message.hasOwnProperty("length"))
                        object.length = message.length;
                    if (message.DimItem && message.DimItem.length) {
                        object.DimItem = [];
                        for (var j = 0; j < message.DimItem.length; ++j)
                            object.DimItem[j] = message.DimItem[j];
                    }
                    if (message.spacingItem && message.spacingItem.length) {
                        object.spacingItem = [];
                        for (var j = 0; j < message.spacingItem.length; ++j)
                            object.spacingItem[j] = options.json && !isFinite(message.spacingItem[j]) ? String(message.spacingItem[j]) : message.spacingItem[j];
                    }
                    if (message.imageRowOrientation && message.imageRowOrientation.length) {
                        object.imageRowOrientation = [];
                        for (var j = 0; j < message.imageRowOrientation.length; ++j)
                            object.imageRowOrientation[j] = options.json && !isFinite(message.imageRowOrientation[j]) ? String(message.imageRowOrientation[j]) : message.imageRowOrientation[j];
                    }
                    if (message.imageColOrientation && message.imageColOrientation.length) {
                        object.imageColOrientation = [];
                        for (var j = 0; j < message.imageColOrientation.length; ++j)
                            object.imageColOrientation[j] = options.json && !isFinite(message.imageColOrientation[j]) ? String(message.imageColOrientation[j]) : message.imageColOrientation[j];
                    }
                    if (message.sliceOrientation && message.sliceOrientation.length) {
                        object.sliceOrientation = [];
                        for (var j = 0; j < message.sliceOrientation.length; ++j)
                            object.sliceOrientation[j] = options.json && !isFinite(message.sliceOrientation[j]) ? String(message.sliceOrientation[j]) : message.sliceOrientation[j];
                    }
                    if (message.imageOrigin && message.imageOrigin.length) {
                        object.imageOrigin = [];
                        for (var j = 0; j < message.imageOrigin.length; ++j)
                            object.imageOrigin[j] = options.json && !isFinite(message.imageOrigin[j]) ? String(message.imageOrigin[j]) : message.imageOrigin[j];
                    }
                    if (message.gradient && message.gradient.length) {
                        object.gradient = [];
                        for (var j = 0; j < message.gradient.length; ++j)
                            object.gradient[j] = options.json && !isFinite(message.gradient[j]) ? String(message.gradient[j]) : message.gradient[j];
                    }
                    if (message.intercept != null && message.hasOwnProperty("intercept"))
                        object.intercept = options.json && !isFinite(message.intercept) ? String(message.intercept) : message.intercept;
                    if (message.slope != null && message.hasOwnProperty("slope"))
                        object.slope = options.json && !isFinite(message.slope) ? String(message.slope) : message.slope;
                    if (message.fMaxGray != null && message.hasOwnProperty("fMaxGray"))
                        object.fMaxGray = options.json && !isFinite(message.fMaxGray) ? String(message.fMaxGray) : message.fMaxGray;
                    if (message.fMinGray != null && message.hasOwnProperty("fMinGray"))
                        object.fMinGray = options.json && !isFinite(message.fMinGray) ? String(message.fMinGray) : message.fMinGray;
                    if (message.windowLevel != null && message.hasOwnProperty("windowLevel"))
                        object.windowLevel = options.json && !isFinite(message.windowLevel) ? String(message.windowLevel) : message.windowLevel;
                    if (message.windowWidth != null && message.hasOwnProperty("windowWidth"))
                        object.windowWidth = options.json && !isFinite(message.windowWidth) ? String(message.windowWidth) : message.windowWidth;
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                    return object;
                };

                /**
                 * Converts this MsgMaskInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgMaskInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MsgMaskInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MsgMaskInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MsgMaskInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MsgMaskInfo";
                };

                return MsgMaskInfo;
            })();

            ProtoBuf.ElectrodeInfo = (function() {

                /**
                 * Properties of an ElectrodeInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IElectrodeInfo
                 * @property {number} contactNum ElectrodeInfo contactNum
                 * @property {number} contactLength ElectrodeInfo contactLength
                 * @property {number} contactDistance ElectrodeInfo contactDistance
                 * @property {number} contactDiameter ElectrodeInfo contactDiameter
                 * @property {number} contactTipDistance ElectrodeInfo contactTipDistance
                 * @property {boolean} isShow ElectrodeInfo isShow
                 * @property {number} infoIndex ElectrodeInfo infoIndex
                 * @property {number} trajectoryID ElectrodeInfo trajectoryID
                 */

                /**
                 * Constructs a new ElectrodeInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents an ElectrodeInfo.
                 * @implements IElectrodeInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IElectrodeInfo=} [properties] Properties to set
                 */
                function ElectrodeInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ElectrodeInfo contactNum.
                 * @member {number} contactNum
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfo
                 * @instance
                 */
                ElectrodeInfo.prototype.contactNum = 0;

                /**
                 * ElectrodeInfo contactLength.
                 * @member {number} contactLength
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfo
                 * @instance
                 */
                ElectrodeInfo.prototype.contactLength = 0;

                /**
                 * ElectrodeInfo contactDistance.
                 * @member {number} contactDistance
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfo
                 * @instance
                 */
                ElectrodeInfo.prototype.contactDistance = 0;

                /**
                 * ElectrodeInfo contactDiameter.
                 * @member {number} contactDiameter
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfo
                 * @instance
                 */
                ElectrodeInfo.prototype.contactDiameter = 0;

                /**
                 * ElectrodeInfo contactTipDistance.
                 * @member {number} contactTipDistance
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfo
                 * @instance
                 */
                ElectrodeInfo.prototype.contactTipDistance = 0;

                /**
                 * ElectrodeInfo isShow.
                 * @member {boolean} isShow
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfo
                 * @instance
                 */
                ElectrodeInfo.prototype.isShow = false;

                /**
                 * ElectrodeInfo infoIndex.
                 * @member {number} infoIndex
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfo
                 * @instance
                 */
                ElectrodeInfo.prototype.infoIndex = 0;

                /**
                 * ElectrodeInfo trajectoryID.
                 * @member {number} trajectoryID
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfo
                 * @instance
                 */
                ElectrodeInfo.prototype.trajectoryID = 0;

                /**
                 * Creates a new ElectrodeInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IElectrodeInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.ElectrodeInfo} ElectrodeInfo instance
                 */
                ElectrodeInfo.create = function create(properties) {
                    return new ElectrodeInfo(properties);
                };

                /**
                 * Encodes the specified ElectrodeInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ElectrodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IElectrodeInfo} message ElectrodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ElectrodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.contactNum);
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.contactLength);
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.contactDistance);
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.contactDiameter);
                    writer.uint32(/* id 5, wireType 1 =*/41).double(message.contactTipDistance);
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isShow);
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.infoIndex);
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.trajectoryID);
                    return writer;
                };

                /**
                 * Encodes the specified ElectrodeInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ElectrodeInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IElectrodeInfo} message ElectrodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ElectrodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ElectrodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.ElectrodeInfo} ElectrodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ElectrodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.ElectrodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.contactNum = reader.int32();
                                break;
                            }
                        case 2: {
                                message.contactLength = reader.double();
                                break;
                            }
                        case 3: {
                                message.contactDistance = reader.double();
                                break;
                            }
                        case 4: {
                                message.contactDiameter = reader.double();
                                break;
                            }
                        case 5: {
                                message.contactTipDistance = reader.double();
                                break;
                            }
                        case 6: {
                                message.isShow = reader.bool();
                                break;
                            }
                        case 7: {
                                message.infoIndex = reader.int32();
                                break;
                            }
                        case 8: {
                                message.trajectoryID = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("contactNum"))
                        throw $util.ProtocolError("missing required 'contactNum'", { instance: message });
                    if (!message.hasOwnProperty("contactLength"))
                        throw $util.ProtocolError("missing required 'contactLength'", { instance: message });
                    if (!message.hasOwnProperty("contactDistance"))
                        throw $util.ProtocolError("missing required 'contactDistance'", { instance: message });
                    if (!message.hasOwnProperty("contactDiameter"))
                        throw $util.ProtocolError("missing required 'contactDiameter'", { instance: message });
                    if (!message.hasOwnProperty("contactTipDistance"))
                        throw $util.ProtocolError("missing required 'contactTipDistance'", { instance: message });
                    if (!message.hasOwnProperty("isShow"))
                        throw $util.ProtocolError("missing required 'isShow'", { instance: message });
                    if (!message.hasOwnProperty("infoIndex"))
                        throw $util.ProtocolError("missing required 'infoIndex'", { instance: message });
                    if (!message.hasOwnProperty("trajectoryID"))
                        throw $util.ProtocolError("missing required 'trajectoryID'", { instance: message });
                    return message;
                };

                /**
                 * Decodes an ElectrodeInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.ElectrodeInfo} ElectrodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ElectrodeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ElectrodeInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ElectrodeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isInteger(message.contactNum))
                        return "contactNum: integer expected";
                    if (typeof message.contactLength !== "number")
                        return "contactLength: number expected";
                    if (typeof message.contactDistance !== "number")
                        return "contactDistance: number expected";
                    if (typeof message.contactDiameter !== "number")
                        return "contactDiameter: number expected";
                    if (typeof message.contactTipDistance !== "number")
                        return "contactTipDistance: number expected";
                    if (typeof message.isShow !== "boolean")
                        return "isShow: boolean expected";
                    if (!$util.isInteger(message.infoIndex))
                        return "infoIndex: integer expected";
                    if (!$util.isInteger(message.trajectoryID))
                        return "trajectoryID: integer expected";
                    return null;
                };

                /**
                 * Creates an ElectrodeInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.ElectrodeInfo} ElectrodeInfo
                 */
                ElectrodeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.ElectrodeInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.ElectrodeInfo();
                    if (object.contactNum != null)
                        message.contactNum = object.contactNum | 0;
                    if (object.contactLength != null)
                        message.contactLength = Number(object.contactLength);
                    if (object.contactDistance != null)
                        message.contactDistance = Number(object.contactDistance);
                    if (object.contactDiameter != null)
                        message.contactDiameter = Number(object.contactDiameter);
                    if (object.contactTipDistance != null)
                        message.contactTipDistance = Number(object.contactTipDistance);
                    if (object.isShow != null)
                        message.isShow = Boolean(object.isShow);
                    if (object.infoIndex != null)
                        message.infoIndex = object.infoIndex | 0;
                    if (object.trajectoryID != null)
                        message.trajectoryID = object.trajectoryID | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an ElectrodeInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ElectrodeInfo} message ElectrodeInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ElectrodeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.contactNum = 0;
                        object.contactLength = 0;
                        object.contactDistance = 0;
                        object.contactDiameter = 0;
                        object.contactTipDistance = 0;
                        object.isShow = false;
                        object.infoIndex = 0;
                        object.trajectoryID = 0;
                    }
                    if (message.contactNum != null && message.hasOwnProperty("contactNum"))
                        object.contactNum = message.contactNum;
                    if (message.contactLength != null && message.hasOwnProperty("contactLength"))
                        object.contactLength = options.json && !isFinite(message.contactLength) ? String(message.contactLength) : message.contactLength;
                    if (message.contactDistance != null && message.hasOwnProperty("contactDistance"))
                        object.contactDistance = options.json && !isFinite(message.contactDistance) ? String(message.contactDistance) : message.contactDistance;
                    if (message.contactDiameter != null && message.hasOwnProperty("contactDiameter"))
                        object.contactDiameter = options.json && !isFinite(message.contactDiameter) ? String(message.contactDiameter) : message.contactDiameter;
                    if (message.contactTipDistance != null && message.hasOwnProperty("contactTipDistance"))
                        object.contactTipDistance = options.json && !isFinite(message.contactTipDistance) ? String(message.contactTipDistance) : message.contactTipDistance;
                    if (message.isShow != null && message.hasOwnProperty("isShow"))
                        object.isShow = message.isShow;
                    if (message.infoIndex != null && message.hasOwnProperty("infoIndex"))
                        object.infoIndex = message.infoIndex;
                    if (message.trajectoryID != null && message.hasOwnProperty("trajectoryID"))
                        object.trajectoryID = message.trajectoryID;
                    return object;
                };

                /**
                 * Converts this ElectrodeInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ElectrodeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ElectrodeInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ElectrodeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.ElectrodeInfo";
                };

                return ElectrodeInfo;
            })();

            ProtoBuf.ElectrodeInfos = (function() {

                /**
                 * Properties of an ElectrodeInfos.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IElectrodeInfos
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IElectrodeInfo>|null} [AllElectrodeInfos] ElectrodeInfos AllElectrodeInfos
                 */

                /**
                 * Constructs a new ElectrodeInfos.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents an ElectrodeInfos.
                 * @implements IElectrodeInfos
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IElectrodeInfos=} [properties] Properties to set
                 */
                function ElectrodeInfos(properties) {
                    this.AllElectrodeInfos = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ElectrodeInfos AllElectrodeInfos.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IElectrodeInfo>} AllElectrodeInfos
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfos
                 * @instance
                 */
                ElectrodeInfos.prototype.AllElectrodeInfos = $util.emptyArray;

                /**
                 * Creates a new ElectrodeInfos instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfos
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IElectrodeInfos=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.ElectrodeInfos} ElectrodeInfos instance
                 */
                ElectrodeInfos.create = function create(properties) {
                    return new ElectrodeInfos(properties);
                };

                /**
                 * Encodes the specified ElectrodeInfos message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ElectrodeInfos.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfos
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IElectrodeInfos} message ElectrodeInfos message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ElectrodeInfos.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.AllElectrodeInfos != null && message.AllElectrodeInfos.length)
                        for (var i = 0; i < message.AllElectrodeInfos.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.ElectrodeInfo.encode(message.AllElectrodeInfos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ElectrodeInfos message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ElectrodeInfos.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfos
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IElectrodeInfos} message ElectrodeInfos message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ElectrodeInfos.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ElectrodeInfos message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfos
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.ElectrodeInfos} ElectrodeInfos
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ElectrodeInfos.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.ElectrodeInfos();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.AllElectrodeInfos && message.AllElectrodeInfos.length))
                                    message.AllElectrodeInfos = [];
                                message.AllElectrodeInfos.push($root.UIBot.UHOR.ProtoBuf.ElectrodeInfo.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ElectrodeInfos message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfos
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.ElectrodeInfos} ElectrodeInfos
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ElectrodeInfos.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ElectrodeInfos message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfos
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ElectrodeInfos.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.AllElectrodeInfos != null && message.hasOwnProperty("AllElectrodeInfos")) {
                        if (!Array.isArray(message.AllElectrodeInfos))
                            return "AllElectrodeInfos: array expected";
                        for (var i = 0; i < message.AllElectrodeInfos.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.ElectrodeInfo.verify(message.AllElectrodeInfos[i]);
                            if (error)
                                return "AllElectrodeInfos." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an ElectrodeInfos message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfos
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.ElectrodeInfos} ElectrodeInfos
                 */
                ElectrodeInfos.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.ElectrodeInfos)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.ElectrodeInfos();
                    if (object.AllElectrodeInfos) {
                        if (!Array.isArray(object.AllElectrodeInfos))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.ElectrodeInfos.AllElectrodeInfos: array expected");
                        message.AllElectrodeInfos = [];
                        for (var i = 0; i < object.AllElectrodeInfos.length; ++i) {
                            if (typeof object.AllElectrodeInfos[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.ElectrodeInfos.AllElectrodeInfos: object expected");
                            message.AllElectrodeInfos[i] = $root.UIBot.UHOR.ProtoBuf.ElectrodeInfo.fromObject(object.AllElectrodeInfos[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ElectrodeInfos message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfos
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ElectrodeInfos} message ElectrodeInfos
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ElectrodeInfos.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.AllElectrodeInfos = [];
                    if (message.AllElectrodeInfos && message.AllElectrodeInfos.length) {
                        object.AllElectrodeInfos = [];
                        for (var j = 0; j < message.AllElectrodeInfos.length; ++j)
                            object.AllElectrodeInfos[j] = $root.UIBot.UHOR.ProtoBuf.ElectrodeInfo.toObject(message.AllElectrodeInfos[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ElectrodeInfos to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfos
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ElectrodeInfos.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ElectrodeInfos
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeInfos
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ElectrodeInfos.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.ElectrodeInfos";
                };

                return ElectrodeInfos;
            })();

            ProtoBuf.ElectrodeEndPointCoordinate = (function() {

                /**
                 * Properties of an ElectrodeEndPointCoordinate.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IElectrodeEndPointCoordinate
                 * @property {number} x ElectrodeEndPointCoordinate x
                 * @property {number} y ElectrodeEndPointCoordinate y
                 * @property {number} z ElectrodeEndPointCoordinate z
                 */

                /**
                 * Constructs a new ElectrodeEndPointCoordinate.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents an ElectrodeEndPointCoordinate.
                 * @implements IElectrodeEndPointCoordinate
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IElectrodeEndPointCoordinate=} [properties] Properties to set
                 */
                function ElectrodeEndPointCoordinate(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ElectrodeEndPointCoordinate x.
                 * @member {number} x
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate
                 * @instance
                 */
                ElectrodeEndPointCoordinate.prototype.x = 0;

                /**
                 * ElectrodeEndPointCoordinate y.
                 * @member {number} y
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate
                 * @instance
                 */
                ElectrodeEndPointCoordinate.prototype.y = 0;

                /**
                 * ElectrodeEndPointCoordinate z.
                 * @member {number} z
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate
                 * @instance
                 */
                ElectrodeEndPointCoordinate.prototype.z = 0;

                /**
                 * Creates a new ElectrodeEndPointCoordinate instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IElectrodeEndPointCoordinate=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate} ElectrodeEndPointCoordinate instance
                 */
                ElectrodeEndPointCoordinate.create = function create(properties) {
                    return new ElectrodeEndPointCoordinate(properties);
                };

                /**
                 * Encodes the specified ElectrodeEndPointCoordinate message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IElectrodeEndPointCoordinate} message ElectrodeEndPointCoordinate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ElectrodeEndPointCoordinate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.x);
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.y);
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.z);
                    return writer;
                };

                /**
                 * Encodes the specified ElectrodeEndPointCoordinate message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IElectrodeEndPointCoordinate} message ElectrodeEndPointCoordinate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ElectrodeEndPointCoordinate.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ElectrodeEndPointCoordinate message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate} ElectrodeEndPointCoordinate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ElectrodeEndPointCoordinate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.x = reader.double();
                                break;
                            }
                        case 2: {
                                message.y = reader.double();
                                break;
                            }
                        case 3: {
                                message.z = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("x"))
                        throw $util.ProtocolError("missing required 'x'", { instance: message });
                    if (!message.hasOwnProperty("y"))
                        throw $util.ProtocolError("missing required 'y'", { instance: message });
                    if (!message.hasOwnProperty("z"))
                        throw $util.ProtocolError("missing required 'z'", { instance: message });
                    return message;
                };

                /**
                 * Decodes an ElectrodeEndPointCoordinate message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate} ElectrodeEndPointCoordinate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ElectrodeEndPointCoordinate.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ElectrodeEndPointCoordinate message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ElectrodeEndPointCoordinate.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (typeof message.x !== "number")
                        return "x: number expected";
                    if (typeof message.y !== "number")
                        return "y: number expected";
                    if (typeof message.z !== "number")
                        return "z: number expected";
                    return null;
                };

                /**
                 * Creates an ElectrodeEndPointCoordinate message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate} ElectrodeEndPointCoordinate
                 */
                ElectrodeEndPointCoordinate.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate();
                    if (object.x != null)
                        message.x = Number(object.x);
                    if (object.y != null)
                        message.y = Number(object.y);
                    if (object.z != null)
                        message.z = Number(object.z);
                    return message;
                };

                /**
                 * Creates a plain object from an ElectrodeEndPointCoordinate message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate} message ElectrodeEndPointCoordinate
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ElectrodeEndPointCoordinate.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.x = 0;
                        object.y = 0;
                        object.z = 0;
                    }
                    if (message.x != null && message.hasOwnProperty("x"))
                        object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
                    if (message.y != null && message.hasOwnProperty("y"))
                        object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
                    if (message.z != null && message.hasOwnProperty("z"))
                        object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
                    return object;
                };

                /**
                 * Converts this ElectrodeEndPointCoordinate to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ElectrodeEndPointCoordinate.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ElectrodeEndPointCoordinate
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ElectrodeEndPointCoordinate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate";
                };

                return ElectrodeEndPointCoordinate;
            })();

            ProtoBuf.ElectrodeETCoordinate = (function() {

                /**
                 * Properties of an ElectrodeETCoordinate.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IElectrodeETCoordinate
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IElectrodeEndPointCoordinate>|null} [ETPoints] ElectrodeETCoordinate ETPoints
                 * @property {number} ConfigIndexInfo ElectrodeETCoordinate ConfigIndexInfo
                 * @property {number} trajectoryID ElectrodeETCoordinate trajectoryID
                 */

                /**
                 * Constructs a new ElectrodeETCoordinate.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents an ElectrodeETCoordinate.
                 * @implements IElectrodeETCoordinate
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IElectrodeETCoordinate=} [properties] Properties to set
                 */
                function ElectrodeETCoordinate(properties) {
                    this.ETPoints = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ElectrodeETCoordinate ETPoints.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IElectrodeEndPointCoordinate>} ETPoints
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate
                 * @instance
                 */
                ElectrodeETCoordinate.prototype.ETPoints = $util.emptyArray;

                /**
                 * ElectrodeETCoordinate ConfigIndexInfo.
                 * @member {number} ConfigIndexInfo
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate
                 * @instance
                 */
                ElectrodeETCoordinate.prototype.ConfigIndexInfo = 0;

                /**
                 * ElectrodeETCoordinate trajectoryID.
                 * @member {number} trajectoryID
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate
                 * @instance
                 */
                ElectrodeETCoordinate.prototype.trajectoryID = 0;

                /**
                 * Creates a new ElectrodeETCoordinate instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IElectrodeETCoordinate=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate} ElectrodeETCoordinate instance
                 */
                ElectrodeETCoordinate.create = function create(properties) {
                    return new ElectrodeETCoordinate(properties);
                };

                /**
                 * Encodes the specified ElectrodeETCoordinate message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IElectrodeETCoordinate} message ElectrodeETCoordinate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ElectrodeETCoordinate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ETPoints != null && message.ETPoints.length)
                        for (var i = 0; i < message.ETPoints.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate.encode(message.ETPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ConfigIndexInfo);
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.trajectoryID);
                    return writer;
                };

                /**
                 * Encodes the specified ElectrodeETCoordinate message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IElectrodeETCoordinate} message ElectrodeETCoordinate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ElectrodeETCoordinate.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ElectrodeETCoordinate message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate} ElectrodeETCoordinate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ElectrodeETCoordinate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.ETPoints && message.ETPoints.length))
                                    message.ETPoints = [];
                                message.ETPoints.push($root.UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate.decode(reader, reader.uint32()));
                                break;
                            }
                        case 2: {
                                message.ConfigIndexInfo = reader.int32();
                                break;
                            }
                        case 3: {
                                message.trajectoryID = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("ConfigIndexInfo"))
                        throw $util.ProtocolError("missing required 'ConfigIndexInfo'", { instance: message });
                    if (!message.hasOwnProperty("trajectoryID"))
                        throw $util.ProtocolError("missing required 'trajectoryID'", { instance: message });
                    return message;
                };

                /**
                 * Decodes an ElectrodeETCoordinate message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate} ElectrodeETCoordinate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ElectrodeETCoordinate.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ElectrodeETCoordinate message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ElectrodeETCoordinate.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ETPoints != null && message.hasOwnProperty("ETPoints")) {
                        if (!Array.isArray(message.ETPoints))
                            return "ETPoints: array expected";
                        for (var i = 0; i < message.ETPoints.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate.verify(message.ETPoints[i]);
                            if (error)
                                return "ETPoints." + error;
                        }
                    }
                    if (!$util.isInteger(message.ConfigIndexInfo))
                        return "ConfigIndexInfo: integer expected";
                    if (!$util.isInteger(message.trajectoryID))
                        return "trajectoryID: integer expected";
                    return null;
                };

                /**
                 * Creates an ElectrodeETCoordinate message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate} ElectrodeETCoordinate
                 */
                ElectrodeETCoordinate.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate();
                    if (object.ETPoints) {
                        if (!Array.isArray(object.ETPoints))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate.ETPoints: array expected");
                        message.ETPoints = [];
                        for (var i = 0; i < object.ETPoints.length; ++i) {
                            if (typeof object.ETPoints[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate.ETPoints: object expected");
                            message.ETPoints[i] = $root.UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate.fromObject(object.ETPoints[i]);
                        }
                    }
                    if (object.ConfigIndexInfo != null)
                        message.ConfigIndexInfo = object.ConfigIndexInfo | 0;
                    if (object.trajectoryID != null)
                        message.trajectoryID = object.trajectoryID | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an ElectrodeETCoordinate message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate} message ElectrodeETCoordinate
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ElectrodeETCoordinate.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.ETPoints = [];
                    if (options.defaults) {
                        object.ConfigIndexInfo = 0;
                        object.trajectoryID = 0;
                    }
                    if (message.ETPoints && message.ETPoints.length) {
                        object.ETPoints = [];
                        for (var j = 0; j < message.ETPoints.length; ++j)
                            object.ETPoints[j] = $root.UIBot.UHOR.ProtoBuf.ElectrodeEndPointCoordinate.toObject(message.ETPoints[j], options);
                    }
                    if (message.ConfigIndexInfo != null && message.hasOwnProperty("ConfigIndexInfo"))
                        object.ConfigIndexInfo = message.ConfigIndexInfo;
                    if (message.trajectoryID != null && message.hasOwnProperty("trajectoryID"))
                        object.trajectoryID = message.trajectoryID;
                    return object;
                };

                /**
                 * Converts this ElectrodeETCoordinate to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ElectrodeETCoordinate.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ElectrodeETCoordinate
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ElectrodeETCoordinate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.ElectrodeETCoordinate";
                };

                return ElectrodeETCoordinate;
            })();

            ProtoBuf.MsgSRRegInfo = (function() {

                /**
                 * Properties of a MsgSRRegInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMsgSRRegInfo
                 * @property {string|null} [refSeriesuid] MsgSRRegInfo refSeriesuid
                 * @property {string|null} [floatSeriesuid] MsgSRRegInfo floatSeriesuid
                 * @property {Array.<number>|null} [matrixItem] MsgSRRegInfo matrixItem
                 */

                /**
                 * Constructs a new MsgSRRegInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MsgSRRegInfo.
                 * @implements IMsgSRRegInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMsgSRRegInfo=} [properties] Properties to set
                 */
                function MsgSRRegInfo(properties) {
                    this.matrixItem = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MsgSRRegInfo refSeriesuid.
                 * @member {string} refSeriesuid
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSRRegInfo
                 * @instance
                 */
                MsgSRRegInfo.prototype.refSeriesuid = "";

                /**
                 * MsgSRRegInfo floatSeriesuid.
                 * @member {string} floatSeriesuid
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSRRegInfo
                 * @instance
                 */
                MsgSRRegInfo.prototype.floatSeriesuid = "";

                /**
                 * MsgSRRegInfo matrixItem.
                 * @member {Array.<number>} matrixItem
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSRRegInfo
                 * @instance
                 */
                MsgSRRegInfo.prototype.matrixItem = $util.emptyArray;

                /**
                 * Creates a new MsgSRRegInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSRRegInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgSRRegInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MsgSRRegInfo} MsgSRRegInfo instance
                 */
                MsgSRRegInfo.create = function create(properties) {
                    return new MsgSRRegInfo(properties);
                };

                /**
                 * Encodes the specified MsgSRRegInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgSRRegInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSRRegInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgSRRegInfo} message MsgSRRegInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgSRRegInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.refSeriesuid != null && Object.hasOwnProperty.call(message, "refSeriesuid"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.refSeriesuid);
                    if (message.floatSeriesuid != null && Object.hasOwnProperty.call(message, "floatSeriesuid"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.floatSeriesuid);
                    if (message.matrixItem != null && message.matrixItem.length)
                        for (var i = 0; i < message.matrixItem.length; ++i)
                            writer.uint32(/* id 3, wireType 1 =*/25).double(message.matrixItem[i]);
                    return writer;
                };

                /**
                 * Encodes the specified MsgSRRegInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgSRRegInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSRRegInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgSRRegInfo} message MsgSRRegInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgSRRegInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MsgSRRegInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSRRegInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MsgSRRegInfo} MsgSRRegInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgSRRegInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MsgSRRegInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.refSeriesuid = reader.string();
                                break;
                            }
                        case 2: {
                                message.floatSeriesuid = reader.string();
                                break;
                            }
                        case 3: {
                                if (!(message.matrixItem && message.matrixItem.length))
                                    message.matrixItem = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.matrixItem.push(reader.double());
                                } else
                                    message.matrixItem.push(reader.double());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MsgSRRegInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSRRegInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MsgSRRegInfo} MsgSRRegInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgSRRegInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MsgSRRegInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSRRegInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgSRRegInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.refSeriesuid != null && message.hasOwnProperty("refSeriesuid"))
                        if (!$util.isString(message.refSeriesuid))
                            return "refSeriesuid: string expected";
                    if (message.floatSeriesuid != null && message.hasOwnProperty("floatSeriesuid"))
                        if (!$util.isString(message.floatSeriesuid))
                            return "floatSeriesuid: string expected";
                    if (message.matrixItem != null && message.hasOwnProperty("matrixItem")) {
                        if (!Array.isArray(message.matrixItem))
                            return "matrixItem: array expected";
                        for (var i = 0; i < message.matrixItem.length; ++i)
                            if (typeof message.matrixItem[i] !== "number")
                                return "matrixItem: number[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a MsgSRRegInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSRRegInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MsgSRRegInfo} MsgSRRegInfo
                 */
                MsgSRRegInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MsgSRRegInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MsgSRRegInfo();
                    if (object.refSeriesuid != null)
                        message.refSeriesuid = String(object.refSeriesuid);
                    if (object.floatSeriesuid != null)
                        message.floatSeriesuid = String(object.floatSeriesuid);
                    if (object.matrixItem) {
                        if (!Array.isArray(object.matrixItem))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgSRRegInfo.matrixItem: array expected");
                        message.matrixItem = [];
                        for (var i = 0; i < object.matrixItem.length; ++i)
                            message.matrixItem[i] = Number(object.matrixItem[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MsgSRRegInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSRRegInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MsgSRRegInfo} message MsgSRRegInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgSRRegInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.matrixItem = [];
                    if (options.defaults) {
                        object.refSeriesuid = "";
                        object.floatSeriesuid = "";
                    }
                    if (message.refSeriesuid != null && message.hasOwnProperty("refSeriesuid"))
                        object.refSeriesuid = message.refSeriesuid;
                    if (message.floatSeriesuid != null && message.hasOwnProperty("floatSeriesuid"))
                        object.floatSeriesuid = message.floatSeriesuid;
                    if (message.matrixItem && message.matrixItem.length) {
                        object.matrixItem = [];
                        for (var j = 0; j < message.matrixItem.length; ++j)
                            object.matrixItem[j] = options.json && !isFinite(message.matrixItem[j]) ? String(message.matrixItem[j]) : message.matrixItem[j];
                    }
                    return object;
                };

                /**
                 * Converts this MsgSRRegInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSRRegInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgSRRegInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MsgSRRegInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MsgSRRegInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MsgSRRegInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MsgSRRegInfo";
                };

                return MsgSRRegInfo;
            })();

            ProtoBuf.PseudoColorInfo = (function() {

                /**
                 * Properties of a PseudoColorInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IPseudoColorInfo
                 * @property {string|null} [BoldUID] PseudoColorInfo BoldUID
                 * @property {string|null} [ActivatePseudoName] PseudoColorInfo ActivatePseudoName
                 * @property {string|null} [NegativePseudoName] PseudoColorInfo NegativePseudoName
                 * @property {string|null} [Ext] PseudoColorInfo Ext
                 */

                /**
                 * Constructs a new PseudoColorInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a PseudoColorInfo.
                 * @implements IPseudoColorInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IPseudoColorInfo=} [properties] Properties to set
                 */
                function PseudoColorInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PseudoColorInfo BoldUID.
                 * @member {string} BoldUID
                 * @memberof UIBot.UHOR.ProtoBuf.PseudoColorInfo
                 * @instance
                 */
                PseudoColorInfo.prototype.BoldUID = "";

                /**
                 * PseudoColorInfo ActivatePseudoName.
                 * @member {string} ActivatePseudoName
                 * @memberof UIBot.UHOR.ProtoBuf.PseudoColorInfo
                 * @instance
                 */
                PseudoColorInfo.prototype.ActivatePseudoName = "";

                /**
                 * PseudoColorInfo NegativePseudoName.
                 * @member {string} NegativePseudoName
                 * @memberof UIBot.UHOR.ProtoBuf.PseudoColorInfo
                 * @instance
                 */
                PseudoColorInfo.prototype.NegativePseudoName = "";

                /**
                 * PseudoColorInfo Ext.
                 * @member {string} Ext
                 * @memberof UIBot.UHOR.ProtoBuf.PseudoColorInfo
                 * @instance
                 */
                PseudoColorInfo.prototype.Ext = "";

                /**
                 * Creates a new PseudoColorInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.PseudoColorInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IPseudoColorInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.PseudoColorInfo} PseudoColorInfo instance
                 */
                PseudoColorInfo.create = function create(properties) {
                    return new PseudoColorInfo(properties);
                };

                /**
                 * Encodes the specified PseudoColorInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.PseudoColorInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.PseudoColorInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IPseudoColorInfo} message PseudoColorInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PseudoColorInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.BoldUID != null && Object.hasOwnProperty.call(message, "BoldUID"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.BoldUID);
                    if (message.ActivatePseudoName != null && Object.hasOwnProperty.call(message, "ActivatePseudoName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.ActivatePseudoName);
                    if (message.NegativePseudoName != null && Object.hasOwnProperty.call(message, "NegativePseudoName"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.NegativePseudoName);
                    if (message.Ext != null && Object.hasOwnProperty.call(message, "Ext"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.Ext);
                    return writer;
                };

                /**
                 * Encodes the specified PseudoColorInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.PseudoColorInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.PseudoColorInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IPseudoColorInfo} message PseudoColorInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PseudoColorInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PseudoColorInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.PseudoColorInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.PseudoColorInfo} PseudoColorInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PseudoColorInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.PseudoColorInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.BoldUID = reader.string();
                                break;
                            }
                        case 2: {
                                message.ActivatePseudoName = reader.string();
                                break;
                            }
                        case 3: {
                                message.NegativePseudoName = reader.string();
                                break;
                            }
                        case 4: {
                                message.Ext = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PseudoColorInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.PseudoColorInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.PseudoColorInfo} PseudoColorInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PseudoColorInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PseudoColorInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.PseudoColorInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PseudoColorInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.BoldUID != null && message.hasOwnProperty("BoldUID"))
                        if (!$util.isString(message.BoldUID))
                            return "BoldUID: string expected";
                    if (message.ActivatePseudoName != null && message.hasOwnProperty("ActivatePseudoName"))
                        if (!$util.isString(message.ActivatePseudoName))
                            return "ActivatePseudoName: string expected";
                    if (message.NegativePseudoName != null && message.hasOwnProperty("NegativePseudoName"))
                        if (!$util.isString(message.NegativePseudoName))
                            return "NegativePseudoName: string expected";
                    if (message.Ext != null && message.hasOwnProperty("Ext"))
                        if (!$util.isString(message.Ext))
                            return "Ext: string expected";
                    return null;
                };

                /**
                 * Creates a PseudoColorInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.PseudoColorInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.PseudoColorInfo} PseudoColorInfo
                 */
                PseudoColorInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.PseudoColorInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.PseudoColorInfo();
                    if (object.BoldUID != null)
                        message.BoldUID = String(object.BoldUID);
                    if (object.ActivatePseudoName != null)
                        message.ActivatePseudoName = String(object.ActivatePseudoName);
                    if (object.NegativePseudoName != null)
                        message.NegativePseudoName = String(object.NegativePseudoName);
                    if (object.Ext != null)
                        message.Ext = String(object.Ext);
                    return message;
                };

                /**
                 * Creates a plain object from a PseudoColorInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.PseudoColorInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.PseudoColorInfo} message PseudoColorInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PseudoColorInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.BoldUID = "";
                        object.ActivatePseudoName = "";
                        object.NegativePseudoName = "";
                        object.Ext = "";
                    }
                    if (message.BoldUID != null && message.hasOwnProperty("BoldUID"))
                        object.BoldUID = message.BoldUID;
                    if (message.ActivatePseudoName != null && message.hasOwnProperty("ActivatePseudoName"))
                        object.ActivatePseudoName = message.ActivatePseudoName;
                    if (message.NegativePseudoName != null && message.hasOwnProperty("NegativePseudoName"))
                        object.NegativePseudoName = message.NegativePseudoName;
                    if (message.Ext != null && message.hasOwnProperty("Ext"))
                        object.Ext = message.Ext;
                    return object;
                };

                /**
                 * Converts this PseudoColorInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.PseudoColorInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PseudoColorInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PseudoColorInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.PseudoColorInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PseudoColorInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.PseudoColorInfo";
                };

                return PseudoColorInfo;
            })();

            ProtoBuf.ExportBoldRegionListInfo = (function() {

                /**
                 * Properties of an ExportBoldRegionListInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IExportBoldRegionListInfo
                 * @property {string|null} [UID] ExportBoldRegionListInfo UID
                 * @property {string|null} [PseudoColorType] ExportBoldRegionListInfo PseudoColorType
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IBoldRegionInfo>|null} [BoldRegion] ExportBoldRegionListInfo BoldRegion
                 * @property {string|null} [UserID] ExportBoldRegionListInfo UserID
                 */

                /**
                 * Constructs a new ExportBoldRegionListInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents an ExportBoldRegionListInfo.
                 * @implements IExportBoldRegionListInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IExportBoldRegionListInfo=} [properties] Properties to set
                 */
                function ExportBoldRegionListInfo(properties) {
                    this.BoldRegion = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExportBoldRegionListInfo UID.
                 * @member {string} UID
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo
                 * @instance
                 */
                ExportBoldRegionListInfo.prototype.UID = "";

                /**
                 * ExportBoldRegionListInfo PseudoColorType.
                 * @member {string} PseudoColorType
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo
                 * @instance
                 */
                ExportBoldRegionListInfo.prototype.PseudoColorType = "";

                /**
                 * ExportBoldRegionListInfo BoldRegion.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IBoldRegionInfo>} BoldRegion
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo
                 * @instance
                 */
                ExportBoldRegionListInfo.prototype.BoldRegion = $util.emptyArray;

                /**
                 * ExportBoldRegionListInfo UserID.
                 * @member {string} UserID
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo
                 * @instance
                 */
                ExportBoldRegionListInfo.prototype.UserID = "";

                /**
                 * Creates a new ExportBoldRegionListInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IExportBoldRegionListInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo} ExportBoldRegionListInfo instance
                 */
                ExportBoldRegionListInfo.create = function create(properties) {
                    return new ExportBoldRegionListInfo(properties);
                };

                /**
                 * Encodes the specified ExportBoldRegionListInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IExportBoldRegionListInfo} message ExportBoldRegionListInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExportBoldRegionListInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.UID != null && Object.hasOwnProperty.call(message, "UID"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.UID);
                    if (message.PseudoColorType != null && Object.hasOwnProperty.call(message, "PseudoColorType"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.PseudoColorType);
                    if (message.BoldRegion != null && message.BoldRegion.length)
                        for (var i = 0; i < message.BoldRegion.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.BoldRegionInfo.encode(message.BoldRegion[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.UserID != null && Object.hasOwnProperty.call(message, "UserID"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.UserID);
                    return writer;
                };

                /**
                 * Encodes the specified ExportBoldRegionListInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IExportBoldRegionListInfo} message ExportBoldRegionListInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExportBoldRegionListInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExportBoldRegionListInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo} ExportBoldRegionListInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExportBoldRegionListInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.UID = reader.string();
                                break;
                            }
                        case 2: {
                                message.PseudoColorType = reader.string();
                                break;
                            }
                        case 3: {
                                if (!(message.BoldRegion && message.BoldRegion.length))
                                    message.BoldRegion = [];
                                message.BoldRegion.push($root.UIBot.UHOR.ProtoBuf.BoldRegionInfo.decode(reader, reader.uint32()));
                                break;
                            }
                        case 4: {
                                message.UserID = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExportBoldRegionListInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo} ExportBoldRegionListInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExportBoldRegionListInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExportBoldRegionListInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExportBoldRegionListInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.UID != null && message.hasOwnProperty("UID"))
                        if (!$util.isString(message.UID))
                            return "UID: string expected";
                    if (message.PseudoColorType != null && message.hasOwnProperty("PseudoColorType"))
                        if (!$util.isString(message.PseudoColorType))
                            return "PseudoColorType: string expected";
                    if (message.BoldRegion != null && message.hasOwnProperty("BoldRegion")) {
                        if (!Array.isArray(message.BoldRegion))
                            return "BoldRegion: array expected";
                        for (var i = 0; i < message.BoldRegion.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.BoldRegionInfo.verify(message.BoldRegion[i]);
                            if (error)
                                return "BoldRegion." + error;
                        }
                    }
                    if (message.UserID != null && message.hasOwnProperty("UserID"))
                        if (!$util.isString(message.UserID))
                            return "UserID: string expected";
                    return null;
                };

                /**
                 * Creates an ExportBoldRegionListInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo} ExportBoldRegionListInfo
                 */
                ExportBoldRegionListInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo();
                    if (object.UID != null)
                        message.UID = String(object.UID);
                    if (object.PseudoColorType != null)
                        message.PseudoColorType = String(object.PseudoColorType);
                    if (object.BoldRegion) {
                        if (!Array.isArray(object.BoldRegion))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo.BoldRegion: array expected");
                        message.BoldRegion = [];
                        for (var i = 0; i < object.BoldRegion.length; ++i) {
                            if (typeof object.BoldRegion[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo.BoldRegion: object expected");
                            message.BoldRegion[i] = $root.UIBot.UHOR.ProtoBuf.BoldRegionInfo.fromObject(object.BoldRegion[i]);
                        }
                    }
                    if (object.UserID != null)
                        message.UserID = String(object.UserID);
                    return message;
                };

                /**
                 * Creates a plain object from an ExportBoldRegionListInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo} message ExportBoldRegionListInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExportBoldRegionListInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.BoldRegion = [];
                    if (options.defaults) {
                        object.UID = "";
                        object.PseudoColorType = "";
                        object.UserID = "";
                    }
                    if (message.UID != null && message.hasOwnProperty("UID"))
                        object.UID = message.UID;
                    if (message.PseudoColorType != null && message.hasOwnProperty("PseudoColorType"))
                        object.PseudoColorType = message.PseudoColorType;
                    if (message.BoldRegion && message.BoldRegion.length) {
                        object.BoldRegion = [];
                        for (var j = 0; j < message.BoldRegion.length; ++j)
                            object.BoldRegion[j] = $root.UIBot.UHOR.ProtoBuf.BoldRegionInfo.toObject(message.BoldRegion[j], options);
                    }
                    if (message.UserID != null && message.hasOwnProperty("UserID"))
                        object.UserID = message.UserID;
                    return object;
                };

                /**
                 * Converts this ExportBoldRegionListInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExportBoldRegionListInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ExportBoldRegionListInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ExportBoldRegionListInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.ExportBoldRegionListInfo";
                };

                return ExportBoldRegionListInfo;
            })();

            ProtoBuf.ExportBoldRegionResultInfo = (function() {

                /**
                 * Properties of an ExportBoldRegionResultInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IExportBoldRegionResultInfo
                 * @property {string|null} [UID] ExportBoldRegionResultInfo UID
                 * @property {string|null} [refSeriesuid] ExportBoldRegionResultInfo refSeriesuid
                 * @property {UIBot.UHOR.ProtoBuf.IPseudoColorInfo|null} [pseudoColorInfo] ExportBoldRegionResultInfo pseudoColorInfo
                 * @property {UIBot.UHOR.ProtoBuf.IMsgMaskInfo|null} [BoldRegionResult] ExportBoldRegionResultInfo BoldRegionResult
                 * @property {UIBot.UHOR.ProtoBuf.IMsgMaskInfo|null} [BoldRegionMask] ExportBoldRegionResultInfo BoldRegionMask
                 * @property {UIBot.UHOR.ProtoBuf.IMsgSRRegInfo|null} [regInfo] ExportBoldRegionResultInfo regInfo
                 * @property {Array.<number>|null} [ActiveBoldRegionLabels] ExportBoldRegionResultInfo ActiveBoldRegionLabels
                 * @property {Array.<string>|null} [ActiveBoldRegionLabelsFullName] ExportBoldRegionResultInfo ActiveBoldRegionLabelsFullName
                 * @property {UIBot.UHOR.ProtoBuf.IMsgMaskInfo|null} [BoldRegionForeignMask] ExportBoldRegionResultInfo BoldRegionForeignMask
                 * @property {UIBot.UHOR.ProtoBuf.IBoldThreshold|null} [BoldThreshold] ExportBoldRegionResultInfo BoldThreshold
                 */

                /**
                 * Constructs a new ExportBoldRegionResultInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents an ExportBoldRegionResultInfo.
                 * @implements IExportBoldRegionResultInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IExportBoldRegionResultInfo=} [properties] Properties to set
                 */
                function ExportBoldRegionResultInfo(properties) {
                    this.ActiveBoldRegionLabels = [];
                    this.ActiveBoldRegionLabelsFullName = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExportBoldRegionResultInfo UID.
                 * @member {string} UID
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @instance
                 */
                ExportBoldRegionResultInfo.prototype.UID = "";

                /**
                 * ExportBoldRegionResultInfo refSeriesuid.
                 * @member {string} refSeriesuid
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @instance
                 */
                ExportBoldRegionResultInfo.prototype.refSeriesuid = "";

                /**
                 * ExportBoldRegionResultInfo pseudoColorInfo.
                 * @member {UIBot.UHOR.ProtoBuf.IPseudoColorInfo|null|undefined} pseudoColorInfo
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @instance
                 */
                ExportBoldRegionResultInfo.prototype.pseudoColorInfo = null;

                /**
                 * ExportBoldRegionResultInfo BoldRegionResult.
                 * @member {UIBot.UHOR.ProtoBuf.IMsgMaskInfo|null|undefined} BoldRegionResult
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @instance
                 */
                ExportBoldRegionResultInfo.prototype.BoldRegionResult = null;

                /**
                 * ExportBoldRegionResultInfo BoldRegionMask.
                 * @member {UIBot.UHOR.ProtoBuf.IMsgMaskInfo|null|undefined} BoldRegionMask
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @instance
                 */
                ExportBoldRegionResultInfo.prototype.BoldRegionMask = null;

                /**
                 * ExportBoldRegionResultInfo regInfo.
                 * @member {UIBot.UHOR.ProtoBuf.IMsgSRRegInfo|null|undefined} regInfo
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @instance
                 */
                ExportBoldRegionResultInfo.prototype.regInfo = null;

                /**
                 * ExportBoldRegionResultInfo ActiveBoldRegionLabels.
                 * @member {Array.<number>} ActiveBoldRegionLabels
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @instance
                 */
                ExportBoldRegionResultInfo.prototype.ActiveBoldRegionLabels = $util.emptyArray;

                /**
                 * ExportBoldRegionResultInfo ActiveBoldRegionLabelsFullName.
                 * @member {Array.<string>} ActiveBoldRegionLabelsFullName
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @instance
                 */
                ExportBoldRegionResultInfo.prototype.ActiveBoldRegionLabelsFullName = $util.emptyArray;

                /**
                 * ExportBoldRegionResultInfo BoldRegionForeignMask.
                 * @member {UIBot.UHOR.ProtoBuf.IMsgMaskInfo|null|undefined} BoldRegionForeignMask
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @instance
                 */
                ExportBoldRegionResultInfo.prototype.BoldRegionForeignMask = null;

                /**
                 * ExportBoldRegionResultInfo BoldThreshold.
                 * @member {UIBot.UHOR.ProtoBuf.IBoldThreshold|null|undefined} BoldThreshold
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @instance
                 */
                ExportBoldRegionResultInfo.prototype.BoldThreshold = null;

                /**
                 * Creates a new ExportBoldRegionResultInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IExportBoldRegionResultInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo} ExportBoldRegionResultInfo instance
                 */
                ExportBoldRegionResultInfo.create = function create(properties) {
                    return new ExportBoldRegionResultInfo(properties);
                };

                /**
                 * Encodes the specified ExportBoldRegionResultInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IExportBoldRegionResultInfo} message ExportBoldRegionResultInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExportBoldRegionResultInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.UID != null && Object.hasOwnProperty.call(message, "UID"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.UID);
                    if (message.refSeriesuid != null && Object.hasOwnProperty.call(message, "refSeriesuid"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.refSeriesuid);
                    if (message.pseudoColorInfo != null && Object.hasOwnProperty.call(message, "pseudoColorInfo"))
                        $root.UIBot.UHOR.ProtoBuf.PseudoColorInfo.encode(message.pseudoColorInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.BoldRegionResult != null && Object.hasOwnProperty.call(message, "BoldRegionResult"))
                        $root.UIBot.UHOR.ProtoBuf.MsgMaskInfo.encode(message.BoldRegionResult, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.BoldRegionMask != null && Object.hasOwnProperty.call(message, "BoldRegionMask"))
                        $root.UIBot.UHOR.ProtoBuf.MsgMaskInfo.encode(message.BoldRegionMask, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.regInfo != null && Object.hasOwnProperty.call(message, "regInfo"))
                        $root.UIBot.UHOR.ProtoBuf.MsgSRRegInfo.encode(message.regInfo, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.ActiveBoldRegionLabels != null && message.ActiveBoldRegionLabels.length)
                        for (var i = 0; i < message.ActiveBoldRegionLabels.length; ++i)
                            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.ActiveBoldRegionLabels[i]);
                    if (message.ActiveBoldRegionLabelsFullName != null && message.ActiveBoldRegionLabelsFullName.length)
                        for (var i = 0; i < message.ActiveBoldRegionLabelsFullName.length; ++i)
                            writer.uint32(/* id 8, wireType 2 =*/66).string(message.ActiveBoldRegionLabelsFullName[i]);
                    if (message.BoldRegionForeignMask != null && Object.hasOwnProperty.call(message, "BoldRegionForeignMask"))
                        $root.UIBot.UHOR.ProtoBuf.MsgMaskInfo.encode(message.BoldRegionForeignMask, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.BoldThreshold != null && Object.hasOwnProperty.call(message, "BoldThreshold"))
                        $root.UIBot.UHOR.ProtoBuf.BoldThreshold.encode(message.BoldThreshold, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ExportBoldRegionResultInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IExportBoldRegionResultInfo} message ExportBoldRegionResultInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExportBoldRegionResultInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExportBoldRegionResultInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo} ExportBoldRegionResultInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExportBoldRegionResultInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.UID = reader.string();
                                break;
                            }
                        case 2: {
                                message.refSeriesuid = reader.string();
                                break;
                            }
                        case 3: {
                                message.pseudoColorInfo = $root.UIBot.UHOR.ProtoBuf.PseudoColorInfo.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.BoldRegionResult = $root.UIBot.UHOR.ProtoBuf.MsgMaskInfo.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.BoldRegionMask = $root.UIBot.UHOR.ProtoBuf.MsgMaskInfo.decode(reader, reader.uint32());
                                break;
                            }
                        case 6: {
                                message.regInfo = $root.UIBot.UHOR.ProtoBuf.MsgSRRegInfo.decode(reader, reader.uint32());
                                break;
                            }
                        case 7: {
                                if (!(message.ActiveBoldRegionLabels && message.ActiveBoldRegionLabels.length))
                                    message.ActiveBoldRegionLabels = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.ActiveBoldRegionLabels.push(reader.int32());
                                } else
                                    message.ActiveBoldRegionLabels.push(reader.int32());
                                break;
                            }
                        case 8: {
                                if (!(message.ActiveBoldRegionLabelsFullName && message.ActiveBoldRegionLabelsFullName.length))
                                    message.ActiveBoldRegionLabelsFullName = [];
                                message.ActiveBoldRegionLabelsFullName.push(reader.string());
                                break;
                            }
                        case 9: {
                                message.BoldRegionForeignMask = $root.UIBot.UHOR.ProtoBuf.MsgMaskInfo.decode(reader, reader.uint32());
                                break;
                            }
                        case 10: {
                                message.BoldThreshold = $root.UIBot.UHOR.ProtoBuf.BoldThreshold.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExportBoldRegionResultInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo} ExportBoldRegionResultInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExportBoldRegionResultInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExportBoldRegionResultInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExportBoldRegionResultInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.UID != null && message.hasOwnProperty("UID"))
                        if (!$util.isString(message.UID))
                            return "UID: string expected";
                    if (message.refSeriesuid != null && message.hasOwnProperty("refSeriesuid"))
                        if (!$util.isString(message.refSeriesuid))
                            return "refSeriesuid: string expected";
                    if (message.pseudoColorInfo != null && message.hasOwnProperty("pseudoColorInfo")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.PseudoColorInfo.verify(message.pseudoColorInfo);
                        if (error)
                            return "pseudoColorInfo." + error;
                    }
                    if (message.BoldRegionResult != null && message.hasOwnProperty("BoldRegionResult")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.MsgMaskInfo.verify(message.BoldRegionResult);
                        if (error)
                            return "BoldRegionResult." + error;
                    }
                    if (message.BoldRegionMask != null && message.hasOwnProperty("BoldRegionMask")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.MsgMaskInfo.verify(message.BoldRegionMask);
                        if (error)
                            return "BoldRegionMask." + error;
                    }
                    if (message.regInfo != null && message.hasOwnProperty("regInfo")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.MsgSRRegInfo.verify(message.regInfo);
                        if (error)
                            return "regInfo." + error;
                    }
                    if (message.ActiveBoldRegionLabels != null && message.hasOwnProperty("ActiveBoldRegionLabels")) {
                        if (!Array.isArray(message.ActiveBoldRegionLabels))
                            return "ActiveBoldRegionLabels: array expected";
                        for (var i = 0; i < message.ActiveBoldRegionLabels.length; ++i)
                            if (!$util.isInteger(message.ActiveBoldRegionLabels[i]))
                                return "ActiveBoldRegionLabels: integer[] expected";
                    }
                    if (message.ActiveBoldRegionLabelsFullName != null && message.hasOwnProperty("ActiveBoldRegionLabelsFullName")) {
                        if (!Array.isArray(message.ActiveBoldRegionLabelsFullName))
                            return "ActiveBoldRegionLabelsFullName: array expected";
                        for (var i = 0; i < message.ActiveBoldRegionLabelsFullName.length; ++i)
                            if (!$util.isString(message.ActiveBoldRegionLabelsFullName[i]))
                                return "ActiveBoldRegionLabelsFullName: string[] expected";
                    }
                    if (message.BoldRegionForeignMask != null && message.hasOwnProperty("BoldRegionForeignMask")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.MsgMaskInfo.verify(message.BoldRegionForeignMask);
                        if (error)
                            return "BoldRegionForeignMask." + error;
                    }
                    if (message.BoldThreshold != null && message.hasOwnProperty("BoldThreshold")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.BoldThreshold.verify(message.BoldThreshold);
                        if (error)
                            return "BoldThreshold." + error;
                    }
                    return null;
                };

                /**
                 * Creates an ExportBoldRegionResultInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo} ExportBoldRegionResultInfo
                 */
                ExportBoldRegionResultInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo();
                    if (object.UID != null)
                        message.UID = String(object.UID);
                    if (object.refSeriesuid != null)
                        message.refSeriesuid = String(object.refSeriesuid);
                    if (object.pseudoColorInfo != null) {
                        if (typeof object.pseudoColorInfo !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo.pseudoColorInfo: object expected");
                        message.pseudoColorInfo = $root.UIBot.UHOR.ProtoBuf.PseudoColorInfo.fromObject(object.pseudoColorInfo);
                    }
                    if (object.BoldRegionResult != null) {
                        if (typeof object.BoldRegionResult !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo.BoldRegionResult: object expected");
                        message.BoldRegionResult = $root.UIBot.UHOR.ProtoBuf.MsgMaskInfo.fromObject(object.BoldRegionResult);
                    }
                    if (object.BoldRegionMask != null) {
                        if (typeof object.BoldRegionMask !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo.BoldRegionMask: object expected");
                        message.BoldRegionMask = $root.UIBot.UHOR.ProtoBuf.MsgMaskInfo.fromObject(object.BoldRegionMask);
                    }
                    if (object.regInfo != null) {
                        if (typeof object.regInfo !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo.regInfo: object expected");
                        message.regInfo = $root.UIBot.UHOR.ProtoBuf.MsgSRRegInfo.fromObject(object.regInfo);
                    }
                    if (object.ActiveBoldRegionLabels) {
                        if (!Array.isArray(object.ActiveBoldRegionLabels))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo.ActiveBoldRegionLabels: array expected");
                        message.ActiveBoldRegionLabels = [];
                        for (var i = 0; i < object.ActiveBoldRegionLabels.length; ++i)
                            message.ActiveBoldRegionLabels[i] = object.ActiveBoldRegionLabels[i] | 0;
                    }
                    if (object.ActiveBoldRegionLabelsFullName) {
                        if (!Array.isArray(object.ActiveBoldRegionLabelsFullName))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo.ActiveBoldRegionLabelsFullName: array expected");
                        message.ActiveBoldRegionLabelsFullName = [];
                        for (var i = 0; i < object.ActiveBoldRegionLabelsFullName.length; ++i)
                            message.ActiveBoldRegionLabelsFullName[i] = String(object.ActiveBoldRegionLabelsFullName[i]);
                    }
                    if (object.BoldRegionForeignMask != null) {
                        if (typeof object.BoldRegionForeignMask !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo.BoldRegionForeignMask: object expected");
                        message.BoldRegionForeignMask = $root.UIBot.UHOR.ProtoBuf.MsgMaskInfo.fromObject(object.BoldRegionForeignMask);
                    }
                    if (object.BoldThreshold != null) {
                        if (typeof object.BoldThreshold !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo.BoldThreshold: object expected");
                        message.BoldThreshold = $root.UIBot.UHOR.ProtoBuf.BoldThreshold.fromObject(object.BoldThreshold);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ExportBoldRegionResultInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo} message ExportBoldRegionResultInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExportBoldRegionResultInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.ActiveBoldRegionLabels = [];
                        object.ActiveBoldRegionLabelsFullName = [];
                    }
                    if (options.defaults) {
                        object.UID = "";
                        object.refSeriesuid = "";
                        object.pseudoColorInfo = null;
                        object.BoldRegionResult = null;
                        object.BoldRegionMask = null;
                        object.regInfo = null;
                        object.BoldRegionForeignMask = null;
                        object.BoldThreshold = null;
                    }
                    if (message.UID != null && message.hasOwnProperty("UID"))
                        object.UID = message.UID;
                    if (message.refSeriesuid != null && message.hasOwnProperty("refSeriesuid"))
                        object.refSeriesuid = message.refSeriesuid;
                    if (message.pseudoColorInfo != null && message.hasOwnProperty("pseudoColorInfo"))
                        object.pseudoColorInfo = $root.UIBot.UHOR.ProtoBuf.PseudoColorInfo.toObject(message.pseudoColorInfo, options);
                    if (message.BoldRegionResult != null && message.hasOwnProperty("BoldRegionResult"))
                        object.BoldRegionResult = $root.UIBot.UHOR.ProtoBuf.MsgMaskInfo.toObject(message.BoldRegionResult, options);
                    if (message.BoldRegionMask != null && message.hasOwnProperty("BoldRegionMask"))
                        object.BoldRegionMask = $root.UIBot.UHOR.ProtoBuf.MsgMaskInfo.toObject(message.BoldRegionMask, options);
                    if (message.regInfo != null && message.hasOwnProperty("regInfo"))
                        object.regInfo = $root.UIBot.UHOR.ProtoBuf.MsgSRRegInfo.toObject(message.regInfo, options);
                    if (message.ActiveBoldRegionLabels && message.ActiveBoldRegionLabels.length) {
                        object.ActiveBoldRegionLabels = [];
                        for (var j = 0; j < message.ActiveBoldRegionLabels.length; ++j)
                            object.ActiveBoldRegionLabels[j] = message.ActiveBoldRegionLabels[j];
                    }
                    if (message.ActiveBoldRegionLabelsFullName && message.ActiveBoldRegionLabelsFullName.length) {
                        object.ActiveBoldRegionLabelsFullName = [];
                        for (var j = 0; j < message.ActiveBoldRegionLabelsFullName.length; ++j)
                            object.ActiveBoldRegionLabelsFullName[j] = message.ActiveBoldRegionLabelsFullName[j];
                    }
                    if (message.BoldRegionForeignMask != null && message.hasOwnProperty("BoldRegionForeignMask"))
                        object.BoldRegionForeignMask = $root.UIBot.UHOR.ProtoBuf.MsgMaskInfo.toObject(message.BoldRegionForeignMask, options);
                    if (message.BoldThreshold != null && message.hasOwnProperty("BoldThreshold"))
                        object.BoldThreshold = $root.UIBot.UHOR.ProtoBuf.BoldThreshold.toObject(message.BoldThreshold, options);
                    return object;
                };

                /**
                 * Converts this ExportBoldRegionResultInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExportBoldRegionResultInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ExportBoldRegionResultInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ExportBoldRegionResultInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.ExportBoldRegionResultInfo";
                };

                return ExportBoldRegionResultInfo;
            })();

            ProtoBuf.ChangeInterpolationStatus = (function() {

                /**
                 * Properties of a ChangeInterpolationStatus.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IChangeInterpolationStatus
                 * @property {string|null} [BoldUID] ChangeInterpolationStatus BoldUID
                 * @property {number|null} [Opacity] ChangeInterpolationStatus Opacity
                 * @property {boolean|null} [Visible] ChangeInterpolationStatus Visible
                 * @property {UIBot.UHOR.ProtoBuf.InterpolationOperationType|null} [OperationType] ChangeInterpolationStatus OperationType
                 */

                /**
                 * Constructs a new ChangeInterpolationStatus.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a ChangeInterpolationStatus.
                 * @implements IChangeInterpolationStatus
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IChangeInterpolationStatus=} [properties] Properties to set
                 */
                function ChangeInterpolationStatus(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ChangeInterpolationStatus BoldUID.
                 * @member {string} BoldUID
                 * @memberof UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus
                 * @instance
                 */
                ChangeInterpolationStatus.prototype.BoldUID = "";

                /**
                 * ChangeInterpolationStatus Opacity.
                 * @member {number} Opacity
                 * @memberof UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus
                 * @instance
                 */
                ChangeInterpolationStatus.prototype.Opacity = 0;

                /**
                 * ChangeInterpolationStatus Visible.
                 * @member {boolean} Visible
                 * @memberof UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus
                 * @instance
                 */
                ChangeInterpolationStatus.prototype.Visible = false;

                /**
                 * ChangeInterpolationStatus OperationType.
                 * @member {UIBot.UHOR.ProtoBuf.InterpolationOperationType} OperationType
                 * @memberof UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus
                 * @instance
                 */
                ChangeInterpolationStatus.prototype.OperationType = 1;

                /**
                 * Creates a new ChangeInterpolationStatus instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IChangeInterpolationStatus=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus} ChangeInterpolationStatus instance
                 */
                ChangeInterpolationStatus.create = function create(properties) {
                    return new ChangeInterpolationStatus(properties);
                };

                /**
                 * Encodes the specified ChangeInterpolationStatus message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IChangeInterpolationStatus} message ChangeInterpolationStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChangeInterpolationStatus.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.BoldUID != null && Object.hasOwnProperty.call(message, "BoldUID"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.BoldUID);
                    if (message.OperationType != null && Object.hasOwnProperty.call(message, "OperationType"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.OperationType);
                    if (message.Opacity != null && Object.hasOwnProperty.call(message, "Opacity"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Opacity);
                    if (message.Visible != null && Object.hasOwnProperty.call(message, "Visible"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.Visible);
                    return writer;
                };

                /**
                 * Encodes the specified ChangeInterpolationStatus message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IChangeInterpolationStatus} message ChangeInterpolationStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChangeInterpolationStatus.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ChangeInterpolationStatus message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus} ChangeInterpolationStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChangeInterpolationStatus.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.BoldUID = reader.string();
                                break;
                            }
                        case 3: {
                                message.Opacity = reader.int32();
                                break;
                            }
                        case 4: {
                                message.Visible = reader.bool();
                                break;
                            }
                        case 2: {
                                message.OperationType = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ChangeInterpolationStatus message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus} ChangeInterpolationStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChangeInterpolationStatus.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ChangeInterpolationStatus message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChangeInterpolationStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.BoldUID != null && message.hasOwnProperty("BoldUID"))
                        if (!$util.isString(message.BoldUID))
                            return "BoldUID: string expected";
                    if (message.Opacity != null && message.hasOwnProperty("Opacity"))
                        if (!$util.isInteger(message.Opacity))
                            return "Opacity: integer expected";
                    if (message.Visible != null && message.hasOwnProperty("Visible"))
                        if (typeof message.Visible !== "boolean")
                            return "Visible: boolean expected";
                    if (message.OperationType != null && message.hasOwnProperty("OperationType"))
                        switch (message.OperationType) {
                        default:
                            return "OperationType: enum value expected";
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a ChangeInterpolationStatus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus} ChangeInterpolationStatus
                 */
                ChangeInterpolationStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus();
                    if (object.BoldUID != null)
                        message.BoldUID = String(object.BoldUID);
                    if (object.Opacity != null)
                        message.Opacity = object.Opacity | 0;
                    if (object.Visible != null)
                        message.Visible = Boolean(object.Visible);
                    switch (object.OperationType) {
                    default:
                        if (typeof object.OperationType === "number") {
                            message.OperationType = object.OperationType;
                            break;
                        }
                        break;
                    case "ChangeOpacity":
                    case 1:
                        message.OperationType = 1;
                        break;
                    case "ChangeVisible":
                    case 2:
                        message.OperationType = 2;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ChangeInterpolationStatus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus} message ChangeInterpolationStatus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChangeInterpolationStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.BoldUID = "";
                        object.OperationType = options.enums === String ? "ChangeOpacity" : 1;
                        object.Opacity = 0;
                        object.Visible = false;
                    }
                    if (message.BoldUID != null && message.hasOwnProperty("BoldUID"))
                        object.BoldUID = message.BoldUID;
                    if (message.OperationType != null && message.hasOwnProperty("OperationType"))
                        object.OperationType = options.enums === String ? $root.UIBot.UHOR.ProtoBuf.InterpolationOperationType[message.OperationType] === undefined ? message.OperationType : $root.UIBot.UHOR.ProtoBuf.InterpolationOperationType[message.OperationType] : message.OperationType;
                    if (message.Opacity != null && message.hasOwnProperty("Opacity"))
                        object.Opacity = message.Opacity;
                    if (message.Visible != null && message.hasOwnProperty("Visible"))
                        object.Visible = message.Visible;
                    return object;
                };

                /**
                 * Converts this ChangeInterpolationStatus to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChangeInterpolationStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ChangeInterpolationStatus
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ChangeInterpolationStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.ChangeInterpolationStatus";
                };

                return ChangeInterpolationStatus;
            })();

            ProtoBuf.BoldThreshold = (function() {

                /**
                 * Properties of a BoldThreshold.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IBoldThreshold
                 * @property {number} PosMax BoldThreshold PosMax
                 * @property {number} PosMin BoldThreshold PosMin
                 * @property {number} NegMax BoldThreshold NegMax
                 * @property {number} NegMin BoldThreshold NegMin
                 */

                /**
                 * Constructs a new BoldThreshold.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a BoldThreshold.
                 * @implements IBoldThreshold
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IBoldThreshold=} [properties] Properties to set
                 */
                function BoldThreshold(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BoldThreshold PosMax.
                 * @member {number} PosMax
                 * @memberof UIBot.UHOR.ProtoBuf.BoldThreshold
                 * @instance
                 */
                BoldThreshold.prototype.PosMax = 0;

                /**
                 * BoldThreshold PosMin.
                 * @member {number} PosMin
                 * @memberof UIBot.UHOR.ProtoBuf.BoldThreshold
                 * @instance
                 */
                BoldThreshold.prototype.PosMin = 0;

                /**
                 * BoldThreshold NegMax.
                 * @member {number} NegMax
                 * @memberof UIBot.UHOR.ProtoBuf.BoldThreshold
                 * @instance
                 */
                BoldThreshold.prototype.NegMax = 0;

                /**
                 * BoldThreshold NegMin.
                 * @member {number} NegMin
                 * @memberof UIBot.UHOR.ProtoBuf.BoldThreshold
                 * @instance
                 */
                BoldThreshold.prototype.NegMin = 0;

                /**
                 * Creates a new BoldThreshold instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.BoldThreshold
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBoldThreshold=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.BoldThreshold} BoldThreshold instance
                 */
                BoldThreshold.create = function create(properties) {
                    return new BoldThreshold(properties);
                };

                /**
                 * Encodes the specified BoldThreshold message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.BoldThreshold.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.BoldThreshold
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBoldThreshold} message BoldThreshold message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BoldThreshold.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.PosMax);
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.PosMin);
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.NegMax);
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.NegMin);
                    return writer;
                };

                /**
                 * Encodes the specified BoldThreshold message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.BoldThreshold.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.BoldThreshold
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBoldThreshold} message BoldThreshold message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BoldThreshold.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BoldThreshold message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.BoldThreshold
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.BoldThreshold} BoldThreshold
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BoldThreshold.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.BoldThreshold();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.PosMax = reader.float();
                                break;
                            }
                        case 2: {
                                message.PosMin = reader.float();
                                break;
                            }
                        case 3: {
                                message.NegMax = reader.float();
                                break;
                            }
                        case 4: {
                                message.NegMin = reader.float();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("PosMax"))
                        throw $util.ProtocolError("missing required 'PosMax'", { instance: message });
                    if (!message.hasOwnProperty("PosMin"))
                        throw $util.ProtocolError("missing required 'PosMin'", { instance: message });
                    if (!message.hasOwnProperty("NegMax"))
                        throw $util.ProtocolError("missing required 'NegMax'", { instance: message });
                    if (!message.hasOwnProperty("NegMin"))
                        throw $util.ProtocolError("missing required 'NegMin'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a BoldThreshold message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.BoldThreshold
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.BoldThreshold} BoldThreshold
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BoldThreshold.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BoldThreshold message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.BoldThreshold
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BoldThreshold.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (typeof message.PosMax !== "number")
                        return "PosMax: number expected";
                    if (typeof message.PosMin !== "number")
                        return "PosMin: number expected";
                    if (typeof message.NegMax !== "number")
                        return "NegMax: number expected";
                    if (typeof message.NegMin !== "number")
                        return "NegMin: number expected";
                    return null;
                };

                /**
                 * Creates a BoldThreshold message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.BoldThreshold
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.BoldThreshold} BoldThreshold
                 */
                BoldThreshold.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.BoldThreshold)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.BoldThreshold();
                    if (object.PosMax != null)
                        message.PosMax = Number(object.PosMax);
                    if (object.PosMin != null)
                        message.PosMin = Number(object.PosMin);
                    if (object.NegMax != null)
                        message.NegMax = Number(object.NegMax);
                    if (object.NegMin != null)
                        message.NegMin = Number(object.NegMin);
                    return message;
                };

                /**
                 * Creates a plain object from a BoldThreshold message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.BoldThreshold
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.BoldThreshold} message BoldThreshold
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BoldThreshold.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.PosMax = 0;
                        object.PosMin = 0;
                        object.NegMax = 0;
                        object.NegMin = 0;
                    }
                    if (message.PosMax != null && message.hasOwnProperty("PosMax"))
                        object.PosMax = options.json && !isFinite(message.PosMax) ? String(message.PosMax) : message.PosMax;
                    if (message.PosMin != null && message.hasOwnProperty("PosMin"))
                        object.PosMin = options.json && !isFinite(message.PosMin) ? String(message.PosMin) : message.PosMin;
                    if (message.NegMax != null && message.hasOwnProperty("NegMax"))
                        object.NegMax = options.json && !isFinite(message.NegMax) ? String(message.NegMax) : message.NegMax;
                    if (message.NegMin != null && message.hasOwnProperty("NegMin"))
                        object.NegMin = options.json && !isFinite(message.NegMin) ? String(message.NegMin) : message.NegMin;
                    return object;
                };

                /**
                 * Converts this BoldThreshold to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.BoldThreshold
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BoldThreshold.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for BoldThreshold
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.BoldThreshold
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                BoldThreshold.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.BoldThreshold";
                };

                return BoldThreshold;
            })();

            ProtoBuf.MsgColor = (function() {

                /**
                 * Properties of a MsgColor.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMsgColor
                 * @property {number} red MsgColor red
                 * @property {number} green MsgColor green
                 * @property {number} blue MsgColor blue
                 * @property {number} alpha MsgColor alpha
                 */

                /**
                 * Constructs a new MsgColor.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MsgColor.
                 * @implements IMsgColor
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMsgColor=} [properties] Properties to set
                 */
                function MsgColor(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MsgColor red.
                 * @member {number} red
                 * @memberof UIBot.UHOR.ProtoBuf.MsgColor
                 * @instance
                 */
                MsgColor.prototype.red = 0;

                /**
                 * MsgColor green.
                 * @member {number} green
                 * @memberof UIBot.UHOR.ProtoBuf.MsgColor
                 * @instance
                 */
                MsgColor.prototype.green = 0;

                /**
                 * MsgColor blue.
                 * @member {number} blue
                 * @memberof UIBot.UHOR.ProtoBuf.MsgColor
                 * @instance
                 */
                MsgColor.prototype.blue = 0;

                /**
                 * MsgColor alpha.
                 * @member {number} alpha
                 * @memberof UIBot.UHOR.ProtoBuf.MsgColor
                 * @instance
                 */
                MsgColor.prototype.alpha = 0;

                /**
                 * Creates a new MsgColor instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MsgColor
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgColor=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MsgColor} MsgColor instance
                 */
                MsgColor.create = function create(properties) {
                    return new MsgColor(properties);
                };

                /**
                 * Encodes the specified MsgColor message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgColor.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgColor
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgColor} message MsgColor message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgColor.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.red);
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.green);
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.blue);
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.alpha);
                    return writer;
                };

                /**
                 * Encodes the specified MsgColor message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgColor.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgColor
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgColor} message MsgColor message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgColor.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MsgColor message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgColor
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MsgColor} MsgColor
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgColor.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MsgColor();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.red = reader.int32();
                                break;
                            }
                        case 2: {
                                message.green = reader.int32();
                                break;
                            }
                        case 3: {
                                message.blue = reader.int32();
                                break;
                            }
                        case 4: {
                                message.alpha = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("red"))
                        throw $util.ProtocolError("missing required 'red'", { instance: message });
                    if (!message.hasOwnProperty("green"))
                        throw $util.ProtocolError("missing required 'green'", { instance: message });
                    if (!message.hasOwnProperty("blue"))
                        throw $util.ProtocolError("missing required 'blue'", { instance: message });
                    if (!message.hasOwnProperty("alpha"))
                        throw $util.ProtocolError("missing required 'alpha'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a MsgColor message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgColor
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MsgColor} MsgColor
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgColor.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MsgColor message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MsgColor
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgColor.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isInteger(message.red))
                        return "red: integer expected";
                    if (!$util.isInteger(message.green))
                        return "green: integer expected";
                    if (!$util.isInteger(message.blue))
                        return "blue: integer expected";
                    if (!$util.isInteger(message.alpha))
                        return "alpha: integer expected";
                    return null;
                };

                /**
                 * Creates a MsgColor message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgColor
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MsgColor} MsgColor
                 */
                MsgColor.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MsgColor)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MsgColor();
                    if (object.red != null)
                        message.red = object.red | 0;
                    if (object.green != null)
                        message.green = object.green | 0;
                    if (object.blue != null)
                        message.blue = object.blue | 0;
                    if (object.alpha != null)
                        message.alpha = object.alpha | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a MsgColor message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgColor
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MsgColor} message MsgColor
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgColor.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.red = 0;
                        object.green = 0;
                        object.blue = 0;
                        object.alpha = 0;
                    }
                    if (message.red != null && message.hasOwnProperty("red"))
                        object.red = message.red;
                    if (message.green != null && message.hasOwnProperty("green"))
                        object.green = message.green;
                    if (message.blue != null && message.hasOwnProperty("blue"))
                        object.blue = message.blue;
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = message.alpha;
                    return object;
                };

                /**
                 * Converts this MsgColor to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MsgColor
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgColor.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MsgColor
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MsgColor
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MsgColor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MsgColor";
                };

                return MsgColor;
            })();

            ProtoBuf.StatisticResult = (function() {

                /**
                 * Properties of a StatisticResult.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IStatisticResult
                 * @property {number|null} [elemCount] StatisticResult elemCount
                 * @property {number|null} [volume] StatisticResult volume
                 * @property {number|null} [mean] StatisticResult mean
                 * @property {number|null} [staticMax] StatisticResult staticMax
                 * @property {number|null} [staticMin] StatisticResult staticMin
                 * @property {number|null} [staticStd] StatisticResult staticStd
                 * @property {number|null} [maxX] StatisticResult maxX
                 * @property {number|null} [maxY] StatisticResult maxY
                 * @property {number|null} [maxZ] StatisticResult maxZ
                 * @property {number|null} [sliceLocation] StatisticResult sliceLocation
                 * @property {number|null} [peak] StatisticResult peak
                 * @property {string|null} [rulerUnit] StatisticResult rulerUnit
                 * @property {string|null} [valueUnit] StatisticResult valueUnit
                 */

                /**
                 * Constructs a new StatisticResult.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a StatisticResult.
                 * @implements IStatisticResult
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IStatisticResult=} [properties] Properties to set
                 */
                function StatisticResult(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StatisticResult elemCount.
                 * @member {number} elemCount
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @instance
                 */
                StatisticResult.prototype.elemCount = 0;

                /**
                 * StatisticResult volume.
                 * @member {number} volume
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @instance
                 */
                StatisticResult.prototype.volume = 0;

                /**
                 * StatisticResult mean.
                 * @member {number} mean
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @instance
                 */
                StatisticResult.prototype.mean = 0;

                /**
                 * StatisticResult staticMax.
                 * @member {number} staticMax
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @instance
                 */
                StatisticResult.prototype.staticMax = 0;

                /**
                 * StatisticResult staticMin.
                 * @member {number} staticMin
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @instance
                 */
                StatisticResult.prototype.staticMin = 0;

                /**
                 * StatisticResult staticStd.
                 * @member {number} staticStd
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @instance
                 */
                StatisticResult.prototype.staticStd = 0;

                /**
                 * StatisticResult maxX.
                 * @member {number} maxX
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @instance
                 */
                StatisticResult.prototype.maxX = 0;

                /**
                 * StatisticResult maxY.
                 * @member {number} maxY
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @instance
                 */
                StatisticResult.prototype.maxY = 0;

                /**
                 * StatisticResult maxZ.
                 * @member {number} maxZ
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @instance
                 */
                StatisticResult.prototype.maxZ = 0;

                /**
                 * StatisticResult sliceLocation.
                 * @member {number} sliceLocation
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @instance
                 */
                StatisticResult.prototype.sliceLocation = 0;

                /**
                 * StatisticResult peak.
                 * @member {number} peak
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @instance
                 */
                StatisticResult.prototype.peak = 0;

                /**
                 * StatisticResult rulerUnit.
                 * @member {string} rulerUnit
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @instance
                 */
                StatisticResult.prototype.rulerUnit = "";

                /**
                 * StatisticResult valueUnit.
                 * @member {string} valueUnit
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @instance
                 */
                StatisticResult.prototype.valueUnit = "";

                /**
                 * Creates a new StatisticResult instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IStatisticResult=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.StatisticResult} StatisticResult instance
                 */
                StatisticResult.create = function create(properties) {
                    return new StatisticResult(properties);
                };

                /**
                 * Encodes the specified StatisticResult message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.StatisticResult.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IStatisticResult} message StatisticResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StatisticResult.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.elemCount != null && Object.hasOwnProperty.call(message, "elemCount"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.elemCount);
                    if (message.volume != null && Object.hasOwnProperty.call(message, "volume"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.volume);
                    if (message.mean != null && Object.hasOwnProperty.call(message, "mean"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.mean);
                    if (message.staticMax != null && Object.hasOwnProperty.call(message, "staticMax"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.staticMax);
                    if (message.staticMin != null && Object.hasOwnProperty.call(message, "staticMin"))
                        writer.uint32(/* id 5, wireType 1 =*/41).double(message.staticMin);
                    if (message.staticStd != null && Object.hasOwnProperty.call(message, "staticStd"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.staticStd);
                    if (message.maxX != null && Object.hasOwnProperty.call(message, "maxX"))
                        writer.uint32(/* id 7, wireType 1 =*/57).double(message.maxX);
                    if (message.maxY != null && Object.hasOwnProperty.call(message, "maxY"))
                        writer.uint32(/* id 8, wireType 1 =*/65).double(message.maxY);
                    if (message.maxZ != null && Object.hasOwnProperty.call(message, "maxZ"))
                        writer.uint32(/* id 9, wireType 1 =*/73).double(message.maxZ);
                    if (message.sliceLocation != null && Object.hasOwnProperty.call(message, "sliceLocation"))
                        writer.uint32(/* id 10, wireType 1 =*/81).double(message.sliceLocation);
                    if (message.peak != null && Object.hasOwnProperty.call(message, "peak"))
                        writer.uint32(/* id 11, wireType 1 =*/89).double(message.peak);
                    if (message.rulerUnit != null && Object.hasOwnProperty.call(message, "rulerUnit"))
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.rulerUnit);
                    if (message.valueUnit != null && Object.hasOwnProperty.call(message, "valueUnit"))
                        writer.uint32(/* id 13, wireType 2 =*/106).string(message.valueUnit);
                    return writer;
                };

                /**
                 * Encodes the specified StatisticResult message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.StatisticResult.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IStatisticResult} message StatisticResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StatisticResult.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a StatisticResult message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.StatisticResult} StatisticResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StatisticResult.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.StatisticResult();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.elemCount = reader.int32();
                                break;
                            }
                        case 2: {
                                message.volume = reader.double();
                                break;
                            }
                        case 3: {
                                message.mean = reader.double();
                                break;
                            }
                        case 4: {
                                message.staticMax = reader.double();
                                break;
                            }
                        case 5: {
                                message.staticMin = reader.double();
                                break;
                            }
                        case 6: {
                                message.staticStd = reader.double();
                                break;
                            }
                        case 7: {
                                message.maxX = reader.double();
                                break;
                            }
                        case 8: {
                                message.maxY = reader.double();
                                break;
                            }
                        case 9: {
                                message.maxZ = reader.double();
                                break;
                            }
                        case 10: {
                                message.sliceLocation = reader.double();
                                break;
                            }
                        case 11: {
                                message.peak = reader.double();
                                break;
                            }
                        case 12: {
                                message.rulerUnit = reader.string();
                                break;
                            }
                        case 13: {
                                message.valueUnit = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a StatisticResult message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.StatisticResult} StatisticResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StatisticResult.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a StatisticResult message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StatisticResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.elemCount != null && message.hasOwnProperty("elemCount"))
                        if (!$util.isInteger(message.elemCount))
                            return "elemCount: integer expected";
                    if (message.volume != null && message.hasOwnProperty("volume"))
                        if (typeof message.volume !== "number")
                            return "volume: number expected";
                    if (message.mean != null && message.hasOwnProperty("mean"))
                        if (typeof message.mean !== "number")
                            return "mean: number expected";
                    if (message.staticMax != null && message.hasOwnProperty("staticMax"))
                        if (typeof message.staticMax !== "number")
                            return "staticMax: number expected";
                    if (message.staticMin != null && message.hasOwnProperty("staticMin"))
                        if (typeof message.staticMin !== "number")
                            return "staticMin: number expected";
                    if (message.staticStd != null && message.hasOwnProperty("staticStd"))
                        if (typeof message.staticStd !== "number")
                            return "staticStd: number expected";
                    if (message.maxX != null && message.hasOwnProperty("maxX"))
                        if (typeof message.maxX !== "number")
                            return "maxX: number expected";
                    if (message.maxY != null && message.hasOwnProperty("maxY"))
                        if (typeof message.maxY !== "number")
                            return "maxY: number expected";
                    if (message.maxZ != null && message.hasOwnProperty("maxZ"))
                        if (typeof message.maxZ !== "number")
                            return "maxZ: number expected";
                    if (message.sliceLocation != null && message.hasOwnProperty("sliceLocation"))
                        if (typeof message.sliceLocation !== "number")
                            return "sliceLocation: number expected";
                    if (message.peak != null && message.hasOwnProperty("peak"))
                        if (typeof message.peak !== "number")
                            return "peak: number expected";
                    if (message.rulerUnit != null && message.hasOwnProperty("rulerUnit"))
                        if (!$util.isString(message.rulerUnit))
                            return "rulerUnit: string expected";
                    if (message.valueUnit != null && message.hasOwnProperty("valueUnit"))
                        if (!$util.isString(message.valueUnit))
                            return "valueUnit: string expected";
                    return null;
                };

                /**
                 * Creates a StatisticResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.StatisticResult} StatisticResult
                 */
                StatisticResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.StatisticResult)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.StatisticResult();
                    if (object.elemCount != null)
                        message.elemCount = object.elemCount | 0;
                    if (object.volume != null)
                        message.volume = Number(object.volume);
                    if (object.mean != null)
                        message.mean = Number(object.mean);
                    if (object.staticMax != null)
                        message.staticMax = Number(object.staticMax);
                    if (object.staticMin != null)
                        message.staticMin = Number(object.staticMin);
                    if (object.staticStd != null)
                        message.staticStd = Number(object.staticStd);
                    if (object.maxX != null)
                        message.maxX = Number(object.maxX);
                    if (object.maxY != null)
                        message.maxY = Number(object.maxY);
                    if (object.maxZ != null)
                        message.maxZ = Number(object.maxZ);
                    if (object.sliceLocation != null)
                        message.sliceLocation = Number(object.sliceLocation);
                    if (object.peak != null)
                        message.peak = Number(object.peak);
                    if (object.rulerUnit != null)
                        message.rulerUnit = String(object.rulerUnit);
                    if (object.valueUnit != null)
                        message.valueUnit = String(object.valueUnit);
                    return message;
                };

                /**
                 * Creates a plain object from a StatisticResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.StatisticResult} message StatisticResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StatisticResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.elemCount = 0;
                        object.volume = 0;
                        object.mean = 0;
                        object.staticMax = 0;
                        object.staticMin = 0;
                        object.staticStd = 0;
                        object.maxX = 0;
                        object.maxY = 0;
                        object.maxZ = 0;
                        object.sliceLocation = 0;
                        object.peak = 0;
                        object.rulerUnit = "";
                        object.valueUnit = "";
                    }
                    if (message.elemCount != null && message.hasOwnProperty("elemCount"))
                        object.elemCount = message.elemCount;
                    if (message.volume != null && message.hasOwnProperty("volume"))
                        object.volume = options.json && !isFinite(message.volume) ? String(message.volume) : message.volume;
                    if (message.mean != null && message.hasOwnProperty("mean"))
                        object.mean = options.json && !isFinite(message.mean) ? String(message.mean) : message.mean;
                    if (message.staticMax != null && message.hasOwnProperty("staticMax"))
                        object.staticMax = options.json && !isFinite(message.staticMax) ? String(message.staticMax) : message.staticMax;
                    if (message.staticMin != null && message.hasOwnProperty("staticMin"))
                        object.staticMin = options.json && !isFinite(message.staticMin) ? String(message.staticMin) : message.staticMin;
                    if (message.staticStd != null && message.hasOwnProperty("staticStd"))
                        object.staticStd = options.json && !isFinite(message.staticStd) ? String(message.staticStd) : message.staticStd;
                    if (message.maxX != null && message.hasOwnProperty("maxX"))
                        object.maxX = options.json && !isFinite(message.maxX) ? String(message.maxX) : message.maxX;
                    if (message.maxY != null && message.hasOwnProperty("maxY"))
                        object.maxY = options.json && !isFinite(message.maxY) ? String(message.maxY) : message.maxY;
                    if (message.maxZ != null && message.hasOwnProperty("maxZ"))
                        object.maxZ = options.json && !isFinite(message.maxZ) ? String(message.maxZ) : message.maxZ;
                    if (message.sliceLocation != null && message.hasOwnProperty("sliceLocation"))
                        object.sliceLocation = options.json && !isFinite(message.sliceLocation) ? String(message.sliceLocation) : message.sliceLocation;
                    if (message.peak != null && message.hasOwnProperty("peak"))
                        object.peak = options.json && !isFinite(message.peak) ? String(message.peak) : message.peak;
                    if (message.rulerUnit != null && message.hasOwnProperty("rulerUnit"))
                        object.rulerUnit = message.rulerUnit;
                    if (message.valueUnit != null && message.hasOwnProperty("valueUnit"))
                        object.valueUnit = message.valueUnit;
                    return object;
                };

                /**
                 * Converts this StatisticResult to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StatisticResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for StatisticResult
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.StatisticResult
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                StatisticResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.StatisticResult";
                };

                return StatisticResult;
            })();

            ProtoBuf.MsgTissueInfo = (function() {

                /**
                 * Properties of a MsgTissueInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMsgTissueInfo
                 * @property {number} tissueId MsgTissueInfo tissueId
                 * @property {string|null} [name] MsgTissueInfo name
                 * @property {number|null} [opacity] MsgTissueInfo opacity
                 * @property {UIBot.UHOR.ProtoBuf.IMsgColor|null} [color] MsgTissueInfo color
                 * @property {string|null} [vrtPath] MsgTissueInfo vrtPath
                 * @property {boolean|null} [visibility] MsgTissueInfo visibility
                 * @property {boolean|null} [isLocked] MsgTissueInfo isLocked
                 * @property {boolean|null} [deleteEnabled] MsgTissueInfo deleteEnabled
                 * @property {boolean|null} [isSelected] MsgTissueInfo isSelected
                 * @property {boolean|null} [isDisplayStatistic] MsgTissueInfo isDisplayStatistic
                 * @property {boolean|null} [isUseVrt] MsgTissueInfo isUseVrt
                 * @property {number|null} [tissueType] MsgTissueInfo tissueType
                 * @property {string|null} [tissueBasis] MsgTissueInfo tissueBasis
                 * @property {Uint8Array|null} [appInfo] MsgTissueInfo appInfo
                 * @property {string|null} [tissueComments] MsgTissueInfo tissueComments
                 * @property {boolean|null} [tissueRefUidVisible] MsgTissueInfo tissueRefUidVisible
                 * @property {Array.<number>|null} [labels] MsgTissueInfo labels
                 * @property {UIBot.UHOR.ProtoBuf.IStatisticResult|null} [tissueStatic] MsgTissueInfo tissueStatic
                 * @property {Uint8Array|null} [stateOnMpr] MsgTissueInfo stateOnMpr
                 * @property {Uint8Array|null} [stateOnVr] MsgTissueInfo stateOnVr
                 * @property {string|null} [cellname] MsgTissueInfo cellname
                 */

                /**
                 * Constructs a new MsgTissueInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MsgTissueInfo.
                 * @implements IMsgTissueInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMsgTissueInfo=} [properties] Properties to set
                 */
                function MsgTissueInfo(properties) {
                    this.labels = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MsgTissueInfo tissueId.
                 * @member {number} tissueId
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.tissueId = 0;

                /**
                 * MsgTissueInfo name.
                 * @member {string} name
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.name = "";

                /**
                 * MsgTissueInfo opacity.
                 * @member {number} opacity
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.opacity = 0;

                /**
                 * MsgTissueInfo color.
                 * @member {UIBot.UHOR.ProtoBuf.IMsgColor|null|undefined} color
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.color = null;

                /**
                 * MsgTissueInfo vrtPath.
                 * @member {string} vrtPath
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.vrtPath = "";

                /**
                 * MsgTissueInfo visibility.
                 * @member {boolean} visibility
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.visibility = false;

                /**
                 * MsgTissueInfo isLocked.
                 * @member {boolean} isLocked
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.isLocked = false;

                /**
                 * MsgTissueInfo deleteEnabled.
                 * @member {boolean} deleteEnabled
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.deleteEnabled = false;

                /**
                 * MsgTissueInfo isSelected.
                 * @member {boolean} isSelected
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.isSelected = false;

                /**
                 * MsgTissueInfo isDisplayStatistic.
                 * @member {boolean} isDisplayStatistic
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.isDisplayStatistic = false;

                /**
                 * MsgTissueInfo isUseVrt.
                 * @member {boolean} isUseVrt
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.isUseVrt = false;

                /**
                 * MsgTissueInfo tissueType.
                 * @member {number} tissueType
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.tissueType = 0;

                /**
                 * MsgTissueInfo tissueBasis.
                 * @member {string} tissueBasis
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.tissueBasis = "";

                /**
                 * MsgTissueInfo appInfo.
                 * @member {Uint8Array} appInfo
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.appInfo = $util.newBuffer([]);

                /**
                 * MsgTissueInfo tissueComments.
                 * @member {string} tissueComments
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.tissueComments = "";

                /**
                 * MsgTissueInfo tissueRefUidVisible.
                 * @member {boolean} tissueRefUidVisible
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.tissueRefUidVisible = false;

                /**
                 * MsgTissueInfo labels.
                 * @member {Array.<number>} labels
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.labels = $util.emptyArray;

                /**
                 * MsgTissueInfo tissueStatic.
                 * @member {UIBot.UHOR.ProtoBuf.IStatisticResult|null|undefined} tissueStatic
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.tissueStatic = null;

                /**
                 * MsgTissueInfo stateOnMpr.
                 * @member {Uint8Array} stateOnMpr
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.stateOnMpr = $util.newBuffer([]);

                /**
                 * MsgTissueInfo stateOnVr.
                 * @member {Uint8Array} stateOnVr
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.stateOnVr = $util.newBuffer([]);

                /**
                 * MsgTissueInfo cellname.
                 * @member {string} cellname
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 */
                MsgTissueInfo.prototype.cellname = "";

                /**
                 * Creates a new MsgTissueInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgTissueInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MsgTissueInfo} MsgTissueInfo instance
                 */
                MsgTissueInfo.create = function create(properties) {
                    return new MsgTissueInfo(properties);
                };

                /**
                 * Encodes the specified MsgTissueInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgTissueInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgTissueInfo} message MsgTissueInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgTissueInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tissueId);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.opacity != null && Object.hasOwnProperty.call(message, "opacity"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.opacity);
                    if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                        $root.UIBot.UHOR.ProtoBuf.MsgColor.encode(message.color, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.vrtPath != null && Object.hasOwnProperty.call(message, "vrtPath"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.vrtPath);
                    if (message.visibility != null && Object.hasOwnProperty.call(message, "visibility"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.visibility);
                    if (message.isLocked != null && Object.hasOwnProperty.call(message, "isLocked"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isLocked);
                    if (message.deleteEnabled != null && Object.hasOwnProperty.call(message, "deleteEnabled"))
                        writer.uint32(/* id 8, wireType 0 =*/64).bool(message.deleteEnabled);
                    if (message.isSelected != null && Object.hasOwnProperty.call(message, "isSelected"))
                        writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isSelected);
                    if (message.isDisplayStatistic != null && Object.hasOwnProperty.call(message, "isDisplayStatistic"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.isDisplayStatistic);
                    if (message.isUseVrt != null && Object.hasOwnProperty.call(message, "isUseVrt"))
                        writer.uint32(/* id 11, wireType 0 =*/88).bool(message.isUseVrt);
                    if (message.tissueType != null && Object.hasOwnProperty.call(message, "tissueType"))
                        writer.uint32(/* id 12, wireType 0 =*/96).int32(message.tissueType);
                    if (message.tissueBasis != null && Object.hasOwnProperty.call(message, "tissueBasis"))
                        writer.uint32(/* id 13, wireType 2 =*/106).string(message.tissueBasis);
                    if (message.appInfo != null && Object.hasOwnProperty.call(message, "appInfo"))
                        writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.appInfo);
                    if (message.tissueComments != null && Object.hasOwnProperty.call(message, "tissueComments"))
                        writer.uint32(/* id 15, wireType 2 =*/122).string(message.tissueComments);
                    if (message.tissueRefUidVisible != null && Object.hasOwnProperty.call(message, "tissueRefUidVisible"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.tissueRefUidVisible);
                    if (message.labels != null && message.labels.length)
                        for (var i = 0; i < message.labels.length; ++i)
                            writer.uint32(/* id 17, wireType 0 =*/136).int32(message.labels[i]);
                    if (message.tissueStatic != null && Object.hasOwnProperty.call(message, "tissueStatic"))
                        $root.UIBot.UHOR.ProtoBuf.StatisticResult.encode(message.tissueStatic, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                    if (message.stateOnMpr != null && Object.hasOwnProperty.call(message, "stateOnMpr"))
                        writer.uint32(/* id 19, wireType 2 =*/154).bytes(message.stateOnMpr);
                    if (message.stateOnVr != null && Object.hasOwnProperty.call(message, "stateOnVr"))
                        writer.uint32(/* id 20, wireType 2 =*/162).bytes(message.stateOnVr);
                    if (message.cellname != null && Object.hasOwnProperty.call(message, "cellname"))
                        writer.uint32(/* id 21, wireType 2 =*/170).string(message.cellname);
                    return writer;
                };

                /**
                 * Encodes the specified MsgTissueInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgTissueInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgTissueInfo} message MsgTissueInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgTissueInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MsgTissueInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MsgTissueInfo} MsgTissueInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgTissueInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MsgTissueInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.tissueId = reader.int32();
                                break;
                            }
                        case 2: {
                                message.name = reader.string();
                                break;
                            }
                        case 3: {
                                message.opacity = reader.double();
                                break;
                            }
                        case 4: {
                                message.color = $root.UIBot.UHOR.ProtoBuf.MsgColor.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.vrtPath = reader.string();
                                break;
                            }
                        case 6: {
                                message.visibility = reader.bool();
                                break;
                            }
                        case 7: {
                                message.isLocked = reader.bool();
                                break;
                            }
                        case 8: {
                                message.deleteEnabled = reader.bool();
                                break;
                            }
                        case 9: {
                                message.isSelected = reader.bool();
                                break;
                            }
                        case 10: {
                                message.isDisplayStatistic = reader.bool();
                                break;
                            }
                        case 11: {
                                message.isUseVrt = reader.bool();
                                break;
                            }
                        case 12: {
                                message.tissueType = reader.int32();
                                break;
                            }
                        case 13: {
                                message.tissueBasis = reader.string();
                                break;
                            }
                        case 14: {
                                message.appInfo = reader.bytes();
                                break;
                            }
                        case 15: {
                                message.tissueComments = reader.string();
                                break;
                            }
                        case 16: {
                                message.tissueRefUidVisible = reader.bool();
                                break;
                            }
                        case 17: {
                                if (!(message.labels && message.labels.length))
                                    message.labels = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.labels.push(reader.int32());
                                } else
                                    message.labels.push(reader.int32());
                                break;
                            }
                        case 18: {
                                message.tissueStatic = $root.UIBot.UHOR.ProtoBuf.StatisticResult.decode(reader, reader.uint32());
                                break;
                            }
                        case 19: {
                                message.stateOnMpr = reader.bytes();
                                break;
                            }
                        case 20: {
                                message.stateOnVr = reader.bytes();
                                break;
                            }
                        case 21: {
                                message.cellname = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("tissueId"))
                        throw $util.ProtocolError("missing required 'tissueId'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a MsgTissueInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MsgTissueInfo} MsgTissueInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgTissueInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MsgTissueInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgTissueInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isInteger(message.tissueId))
                        return "tissueId: integer expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.opacity != null && message.hasOwnProperty("opacity"))
                        if (typeof message.opacity !== "number")
                            return "opacity: number expected";
                    if (message.color != null && message.hasOwnProperty("color")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.MsgColor.verify(message.color);
                        if (error)
                            return "color." + error;
                    }
                    if (message.vrtPath != null && message.hasOwnProperty("vrtPath"))
                        if (!$util.isString(message.vrtPath))
                            return "vrtPath: string expected";
                    if (message.visibility != null && message.hasOwnProperty("visibility"))
                        if (typeof message.visibility !== "boolean")
                            return "visibility: boolean expected";
                    if (message.isLocked != null && message.hasOwnProperty("isLocked"))
                        if (typeof message.isLocked !== "boolean")
                            return "isLocked: boolean expected";
                    if (message.deleteEnabled != null && message.hasOwnProperty("deleteEnabled"))
                        if (typeof message.deleteEnabled !== "boolean")
                            return "deleteEnabled: boolean expected";
                    if (message.isSelected != null && message.hasOwnProperty("isSelected"))
                        if (typeof message.isSelected !== "boolean")
                            return "isSelected: boolean expected";
                    if (message.isDisplayStatistic != null && message.hasOwnProperty("isDisplayStatistic"))
                        if (typeof message.isDisplayStatistic !== "boolean")
                            return "isDisplayStatistic: boolean expected";
                    if (message.isUseVrt != null && message.hasOwnProperty("isUseVrt"))
                        if (typeof message.isUseVrt !== "boolean")
                            return "isUseVrt: boolean expected";
                    if (message.tissueType != null && message.hasOwnProperty("tissueType"))
                        if (!$util.isInteger(message.tissueType))
                            return "tissueType: integer expected";
                    if (message.tissueBasis != null && message.hasOwnProperty("tissueBasis"))
                        if (!$util.isString(message.tissueBasis))
                            return "tissueBasis: string expected";
                    if (message.appInfo != null && message.hasOwnProperty("appInfo"))
                        if (!(message.appInfo && typeof message.appInfo.length === "number" || $util.isString(message.appInfo)))
                            return "appInfo: buffer expected";
                    if (message.tissueComments != null && message.hasOwnProperty("tissueComments"))
                        if (!$util.isString(message.tissueComments))
                            return "tissueComments: string expected";
                    if (message.tissueRefUidVisible != null && message.hasOwnProperty("tissueRefUidVisible"))
                        if (typeof message.tissueRefUidVisible !== "boolean")
                            return "tissueRefUidVisible: boolean expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!Array.isArray(message.labels))
                            return "labels: array expected";
                        for (var i = 0; i < message.labels.length; ++i)
                            if (!$util.isInteger(message.labels[i]))
                                return "labels: integer[] expected";
                    }
                    if (message.tissueStatic != null && message.hasOwnProperty("tissueStatic")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.StatisticResult.verify(message.tissueStatic);
                        if (error)
                            return "tissueStatic." + error;
                    }
                    if (message.stateOnMpr != null && message.hasOwnProperty("stateOnMpr"))
                        if (!(message.stateOnMpr && typeof message.stateOnMpr.length === "number" || $util.isString(message.stateOnMpr)))
                            return "stateOnMpr: buffer expected";
                    if (message.stateOnVr != null && message.hasOwnProperty("stateOnVr"))
                        if (!(message.stateOnVr && typeof message.stateOnVr.length === "number" || $util.isString(message.stateOnVr)))
                            return "stateOnVr: buffer expected";
                    if (message.cellname != null && message.hasOwnProperty("cellname"))
                        if (!$util.isString(message.cellname))
                            return "cellname: string expected";
                    return null;
                };

                /**
                 * Creates a MsgTissueInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MsgTissueInfo} MsgTissueInfo
                 */
                MsgTissueInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MsgTissueInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MsgTissueInfo();
                    if (object.tissueId != null)
                        message.tissueId = object.tissueId | 0;
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.opacity != null)
                        message.opacity = Number(object.opacity);
                    if (object.color != null) {
                        if (typeof object.color !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgTissueInfo.color: object expected");
                        message.color = $root.UIBot.UHOR.ProtoBuf.MsgColor.fromObject(object.color);
                    }
                    if (object.vrtPath != null)
                        message.vrtPath = String(object.vrtPath);
                    if (object.visibility != null)
                        message.visibility = Boolean(object.visibility);
                    if (object.isLocked != null)
                        message.isLocked = Boolean(object.isLocked);
                    if (object.deleteEnabled != null)
                        message.deleteEnabled = Boolean(object.deleteEnabled);
                    if (object.isSelected != null)
                        message.isSelected = Boolean(object.isSelected);
                    if (object.isDisplayStatistic != null)
                        message.isDisplayStatistic = Boolean(object.isDisplayStatistic);
                    if (object.isUseVrt != null)
                        message.isUseVrt = Boolean(object.isUseVrt);
                    if (object.tissueType != null)
                        message.tissueType = object.tissueType | 0;
                    if (object.tissueBasis != null)
                        message.tissueBasis = String(object.tissueBasis);
                    if (object.appInfo != null)
                        if (typeof object.appInfo === "string")
                            $util.base64.decode(object.appInfo, message.appInfo = $util.newBuffer($util.base64.length(object.appInfo)), 0);
                        else if (object.appInfo.length >= 0)
                            message.appInfo = object.appInfo;
                    if (object.tissueComments != null)
                        message.tissueComments = String(object.tissueComments);
                    if (object.tissueRefUidVisible != null)
                        message.tissueRefUidVisible = Boolean(object.tissueRefUidVisible);
                    if (object.labels) {
                        if (!Array.isArray(object.labels))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgTissueInfo.labels: array expected");
                        message.labels = [];
                        for (var i = 0; i < object.labels.length; ++i)
                            message.labels[i] = object.labels[i] | 0;
                    }
                    if (object.tissueStatic != null) {
                        if (typeof object.tissueStatic !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgTissueInfo.tissueStatic: object expected");
                        message.tissueStatic = $root.UIBot.UHOR.ProtoBuf.StatisticResult.fromObject(object.tissueStatic);
                    }
                    if (object.stateOnMpr != null)
                        if (typeof object.stateOnMpr === "string")
                            $util.base64.decode(object.stateOnMpr, message.stateOnMpr = $util.newBuffer($util.base64.length(object.stateOnMpr)), 0);
                        else if (object.stateOnMpr.length >= 0)
                            message.stateOnMpr = object.stateOnMpr;
                    if (object.stateOnVr != null)
                        if (typeof object.stateOnVr === "string")
                            $util.base64.decode(object.stateOnVr, message.stateOnVr = $util.newBuffer($util.base64.length(object.stateOnVr)), 0);
                        else if (object.stateOnVr.length >= 0)
                            message.stateOnVr = object.stateOnVr;
                    if (object.cellname != null)
                        message.cellname = String(object.cellname);
                    return message;
                };

                /**
                 * Creates a plain object from a MsgTissueInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MsgTissueInfo} message MsgTissueInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgTissueInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.labels = [];
                    if (options.defaults) {
                        object.tissueId = 0;
                        object.name = "";
                        object.opacity = 0;
                        object.color = null;
                        object.vrtPath = "";
                        object.visibility = false;
                        object.isLocked = false;
                        object.deleteEnabled = false;
                        object.isSelected = false;
                        object.isDisplayStatistic = false;
                        object.isUseVrt = false;
                        object.tissueType = 0;
                        object.tissueBasis = "";
                        if (options.bytes === String)
                            object.appInfo = "";
                        else {
                            object.appInfo = [];
                            if (options.bytes !== Array)
                                object.appInfo = $util.newBuffer(object.appInfo);
                        }
                        object.tissueComments = "";
                        object.tissueRefUidVisible = false;
                        object.tissueStatic = null;
                        if (options.bytes === String)
                            object.stateOnMpr = "";
                        else {
                            object.stateOnMpr = [];
                            if (options.bytes !== Array)
                                object.stateOnMpr = $util.newBuffer(object.stateOnMpr);
                        }
                        if (options.bytes === String)
                            object.stateOnVr = "";
                        else {
                            object.stateOnVr = [];
                            if (options.bytes !== Array)
                                object.stateOnVr = $util.newBuffer(object.stateOnVr);
                        }
                        object.cellname = "";
                    }
                    if (message.tissueId != null && message.hasOwnProperty("tissueId"))
                        object.tissueId = message.tissueId;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.opacity != null && message.hasOwnProperty("opacity"))
                        object.opacity = options.json && !isFinite(message.opacity) ? String(message.opacity) : message.opacity;
                    if (message.color != null && message.hasOwnProperty("color"))
                        object.color = $root.UIBot.UHOR.ProtoBuf.MsgColor.toObject(message.color, options);
                    if (message.vrtPath != null && message.hasOwnProperty("vrtPath"))
                        object.vrtPath = message.vrtPath;
                    if (message.visibility != null && message.hasOwnProperty("visibility"))
                        object.visibility = message.visibility;
                    if (message.isLocked != null && message.hasOwnProperty("isLocked"))
                        object.isLocked = message.isLocked;
                    if (message.deleteEnabled != null && message.hasOwnProperty("deleteEnabled"))
                        object.deleteEnabled = message.deleteEnabled;
                    if (message.isSelected != null && message.hasOwnProperty("isSelected"))
                        object.isSelected = message.isSelected;
                    if (message.isDisplayStatistic != null && message.hasOwnProperty("isDisplayStatistic"))
                        object.isDisplayStatistic = message.isDisplayStatistic;
                    if (message.isUseVrt != null && message.hasOwnProperty("isUseVrt"))
                        object.isUseVrt = message.isUseVrt;
                    if (message.tissueType != null && message.hasOwnProperty("tissueType"))
                        object.tissueType = message.tissueType;
                    if (message.tissueBasis != null && message.hasOwnProperty("tissueBasis"))
                        object.tissueBasis = message.tissueBasis;
                    if (message.appInfo != null && message.hasOwnProperty("appInfo"))
                        object.appInfo = options.bytes === String ? $util.base64.encode(message.appInfo, 0, message.appInfo.length) : options.bytes === Array ? Array.prototype.slice.call(message.appInfo) : message.appInfo;
                    if (message.tissueComments != null && message.hasOwnProperty("tissueComments"))
                        object.tissueComments = message.tissueComments;
                    if (message.tissueRefUidVisible != null && message.hasOwnProperty("tissueRefUidVisible"))
                        object.tissueRefUidVisible = message.tissueRefUidVisible;
                    if (message.labels && message.labels.length) {
                        object.labels = [];
                        for (var j = 0; j < message.labels.length; ++j)
                            object.labels[j] = message.labels[j];
                    }
                    if (message.tissueStatic != null && message.hasOwnProperty("tissueStatic"))
                        object.tissueStatic = $root.UIBot.UHOR.ProtoBuf.StatisticResult.toObject(message.tissueStatic, options);
                    if (message.stateOnMpr != null && message.hasOwnProperty("stateOnMpr"))
                        object.stateOnMpr = options.bytes === String ? $util.base64.encode(message.stateOnMpr, 0, message.stateOnMpr.length) : options.bytes === Array ? Array.prototype.slice.call(message.stateOnMpr) : message.stateOnMpr;
                    if (message.stateOnVr != null && message.hasOwnProperty("stateOnVr"))
                        object.stateOnVr = options.bytes === String ? $util.base64.encode(message.stateOnVr, 0, message.stateOnVr.length) : options.bytes === Array ? Array.prototype.slice.call(message.stateOnVr) : message.stateOnVr;
                    if (message.cellname != null && message.hasOwnProperty("cellname"))
                        object.cellname = message.cellname;
                    return object;
                };

                /**
                 * Converts this MsgTissueInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgTissueInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MsgTissueInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MsgTissueInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MsgTissueInfo";
                };

                return MsgTissueInfo;
            })();

            ProtoBuf.MsgTissueList = (function() {

                /**
                 * Properties of a MsgTissueList.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMsgTissueList
                 * @property {string|null} [seriesuid] MsgTissueList seriesuid
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IMsgTissueInfo>|null} [tissueList] MsgTissueList tissueList
                 */

                /**
                 * Constructs a new MsgTissueList.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MsgTissueList.
                 * @implements IMsgTissueList
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMsgTissueList=} [properties] Properties to set
                 */
                function MsgTissueList(properties) {
                    this.tissueList = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MsgTissueList seriesuid.
                 * @member {string} seriesuid
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueList
                 * @instance
                 */
                MsgTissueList.prototype.seriesuid = "";

                /**
                 * MsgTissueList tissueList.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IMsgTissueInfo>} tissueList
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueList
                 * @instance
                 */
                MsgTissueList.prototype.tissueList = $util.emptyArray;

                /**
                 * Creates a new MsgTissueList instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgTissueList=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MsgTissueList} MsgTissueList instance
                 */
                MsgTissueList.create = function create(properties) {
                    return new MsgTissueList(properties);
                };

                /**
                 * Encodes the specified MsgTissueList message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgTissueList.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgTissueList} message MsgTissueList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgTissueList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.seriesuid != null && Object.hasOwnProperty.call(message, "seriesuid"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.seriesuid);
                    if (message.tissueList != null && message.tissueList.length)
                        for (var i = 0; i < message.tissueList.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.MsgTissueInfo.encode(message.tissueList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MsgTissueList message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgTissueList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgTissueList} message MsgTissueList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgTissueList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MsgTissueList message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MsgTissueList} MsgTissueList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgTissueList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MsgTissueList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.seriesuid = reader.string();
                                break;
                            }
                        case 2: {
                                if (!(message.tissueList && message.tissueList.length))
                                    message.tissueList = [];
                                message.tissueList.push($root.UIBot.UHOR.ProtoBuf.MsgTissueInfo.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MsgTissueList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MsgTissueList} MsgTissueList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgTissueList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MsgTissueList message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgTissueList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.seriesuid != null && message.hasOwnProperty("seriesuid"))
                        if (!$util.isString(message.seriesuid))
                            return "seriesuid: string expected";
                    if (message.tissueList != null && message.hasOwnProperty("tissueList")) {
                        if (!Array.isArray(message.tissueList))
                            return "tissueList: array expected";
                        for (var i = 0; i < message.tissueList.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.MsgTissueInfo.verify(message.tissueList[i]);
                            if (error)
                                return "tissueList." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MsgTissueList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MsgTissueList} MsgTissueList
                 */
                MsgTissueList.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MsgTissueList)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MsgTissueList();
                    if (object.seriesuid != null)
                        message.seriesuid = String(object.seriesuid);
                    if (object.tissueList) {
                        if (!Array.isArray(object.tissueList))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgTissueList.tissueList: array expected");
                        message.tissueList = [];
                        for (var i = 0; i < object.tissueList.length; ++i) {
                            if (typeof object.tissueList[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MsgTissueList.tissueList: object expected");
                            message.tissueList[i] = $root.UIBot.UHOR.ProtoBuf.MsgTissueInfo.fromObject(object.tissueList[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MsgTissueList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MsgTissueList} message MsgTissueList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgTissueList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.tissueList = [];
                    if (options.defaults)
                        object.seriesuid = "";
                    if (message.seriesuid != null && message.hasOwnProperty("seriesuid"))
                        object.seriesuid = message.seriesuid;
                    if (message.tissueList && message.tissueList.length) {
                        object.tissueList = [];
                        for (var j = 0; j < message.tissueList.length; ++j)
                            object.tissueList[j] = $root.UIBot.UHOR.ProtoBuf.MsgTissueInfo.toObject(message.tissueList[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MsgTissueList to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgTissueList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MsgTissueList
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MsgTissueList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MsgTissueList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MsgTissueList";
                };

                return MsgTissueList;
            })();

            ProtoBuf.MsgVOIInfo = (function() {

                /**
                 * Properties of a MsgVOIInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMsgVOIInfo
                 * @property {string} maskID MsgVOIInfo maskID
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IMsgPointList>|null} [outerlinePointList] MsgVOIInfo outerlinePointList
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IMsgPointList>|null} [innerlinePointList] MsgVOIInfo innerlinePointList
                 * @property {string|null} [unit] MsgVOIInfo unit
                 * @property {boolean|null} [isVisible] MsgVOIInfo isVisible
                 * @property {number|null} [opacity] MsgVOIInfo opacity
                 * @property {UIBot.UHOR.ProtoBuf.IMsgColor|null} [color] MsgVOIInfo color
                 * @property {string|null} [volumeUID] MsgVOIInfo volumeUID
                 */

                /**
                 * Constructs a new MsgVOIInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MsgVOIInfo.
                 * @implements IMsgVOIInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMsgVOIInfo=} [properties] Properties to set
                 */
                function MsgVOIInfo(properties) {
                    this.outerlinePointList = [];
                    this.innerlinePointList = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MsgVOIInfo maskID.
                 * @member {string} maskID
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfo
                 * @instance
                 */
                MsgVOIInfo.prototype.maskID = "";

                /**
                 * MsgVOIInfo outerlinePointList.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IMsgPointList>} outerlinePointList
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfo
                 * @instance
                 */
                MsgVOIInfo.prototype.outerlinePointList = $util.emptyArray;

                /**
                 * MsgVOIInfo innerlinePointList.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IMsgPointList>} innerlinePointList
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfo
                 * @instance
                 */
                MsgVOIInfo.prototype.innerlinePointList = $util.emptyArray;

                /**
                 * MsgVOIInfo unit.
                 * @member {string} unit
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfo
                 * @instance
                 */
                MsgVOIInfo.prototype.unit = "";

                /**
                 * MsgVOIInfo isVisible.
                 * @member {boolean} isVisible
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfo
                 * @instance
                 */
                MsgVOIInfo.prototype.isVisible = false;

                /**
                 * MsgVOIInfo opacity.
                 * @member {number} opacity
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfo
                 * @instance
                 */
                MsgVOIInfo.prototype.opacity = 0;

                /**
                 * MsgVOIInfo color.
                 * @member {UIBot.UHOR.ProtoBuf.IMsgColor|null|undefined} color
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfo
                 * @instance
                 */
                MsgVOIInfo.prototype.color = null;

                /**
                 * MsgVOIInfo volumeUID.
                 * @member {string} volumeUID
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfo
                 * @instance
                 */
                MsgVOIInfo.prototype.volumeUID = "";

                /**
                 * Creates a new MsgVOIInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgVOIInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MsgVOIInfo} MsgVOIInfo instance
                 */
                MsgVOIInfo.create = function create(properties) {
                    return new MsgVOIInfo(properties);
                };

                /**
                 * Encodes the specified MsgVOIInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgVOIInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgVOIInfo} message MsgVOIInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgVOIInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.maskID);
                    if (message.outerlinePointList != null && message.outerlinePointList.length)
                        for (var i = 0; i < message.outerlinePointList.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.MsgPointList.encode(message.outerlinePointList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.innerlinePointList != null && message.innerlinePointList.length)
                        for (var i = 0; i < message.innerlinePointList.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.MsgPointList.encode(message.innerlinePointList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.unit != null && Object.hasOwnProperty.call(message, "unit"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.unit);
                    if (message.isVisible != null && Object.hasOwnProperty.call(message, "isVisible"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isVisible);
                    if (message.opacity != null && Object.hasOwnProperty.call(message, "opacity"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.opacity);
                    if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                        $root.UIBot.UHOR.ProtoBuf.MsgColor.encode(message.color, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.volumeUID != null && Object.hasOwnProperty.call(message, "volumeUID"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.volumeUID);
                    return writer;
                };

                /**
                 * Encodes the specified MsgVOIInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgVOIInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgVOIInfo} message MsgVOIInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgVOIInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MsgVOIInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MsgVOIInfo} MsgVOIInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgVOIInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MsgVOIInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.maskID = reader.string();
                                break;
                            }
                        case 2: {
                                if (!(message.outerlinePointList && message.outerlinePointList.length))
                                    message.outerlinePointList = [];
                                message.outerlinePointList.push($root.UIBot.UHOR.ProtoBuf.MsgPointList.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                if (!(message.innerlinePointList && message.innerlinePointList.length))
                                    message.innerlinePointList = [];
                                message.innerlinePointList.push($root.UIBot.UHOR.ProtoBuf.MsgPointList.decode(reader, reader.uint32()));
                                break;
                            }
                        case 4: {
                                message.unit = reader.string();
                                break;
                            }
                        case 5: {
                                message.isVisible = reader.bool();
                                break;
                            }
                        case 6: {
                                message.opacity = reader.double();
                                break;
                            }
                        case 7: {
                                message.color = $root.UIBot.UHOR.ProtoBuf.MsgColor.decode(reader, reader.uint32());
                                break;
                            }
                        case 8: {
                                message.volumeUID = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("maskID"))
                        throw $util.ProtocolError("missing required 'maskID'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a MsgVOIInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MsgVOIInfo} MsgVOIInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgVOIInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MsgVOIInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgVOIInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.maskID))
                        return "maskID: string expected";
                    if (message.outerlinePointList != null && message.hasOwnProperty("outerlinePointList")) {
                        if (!Array.isArray(message.outerlinePointList))
                            return "outerlinePointList: array expected";
                        for (var i = 0; i < message.outerlinePointList.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.MsgPointList.verify(message.outerlinePointList[i]);
                            if (error)
                                return "outerlinePointList." + error;
                        }
                    }
                    if (message.innerlinePointList != null && message.hasOwnProperty("innerlinePointList")) {
                        if (!Array.isArray(message.innerlinePointList))
                            return "innerlinePointList: array expected";
                        for (var i = 0; i < message.innerlinePointList.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.MsgPointList.verify(message.innerlinePointList[i]);
                            if (error)
                                return "innerlinePointList." + error;
                        }
                    }
                    if (message.unit != null && message.hasOwnProperty("unit"))
                        if (!$util.isString(message.unit))
                            return "unit: string expected";
                    if (message.isVisible != null && message.hasOwnProperty("isVisible"))
                        if (typeof message.isVisible !== "boolean")
                            return "isVisible: boolean expected";
                    if (message.opacity != null && message.hasOwnProperty("opacity"))
                        if (typeof message.opacity !== "number")
                            return "opacity: number expected";
                    if (message.color != null && message.hasOwnProperty("color")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.MsgColor.verify(message.color);
                        if (error)
                            return "color." + error;
                    }
                    if (message.volumeUID != null && message.hasOwnProperty("volumeUID"))
                        if (!$util.isString(message.volumeUID))
                            return "volumeUID: string expected";
                    return null;
                };

                /**
                 * Creates a MsgVOIInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MsgVOIInfo} MsgVOIInfo
                 */
                MsgVOIInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MsgVOIInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MsgVOIInfo();
                    if (object.maskID != null)
                        message.maskID = String(object.maskID);
                    if (object.outerlinePointList) {
                        if (!Array.isArray(object.outerlinePointList))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgVOIInfo.outerlinePointList: array expected");
                        message.outerlinePointList = [];
                        for (var i = 0; i < object.outerlinePointList.length; ++i) {
                            if (typeof object.outerlinePointList[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MsgVOIInfo.outerlinePointList: object expected");
                            message.outerlinePointList[i] = $root.UIBot.UHOR.ProtoBuf.MsgPointList.fromObject(object.outerlinePointList[i]);
                        }
                    }
                    if (object.innerlinePointList) {
                        if (!Array.isArray(object.innerlinePointList))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgVOIInfo.innerlinePointList: array expected");
                        message.innerlinePointList = [];
                        for (var i = 0; i < object.innerlinePointList.length; ++i) {
                            if (typeof object.innerlinePointList[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MsgVOIInfo.innerlinePointList: object expected");
                            message.innerlinePointList[i] = $root.UIBot.UHOR.ProtoBuf.MsgPointList.fromObject(object.innerlinePointList[i]);
                        }
                    }
                    if (object.unit != null)
                        message.unit = String(object.unit);
                    if (object.isVisible != null)
                        message.isVisible = Boolean(object.isVisible);
                    if (object.opacity != null)
                        message.opacity = Number(object.opacity);
                    if (object.color != null) {
                        if (typeof object.color !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgVOIInfo.color: object expected");
                        message.color = $root.UIBot.UHOR.ProtoBuf.MsgColor.fromObject(object.color);
                    }
                    if (object.volumeUID != null)
                        message.volumeUID = String(object.volumeUID);
                    return message;
                };

                /**
                 * Creates a plain object from a MsgVOIInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MsgVOIInfo} message MsgVOIInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgVOIInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.outerlinePointList = [];
                        object.innerlinePointList = [];
                    }
                    if (options.defaults) {
                        object.maskID = "";
                        object.unit = "";
                        object.isVisible = false;
                        object.opacity = 0;
                        object.color = null;
                        object.volumeUID = "";
                    }
                    if (message.maskID != null && message.hasOwnProperty("maskID"))
                        object.maskID = message.maskID;
                    if (message.outerlinePointList && message.outerlinePointList.length) {
                        object.outerlinePointList = [];
                        for (var j = 0; j < message.outerlinePointList.length; ++j)
                            object.outerlinePointList[j] = $root.UIBot.UHOR.ProtoBuf.MsgPointList.toObject(message.outerlinePointList[j], options);
                    }
                    if (message.innerlinePointList && message.innerlinePointList.length) {
                        object.innerlinePointList = [];
                        for (var j = 0; j < message.innerlinePointList.length; ++j)
                            object.innerlinePointList[j] = $root.UIBot.UHOR.ProtoBuf.MsgPointList.toObject(message.innerlinePointList[j], options);
                    }
                    if (message.unit != null && message.hasOwnProperty("unit"))
                        object.unit = message.unit;
                    if (message.isVisible != null && message.hasOwnProperty("isVisible"))
                        object.isVisible = message.isVisible;
                    if (message.opacity != null && message.hasOwnProperty("opacity"))
                        object.opacity = options.json && !isFinite(message.opacity) ? String(message.opacity) : message.opacity;
                    if (message.color != null && message.hasOwnProperty("color"))
                        object.color = $root.UIBot.UHOR.ProtoBuf.MsgColor.toObject(message.color, options);
                    if (message.volumeUID != null && message.hasOwnProperty("volumeUID"))
                        object.volumeUID = message.volumeUID;
                    return object;
                };

                /**
                 * Converts this MsgVOIInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgVOIInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MsgVOIInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MsgVOIInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MsgVOIInfo";
                };

                return MsgVOIInfo;
            })();

            ProtoBuf.MsgVOIInfos = (function() {

                /**
                 * Properties of a MsgVOIInfos.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMsgVOIInfos
                 * @property {number} count MsgVOIInfos count
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IMsgVOIInfo>|null} [voiInfoList] MsgVOIInfos voiInfoList
                 */

                /**
                 * Constructs a new MsgVOIInfos.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MsgVOIInfos.
                 * @implements IMsgVOIInfos
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMsgVOIInfos=} [properties] Properties to set
                 */
                function MsgVOIInfos(properties) {
                    this.voiInfoList = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MsgVOIInfos count.
                 * @member {number} count
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfos
                 * @instance
                 */
                MsgVOIInfos.prototype.count = 0;

                /**
                 * MsgVOIInfos voiInfoList.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IMsgVOIInfo>} voiInfoList
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfos
                 * @instance
                 */
                MsgVOIInfos.prototype.voiInfoList = $util.emptyArray;

                /**
                 * Creates a new MsgVOIInfos instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfos
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgVOIInfos=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MsgVOIInfos} MsgVOIInfos instance
                 */
                MsgVOIInfos.create = function create(properties) {
                    return new MsgVOIInfos(properties);
                };

                /**
                 * Encodes the specified MsgVOIInfos message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgVOIInfos.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfos
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgVOIInfos} message MsgVOIInfos message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgVOIInfos.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.count);
                    if (message.voiInfoList != null && message.voiInfoList.length)
                        for (var i = 0; i < message.voiInfoList.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.MsgVOIInfo.encode(message.voiInfoList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MsgVOIInfos message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgVOIInfos.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfos
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgVOIInfos} message MsgVOIInfos message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgVOIInfos.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MsgVOIInfos message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfos
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MsgVOIInfos} MsgVOIInfos
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgVOIInfos.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MsgVOIInfos();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.count = reader.int32();
                                break;
                            }
                        case 2: {
                                if (!(message.voiInfoList && message.voiInfoList.length))
                                    message.voiInfoList = [];
                                message.voiInfoList.push($root.UIBot.UHOR.ProtoBuf.MsgVOIInfo.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("count"))
                        throw $util.ProtocolError("missing required 'count'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a MsgVOIInfos message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfos
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MsgVOIInfos} MsgVOIInfos
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgVOIInfos.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MsgVOIInfos message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfos
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgVOIInfos.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                    if (message.voiInfoList != null && message.hasOwnProperty("voiInfoList")) {
                        if (!Array.isArray(message.voiInfoList))
                            return "voiInfoList: array expected";
                        for (var i = 0; i < message.voiInfoList.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.MsgVOIInfo.verify(message.voiInfoList[i]);
                            if (error)
                                return "voiInfoList." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MsgVOIInfos message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfos
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MsgVOIInfos} MsgVOIInfos
                 */
                MsgVOIInfos.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MsgVOIInfos)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MsgVOIInfos();
                    if (object.count != null)
                        message.count = object.count | 0;
                    if (object.voiInfoList) {
                        if (!Array.isArray(object.voiInfoList))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgVOIInfos.voiInfoList: array expected");
                        message.voiInfoList = [];
                        for (var i = 0; i < object.voiInfoList.length; ++i) {
                            if (typeof object.voiInfoList[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MsgVOIInfos.voiInfoList: object expected");
                            message.voiInfoList[i] = $root.UIBot.UHOR.ProtoBuf.MsgVOIInfo.fromObject(object.voiInfoList[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MsgVOIInfos message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfos
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MsgVOIInfos} message MsgVOIInfos
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgVOIInfos.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.voiInfoList = [];
                    if (options.defaults)
                        object.count = 0;
                    if (message.count != null && message.hasOwnProperty("count"))
                        object.count = message.count;
                    if (message.voiInfoList && message.voiInfoList.length) {
                        object.voiInfoList = [];
                        for (var j = 0; j < message.voiInfoList.length; ++j)
                            object.voiInfoList[j] = $root.UIBot.UHOR.ProtoBuf.MsgVOIInfo.toObject(message.voiInfoList[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MsgVOIInfos to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfos
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgVOIInfos.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MsgVOIInfos
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MsgVOIInfos
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MsgVOIInfos.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MsgVOIInfos";
                };

                return MsgVOIInfos;
            })();

            ProtoBuf.MessageResult = (function() {

                /**
                 * Properties of a MessageResult.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageResult
                 * @property {boolean|null} [IsSuccess] MessageResult IsSuccess
                 * @property {UIBot.UHOR.ProtoBuf.NeuroErrorCode|null} [ErrorCode] MessageResult ErrorCode
                 * @property {string|null} [Info] MessageResult Info
                 */

                /**
                 * Constructs a new MessageResult.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageResult.
                 * @implements IMessageResult
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageResult=} [properties] Properties to set
                 */
                function MessageResult(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageResult IsSuccess.
                 * @member {boolean} IsSuccess
                 * @memberof UIBot.UHOR.ProtoBuf.MessageResult
                 * @instance
                 */
                MessageResult.prototype.IsSuccess = false;

                /**
                 * MessageResult ErrorCode.
                 * @member {UIBot.UHOR.ProtoBuf.NeuroErrorCode} ErrorCode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageResult
                 * @instance
                 */
                MessageResult.prototype.ErrorCode = 0;

                /**
                 * MessageResult Info.
                 * @member {string} Info
                 * @memberof UIBot.UHOR.ProtoBuf.MessageResult
                 * @instance
                 */
                MessageResult.prototype.Info = "";

                /**
                 * Creates a new MessageResult instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageResult
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageResult=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageResult} MessageResult instance
                 */
                MessageResult.create = function create(properties) {
                    return new MessageResult(properties);
                };

                /**
                 * Encodes the specified MessageResult message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageResult.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageResult
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageResult} message MessageResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageResult.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.IsSuccess != null && Object.hasOwnProperty.call(message, "IsSuccess"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.IsSuccess);
                    if (message.ErrorCode != null && Object.hasOwnProperty.call(message, "ErrorCode"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ErrorCode);
                    if (message.Info != null && Object.hasOwnProperty.call(message, "Info"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.Info);
                    return writer;
                };

                /**
                 * Encodes the specified MessageResult message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageResult.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageResult
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageResult} message MessageResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageResult.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageResult message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageResult} MessageResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageResult.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageResult();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.IsSuccess = reader.bool();
                                break;
                            }
                        case 2: {
                                message.ErrorCode = reader.int32();
                                break;
                            }
                        case 3: {
                                message.Info = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageResult message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageResult} MessageResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageResult.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageResult message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.IsSuccess != null && message.hasOwnProperty("IsSuccess"))
                        if (typeof message.IsSuccess !== "boolean")
                            return "IsSuccess: boolean expected";
                    if (message.ErrorCode != null && message.hasOwnProperty("ErrorCode"))
                        switch (message.ErrorCode) {
                        default:
                            return "ErrorCode: enum value expected";
                        case 0:
                        case 257:
                        case 258:
                        case 259:
                        case 769:
                        case 770:
                        case 1281:
                        case 1282:
                        case 1283:
                        case 1284:
                        case 1285:
                        case 1793:
                        case 1794:
                        case 2305:
                        case 2306:
                        case 2307:
                        case 2308:
                        case 2309:
                        case 2817:
                        case 2818:
                        case 2819:
                        case 8193:
                        case 8194:
                        case 8195:
                        case 8196:
                        case 8197:
                        case 8198:
                        case 8199:
                        case 8200:
                        case 8201:
                        case 8202:
                        case 8203:
                        case 8204:
                        case 8205:
                        case 12289:
                        case 12290:
                        case 12291:
                        case 12292:
                        case 12293:
                        case 12294:
                        case 12295:
                        case 12296:
                        case 12297:
                        case 12301:
                        case 12302:
                        case 16385:
                        case 16386:
                        case 16387:
                        case 16388:
                        case 16389:
                            break;
                        }
                    if (message.Info != null && message.hasOwnProperty("Info"))
                        if (!$util.isString(message.Info))
                            return "Info: string expected";
                    return null;
                };

                /**
                 * Creates a MessageResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageResult} MessageResult
                 */
                MessageResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageResult)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageResult();
                    if (object.IsSuccess != null)
                        message.IsSuccess = Boolean(object.IsSuccess);
                    switch (object.ErrorCode) {
                    default:
                        if (typeof object.ErrorCode === "number") {
                            message.ErrorCode = object.ErrorCode;
                            break;
                        }
                        break;
                    case "Neuro_Success":
                    case 0:
                        message.ErrorCode = 0;
                        break;
                    case "Neuro_Bold_Error":
                    case 257:
                        message.ErrorCode = 257;
                        break;
                    case "Neuro_Bold_Missing_Active_Region_Error":
                    case 258:
                        message.ErrorCode = 258;
                        break;
                    case "Neuro_Bold_Protocol_Info_Error":
                    case 259:
                        message.ErrorCode = 259;
                        break;
                    case "Neuro_DTI_Error":
                    case 769:
                        message.ErrorCode = 769;
                        break;
                    case "Neuro_DTI_Outside_Volume_Error":
                    case 770:
                        message.ErrorCode = 770;
                        break;
                    case "Neuro_Hemorhage_Vessel_Segment_Error":
                    case 1281:
                        message.ErrorCode = 1281;
                        break;
                    case "Neuro_Hemorhage_Hemorrhage_Segment_Error":
                    case 1282:
                        message.ErrorCode = 1282;
                        break;
                    case "Neuro_Hemorhage_Hydroncus_Segment_Error":
                    case 1283:
                        message.ErrorCode = 1283;
                        break;
                    case "Neuro_Hemorhage_Skull_Extraction_Error":
                    case 1284:
                        message.ErrorCode = 1284;
                        break;
                    case "Neuro_Hemorhage_DrainageTube_Extraction_Error":
                    case 1285:
                        message.ErrorCode = 1285;
                        break;
                    case "Neuro_TumorBiopsies_Vessel_Segment_Error":
                    case 1793:
                        message.ErrorCode = 1793;
                        break;
                    case "Neuro_TumorBiopsies_TumorBiopsies_Segment_Error":
                    case 1794:
                        message.ErrorCode = 1794;
                        break;
                    case "Neuro_DBS_Vessel_Segment_Error":
                    case 2305:
                        message.ErrorCode = 2305;
                        break;
                    case "Neuro_DBS_BrainAltlases_Error":
                    case 2306:
                        message.ErrorCode = 2306;
                        break;
                    case "Neuro_DBS_ACPCVolumeUIDMatchCurrentVolumeUID_Error":
                    case 2307:
                        message.ErrorCode = 2307;
                        break;
                    case "Neuro_DBS_CorticalLandmarkCalculate_Error":
                    case 2308:
                        message.ErrorCode = 2308;
                        break;
                    case "Neuro_DBS_EditBrainAtlases_Error":
                    case 2309:
                        message.ErrorCode = 2309;
                        break;
                    case "Neuro_SEEG_Vessel_Segment_Error":
                    case 2817:
                        message.ErrorCode = 2817;
                        break;
                    case "Neuro_SEEG_Cucoloris_Error":
                    case 2818:
                        message.ErrorCode = 2818;
                        break;
                    case "Neuro_SEEG_Brain_Segmentation_Error":
                    case 2819:
                        message.ErrorCode = 2819;
                        break;
                    case "Neuro_Common_Marker_Auto_Add_Nail_Error":
                    case 8193:
                        message.ErrorCode = 8193;
                        break;
                    case "Neuro_Common_Marker_Auto_Add_Sphere_Error":
                    case 8194:
                        message.ErrorCode = 8194;
                        break;
                    case "Neuro_Common_Marker_Add_Marker_Duplicate_Error":
                    case 8195:
                        message.ErrorCode = 8195;
                        break;
                    case "Neuro_Common_Marker_Add_Marker_Limit_Exceeded_Error":
                    case 8196:
                        message.ErrorCode = 8196;
                        break;
                    case "Neuro_Common_ParcellationDKT_Error":
                    case 8197:
                        message.ErrorCode = 8197;
                        break;
                    case "Neuro_Common_BedboardRemovement_Error":
                    case 8198:
                        message.ErrorCode = 8198;
                        break;
                    case "Neuro_Common_NucleiExtract_Error":
                    case 8199:
                        message.ErrorCode = 8199;
                        break;
                    case "Neuro_Common_TissueGrow_Error":
                    case 8200:
                        message.ErrorCode = 8200;
                        break;
                    case "Neuro_Common_MultiPointsConnection_Error":
                    case 8201:
                        message.ErrorCode = 8201;
                        break;
                    case "Neuro_Common_Upload_Error":
                    case 8202:
                        message.ErrorCode = 8202;
                        break;
                    case "Neuro_Common_Upload_Success":
                    case 8203:
                        message.ErrorCode = 8203;
                        break;
                    case "Neuro_Common_No_Exit_User_Error":
                    case 8204:
                        message.ErrorCode = 8204;
                        break;
                    case "Neuro_Common_Could_Not_Connect_Error":
                    case 8205:
                        message.ErrorCode = 8205;
                        break;
                    case "Neuro_DataChecking_Validate_Error":
                    case 12289:
                        message.ErrorCode = 12289;
                        break;
                    case "Neuro_DataChecking_Dicom_Empty_Error":
                    case 12290:
                        message.ErrorCode = 12290;
                        break;
                    case "Neuro_DataChecking_Dicom_Absence_Error":
                    case 12291:
                        message.ErrorCode = 12291;
                        break;
                    case "Neuro_DataChecking_Dicom_Ori_Error":
                    case 12292:
                        message.ErrorCode = 12292;
                        break;
                    case "Neuro_DataChecking_Dicom_Space_Error":
                    case 12293:
                        message.ErrorCode = 12293;
                        break;
                    case "Neuro_DataChecking_Serise_Number_Error":
                    case 12294:
                        message.ErrorCode = 12294;
                        break;
                    case "Neuro_DataChecking_DTI_Missing_Ref_Sequence_Error":
                    case 12295:
                        message.ErrorCode = 12295;
                        break;
                    case "Neuro_DataChecking_BOLD_Missing_Ref_Sequence_Error":
                    case 12296:
                        message.ErrorCode = 12296;
                        break;
                    case "Neuro_DataChecking_Result_Not_Match_Error":
                    case 12297:
                        message.ErrorCode = 12297;
                        break;
                    case "Neuro_DataChecking_Result_Sequence_Error":
                    case 12301:
                        message.ErrorCode = 12301;
                        break;
                    case "Neuro_DataChecking_Load_Series_Error":
                    case 12302:
                        message.ErrorCode = 12302;
                        break;
                    case "Neuro_LoadPlanningResult_OtherApp_Error":
                    case 16385:
                        message.ErrorCode = 16385;
                        break;
                    case "Neuro_LoadPlanningResult_LoadData_Error":
                    case 16386:
                        message.ErrorCode = 16386;
                        break;
                    case "Neuro_SavePlanningResult_SaveData_Success":
                    case 16387:
                        message.ErrorCode = 16387;
                        break;
                    case "Neruo_SavePlanningResult_SaveData_Fail":
                    case 16388:
                        message.ErrorCode = 16388;
                        break;
                    case "Neruo_SavePlanningResult_SaveFiber_TooMuch":
                    case 16389:
                        message.ErrorCode = 16389;
                        break;
                    }
                    if (object.Info != null)
                        message.Info = String(object.Info);
                    return message;
                };

                /**
                 * Creates a plain object from a MessageResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageResult
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageResult} message MessageResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.IsSuccess = false;
                        object.ErrorCode = options.enums === String ? "Neuro_Success" : 0;
                        object.Info = "";
                    }
                    if (message.IsSuccess != null && message.hasOwnProperty("IsSuccess"))
                        object.IsSuccess = message.IsSuccess;
                    if (message.ErrorCode != null && message.hasOwnProperty("ErrorCode"))
                        object.ErrorCode = options.enums === String ? $root.UIBot.UHOR.ProtoBuf.NeuroErrorCode[message.ErrorCode] === undefined ? message.ErrorCode : $root.UIBot.UHOR.ProtoBuf.NeuroErrorCode[message.ErrorCode] : message.ErrorCode;
                    if (message.Info != null && message.hasOwnProperty("Info"))
                        object.Info = message.Info;
                    return object;
                };

                /**
                 * Converts this MessageResult to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageResult
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageResult
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageResult";
                };

                return MessageResult;
            })();

            ProtoBuf.MessageTumorLongestPerpend = (function() {

                /**
                 * Properties of a MessageTumorLongestPerpend.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageTumorLongestPerpend
                 * @property {number|null} [MaskLabel] MessageTumorLongestPerpend MaskLabel
                 * @property {UIBot.UHOR.ProtoBuf.IPoint2DInt|null} [PtLongestStart] MessageTumorLongestPerpend PtLongestStart
                 * @property {UIBot.UHOR.ProtoBuf.IPoint2DInt|null} [PtLongestEnd] MessageTumorLongestPerpend PtLongestEnd
                 * @property {UIBot.UHOR.ProtoBuf.IPoint2DInt|null} [PtPerpendicularStart] MessageTumorLongestPerpend PtPerpendicularStart
                 * @property {UIBot.UHOR.ProtoBuf.IPoint2DInt|null} [PtPerpendicularEnd] MessageTumorLongestPerpend PtPerpendicularEnd
                 * @property {number|null} [fLongestDiameter] MessageTumorLongestPerpend fLongestDiameter
                 * @property {number|null} [fPerpendicularDiameter] MessageTumorLongestPerpend fPerpendicularDiameter
                 */

                /**
                 * Constructs a new MessageTumorLongestPerpend.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageTumorLongestPerpend.
                 * @implements IMessageTumorLongestPerpend
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorLongestPerpend=} [properties] Properties to set
                 */
                function MessageTumorLongestPerpend(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageTumorLongestPerpend MaskLabel.
                 * @member {number} MaskLabel
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend
                 * @instance
                 */
                MessageTumorLongestPerpend.prototype.MaskLabel = 0;

                /**
                 * MessageTumorLongestPerpend PtLongestStart.
                 * @member {UIBot.UHOR.ProtoBuf.IPoint2DInt|null|undefined} PtLongestStart
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend
                 * @instance
                 */
                MessageTumorLongestPerpend.prototype.PtLongestStart = null;

                /**
                 * MessageTumorLongestPerpend PtLongestEnd.
                 * @member {UIBot.UHOR.ProtoBuf.IPoint2DInt|null|undefined} PtLongestEnd
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend
                 * @instance
                 */
                MessageTumorLongestPerpend.prototype.PtLongestEnd = null;

                /**
                 * MessageTumorLongestPerpend PtPerpendicularStart.
                 * @member {UIBot.UHOR.ProtoBuf.IPoint2DInt|null|undefined} PtPerpendicularStart
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend
                 * @instance
                 */
                MessageTumorLongestPerpend.prototype.PtPerpendicularStart = null;

                /**
                 * MessageTumorLongestPerpend PtPerpendicularEnd.
                 * @member {UIBot.UHOR.ProtoBuf.IPoint2DInt|null|undefined} PtPerpendicularEnd
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend
                 * @instance
                 */
                MessageTumorLongestPerpend.prototype.PtPerpendicularEnd = null;

                /**
                 * MessageTumorLongestPerpend fLongestDiameter.
                 * @member {number} fLongestDiameter
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend
                 * @instance
                 */
                MessageTumorLongestPerpend.prototype.fLongestDiameter = 0;

                /**
                 * MessageTumorLongestPerpend fPerpendicularDiameter.
                 * @member {number} fPerpendicularDiameter
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend
                 * @instance
                 */
                MessageTumorLongestPerpend.prototype.fPerpendicularDiameter = 0;

                /**
                 * Creates a new MessageTumorLongestPerpend instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorLongestPerpend=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend} MessageTumorLongestPerpend instance
                 */
                MessageTumorLongestPerpend.create = function create(properties) {
                    return new MessageTumorLongestPerpend(properties);
                };

                /**
                 * Encodes the specified MessageTumorLongestPerpend message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorLongestPerpend} message MessageTumorLongestPerpend message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTumorLongestPerpend.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.MaskLabel != null && Object.hasOwnProperty.call(message, "MaskLabel"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.MaskLabel);
                    if (message.PtLongestStart != null && Object.hasOwnProperty.call(message, "PtLongestStart"))
                        $root.UIBot.UHOR.ProtoBuf.Point2DInt.encode(message.PtLongestStart, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.PtLongestEnd != null && Object.hasOwnProperty.call(message, "PtLongestEnd"))
                        $root.UIBot.UHOR.ProtoBuf.Point2DInt.encode(message.PtLongestEnd, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.PtPerpendicularStart != null && Object.hasOwnProperty.call(message, "PtPerpendicularStart"))
                        $root.UIBot.UHOR.ProtoBuf.Point2DInt.encode(message.PtPerpendicularStart, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.PtPerpendicularEnd != null && Object.hasOwnProperty.call(message, "PtPerpendicularEnd"))
                        $root.UIBot.UHOR.ProtoBuf.Point2DInt.encode(message.PtPerpendicularEnd, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.fLongestDiameter != null && Object.hasOwnProperty.call(message, "fLongestDiameter"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.fLongestDiameter);
                    if (message.fPerpendicularDiameter != null && Object.hasOwnProperty.call(message, "fPerpendicularDiameter"))
                        writer.uint32(/* id 7, wireType 1 =*/57).double(message.fPerpendicularDiameter);
                    return writer;
                };

                /**
                 * Encodes the specified MessageTumorLongestPerpend message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorLongestPerpend} message MessageTumorLongestPerpend message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTumorLongestPerpend.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageTumorLongestPerpend message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend} MessageTumorLongestPerpend
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTumorLongestPerpend.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.MaskLabel = reader.int32();
                                break;
                            }
                        case 2: {
                                message.PtLongestStart = $root.UIBot.UHOR.ProtoBuf.Point2DInt.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.PtLongestEnd = $root.UIBot.UHOR.ProtoBuf.Point2DInt.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.PtPerpendicularStart = $root.UIBot.UHOR.ProtoBuf.Point2DInt.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.PtPerpendicularEnd = $root.UIBot.UHOR.ProtoBuf.Point2DInt.decode(reader, reader.uint32());
                                break;
                            }
                        case 6: {
                                message.fLongestDiameter = reader.double();
                                break;
                            }
                        case 7: {
                                message.fPerpendicularDiameter = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageTumorLongestPerpend message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend} MessageTumorLongestPerpend
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTumorLongestPerpend.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageTumorLongestPerpend message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageTumorLongestPerpend.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.MaskLabel != null && message.hasOwnProperty("MaskLabel"))
                        if (!$util.isInteger(message.MaskLabel))
                            return "MaskLabel: integer expected";
                    if (message.PtLongestStart != null && message.hasOwnProperty("PtLongestStart")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.Point2DInt.verify(message.PtLongestStart);
                        if (error)
                            return "PtLongestStart." + error;
                    }
                    if (message.PtLongestEnd != null && message.hasOwnProperty("PtLongestEnd")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.Point2DInt.verify(message.PtLongestEnd);
                        if (error)
                            return "PtLongestEnd." + error;
                    }
                    if (message.PtPerpendicularStart != null && message.hasOwnProperty("PtPerpendicularStart")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.Point2DInt.verify(message.PtPerpendicularStart);
                        if (error)
                            return "PtPerpendicularStart." + error;
                    }
                    if (message.PtPerpendicularEnd != null && message.hasOwnProperty("PtPerpendicularEnd")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.Point2DInt.verify(message.PtPerpendicularEnd);
                        if (error)
                            return "PtPerpendicularEnd." + error;
                    }
                    if (message.fLongestDiameter != null && message.hasOwnProperty("fLongestDiameter"))
                        if (typeof message.fLongestDiameter !== "number")
                            return "fLongestDiameter: number expected";
                    if (message.fPerpendicularDiameter != null && message.hasOwnProperty("fPerpendicularDiameter"))
                        if (typeof message.fPerpendicularDiameter !== "number")
                            return "fPerpendicularDiameter: number expected";
                    return null;
                };

                /**
                 * Creates a MessageTumorLongestPerpend message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend} MessageTumorLongestPerpend
                 */
                MessageTumorLongestPerpend.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend();
                    if (object.MaskLabel != null)
                        message.MaskLabel = object.MaskLabel | 0;
                    if (object.PtLongestStart != null) {
                        if (typeof object.PtLongestStart !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend.PtLongestStart: object expected");
                        message.PtLongestStart = $root.UIBot.UHOR.ProtoBuf.Point2DInt.fromObject(object.PtLongestStart);
                    }
                    if (object.PtLongestEnd != null) {
                        if (typeof object.PtLongestEnd !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend.PtLongestEnd: object expected");
                        message.PtLongestEnd = $root.UIBot.UHOR.ProtoBuf.Point2DInt.fromObject(object.PtLongestEnd);
                    }
                    if (object.PtPerpendicularStart != null) {
                        if (typeof object.PtPerpendicularStart !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend.PtPerpendicularStart: object expected");
                        message.PtPerpendicularStart = $root.UIBot.UHOR.ProtoBuf.Point2DInt.fromObject(object.PtPerpendicularStart);
                    }
                    if (object.PtPerpendicularEnd != null) {
                        if (typeof object.PtPerpendicularEnd !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend.PtPerpendicularEnd: object expected");
                        message.PtPerpendicularEnd = $root.UIBot.UHOR.ProtoBuf.Point2DInt.fromObject(object.PtPerpendicularEnd);
                    }
                    if (object.fLongestDiameter != null)
                        message.fLongestDiameter = Number(object.fLongestDiameter);
                    if (object.fPerpendicularDiameter != null)
                        message.fPerpendicularDiameter = Number(object.fPerpendicularDiameter);
                    return message;
                };

                /**
                 * Creates a plain object from a MessageTumorLongestPerpend message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend} message MessageTumorLongestPerpend
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageTumorLongestPerpend.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.MaskLabel = 0;
                        object.PtLongestStart = null;
                        object.PtLongestEnd = null;
                        object.PtPerpendicularStart = null;
                        object.PtPerpendicularEnd = null;
                        object.fLongestDiameter = 0;
                        object.fPerpendicularDiameter = 0;
                    }
                    if (message.MaskLabel != null && message.hasOwnProperty("MaskLabel"))
                        object.MaskLabel = message.MaskLabel;
                    if (message.PtLongestStart != null && message.hasOwnProperty("PtLongestStart"))
                        object.PtLongestStart = $root.UIBot.UHOR.ProtoBuf.Point2DInt.toObject(message.PtLongestStart, options);
                    if (message.PtLongestEnd != null && message.hasOwnProperty("PtLongestEnd"))
                        object.PtLongestEnd = $root.UIBot.UHOR.ProtoBuf.Point2DInt.toObject(message.PtLongestEnd, options);
                    if (message.PtPerpendicularStart != null && message.hasOwnProperty("PtPerpendicularStart"))
                        object.PtPerpendicularStart = $root.UIBot.UHOR.ProtoBuf.Point2DInt.toObject(message.PtPerpendicularStart, options);
                    if (message.PtPerpendicularEnd != null && message.hasOwnProperty("PtPerpendicularEnd"))
                        object.PtPerpendicularEnd = $root.UIBot.UHOR.ProtoBuf.Point2DInt.toObject(message.PtPerpendicularEnd, options);
                    if (message.fLongestDiameter != null && message.hasOwnProperty("fLongestDiameter"))
                        object.fLongestDiameter = options.json && !isFinite(message.fLongestDiameter) ? String(message.fLongestDiameter) : message.fLongestDiameter;
                    if (message.fPerpendicularDiameter != null && message.hasOwnProperty("fPerpendicularDiameter"))
                        object.fPerpendicularDiameter = options.json && !isFinite(message.fPerpendicularDiameter) ? String(message.fPerpendicularDiameter) : message.fPerpendicularDiameter;
                    return object;
                };

                /**
                 * Converts this MessageTumorLongestPerpend to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageTumorLongestPerpend.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageTumorLongestPerpend
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageTumorLongestPerpend.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend";
                };

                return MessageTumorLongestPerpend;
            })();

            ProtoBuf.MessageTumorLongestPerpendList = (function() {

                /**
                 * Properties of a MessageTumorLongestPerpendList.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageTumorLongestPerpendList
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IMessageTumorLongestPerpend>|null} [item] MessageTumorLongestPerpendList item
                 */

                /**
                 * Constructs a new MessageTumorLongestPerpendList.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageTumorLongestPerpendList.
                 * @implements IMessageTumorLongestPerpendList
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorLongestPerpendList=} [properties] Properties to set
                 */
                function MessageTumorLongestPerpendList(properties) {
                    this.item = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageTumorLongestPerpendList item.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IMessageTumorLongestPerpend>} item
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList
                 * @instance
                 */
                MessageTumorLongestPerpendList.prototype.item = $util.emptyArray;

                /**
                 * Creates a new MessageTumorLongestPerpendList instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorLongestPerpendList=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList} MessageTumorLongestPerpendList instance
                 */
                MessageTumorLongestPerpendList.create = function create(properties) {
                    return new MessageTumorLongestPerpendList(properties);
                };

                /**
                 * Encodes the specified MessageTumorLongestPerpendList message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorLongestPerpendList} message MessageTumorLongestPerpendList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTumorLongestPerpendList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.item != null && message.item.length)
                        for (var i = 0; i < message.item.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend.encode(message.item[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageTumorLongestPerpendList message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorLongestPerpendList} message MessageTumorLongestPerpendList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTumorLongestPerpendList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageTumorLongestPerpendList message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList} MessageTumorLongestPerpendList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTumorLongestPerpendList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.item && message.item.length))
                                    message.item = [];
                                message.item.push($root.UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageTumorLongestPerpendList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList} MessageTumorLongestPerpendList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTumorLongestPerpendList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageTumorLongestPerpendList message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageTumorLongestPerpendList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.item != null && message.hasOwnProperty("item")) {
                        if (!Array.isArray(message.item))
                            return "item: array expected";
                        for (var i = 0; i < message.item.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend.verify(message.item[i]);
                            if (error)
                                return "item." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MessageTumorLongestPerpendList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList} MessageTumorLongestPerpendList
                 */
                MessageTumorLongestPerpendList.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList();
                    if (object.item) {
                        if (!Array.isArray(object.item))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList.item: array expected");
                        message.item = [];
                        for (var i = 0; i < object.item.length; ++i) {
                            if (typeof object.item[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList.item: object expected");
                            message.item[i] = $root.UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend.fromObject(object.item[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageTumorLongestPerpendList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList} message MessageTumorLongestPerpendList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageTumorLongestPerpendList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.item = [];
                    if (message.item && message.item.length) {
                        object.item = [];
                        for (var j = 0; j < message.item.length; ++j)
                            object.item[j] = $root.UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpend.toObject(message.item[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MessageTumorLongestPerpendList to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageTumorLongestPerpendList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageTumorLongestPerpendList
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageTumorLongestPerpendList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageTumorLongestPerpendList";
                };

                return MessageTumorLongestPerpendList;
            })();

            ProtoBuf.MsgLayerFusionData = (function() {

                /**
                 * Properties of a MsgLayerFusionData.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMsgLayerFusionData
                 * @property {string} LayerName MsgLayerFusionData LayerName
                 * @property {boolean|null} [IsVisible] MsgLayerFusionData IsVisible
                 * @property {number|null} [BlendRatio] MsgLayerFusionData BlendRatio
                 * @property {boolean|null} [IsSelected] MsgLayerFusionData IsSelected
                 */

                /**
                 * Constructs a new MsgLayerFusionData.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MsgLayerFusionData.
                 * @implements IMsgLayerFusionData
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMsgLayerFusionData=} [properties] Properties to set
                 */
                function MsgLayerFusionData(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MsgLayerFusionData LayerName.
                 * @member {string} LayerName
                 * @memberof UIBot.UHOR.ProtoBuf.MsgLayerFusionData
                 * @instance
                 */
                MsgLayerFusionData.prototype.LayerName = "";

                /**
                 * MsgLayerFusionData IsVisible.
                 * @member {boolean} IsVisible
                 * @memberof UIBot.UHOR.ProtoBuf.MsgLayerFusionData
                 * @instance
                 */
                MsgLayerFusionData.prototype.IsVisible = false;

                /**
                 * MsgLayerFusionData BlendRatio.
                 * @member {number} BlendRatio
                 * @memberof UIBot.UHOR.ProtoBuf.MsgLayerFusionData
                 * @instance
                 */
                MsgLayerFusionData.prototype.BlendRatio = 0;

                /**
                 * MsgLayerFusionData IsSelected.
                 * @member {boolean} IsSelected
                 * @memberof UIBot.UHOR.ProtoBuf.MsgLayerFusionData
                 * @instance
                 */
                MsgLayerFusionData.prototype.IsSelected = false;

                /**
                 * Creates a new MsgLayerFusionData instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MsgLayerFusionData
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgLayerFusionData=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MsgLayerFusionData} MsgLayerFusionData instance
                 */
                MsgLayerFusionData.create = function create(properties) {
                    return new MsgLayerFusionData(properties);
                };

                /**
                 * Encodes the specified MsgLayerFusionData message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgLayerFusionData.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgLayerFusionData
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgLayerFusionData} message MsgLayerFusionData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgLayerFusionData.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.LayerName);
                    if (message.IsVisible != null && Object.hasOwnProperty.call(message, "IsVisible"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.IsVisible);
                    if (message.BlendRatio != null && Object.hasOwnProperty.call(message, "BlendRatio"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.BlendRatio);
                    if (message.IsSelected != null && Object.hasOwnProperty.call(message, "IsSelected"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.IsSelected);
                    return writer;
                };

                /**
                 * Encodes the specified MsgLayerFusionData message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgLayerFusionData.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgLayerFusionData
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgLayerFusionData} message MsgLayerFusionData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgLayerFusionData.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MsgLayerFusionData message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgLayerFusionData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MsgLayerFusionData} MsgLayerFusionData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgLayerFusionData.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MsgLayerFusionData();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.LayerName = reader.string();
                                break;
                            }
                        case 2: {
                                message.IsVisible = reader.bool();
                                break;
                            }
                        case 3: {
                                message.BlendRatio = reader.float();
                                break;
                            }
                        case 4: {
                                message.IsSelected = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("LayerName"))
                        throw $util.ProtocolError("missing required 'LayerName'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a MsgLayerFusionData message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgLayerFusionData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MsgLayerFusionData} MsgLayerFusionData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgLayerFusionData.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MsgLayerFusionData message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MsgLayerFusionData
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgLayerFusionData.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.LayerName))
                        return "LayerName: string expected";
                    if (message.IsVisible != null && message.hasOwnProperty("IsVisible"))
                        if (typeof message.IsVisible !== "boolean")
                            return "IsVisible: boolean expected";
                    if (message.BlendRatio != null && message.hasOwnProperty("BlendRatio"))
                        if (typeof message.BlendRatio !== "number")
                            return "BlendRatio: number expected";
                    if (message.IsSelected != null && message.hasOwnProperty("IsSelected"))
                        if (typeof message.IsSelected !== "boolean")
                            return "IsSelected: boolean expected";
                    return null;
                };

                /**
                 * Creates a MsgLayerFusionData message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgLayerFusionData
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MsgLayerFusionData} MsgLayerFusionData
                 */
                MsgLayerFusionData.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MsgLayerFusionData)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MsgLayerFusionData();
                    if (object.LayerName != null)
                        message.LayerName = String(object.LayerName);
                    if (object.IsVisible != null)
                        message.IsVisible = Boolean(object.IsVisible);
                    if (object.BlendRatio != null)
                        message.BlendRatio = Number(object.BlendRatio);
                    if (object.IsSelected != null)
                        message.IsSelected = Boolean(object.IsSelected);
                    return message;
                };

                /**
                 * Creates a plain object from a MsgLayerFusionData message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgLayerFusionData
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MsgLayerFusionData} message MsgLayerFusionData
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgLayerFusionData.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.LayerName = "";
                        object.IsVisible = false;
                        object.BlendRatio = 0;
                        object.IsSelected = false;
                    }
                    if (message.LayerName != null && message.hasOwnProperty("LayerName"))
                        object.LayerName = message.LayerName;
                    if (message.IsVisible != null && message.hasOwnProperty("IsVisible"))
                        object.IsVisible = message.IsVisible;
                    if (message.BlendRatio != null && message.hasOwnProperty("BlendRatio"))
                        object.BlendRatio = options.json && !isFinite(message.BlendRatio) ? String(message.BlendRatio) : message.BlendRatio;
                    if (message.IsSelected != null && message.hasOwnProperty("IsSelected"))
                        object.IsSelected = message.IsSelected;
                    return object;
                };

                /**
                 * Converts this MsgLayerFusionData to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MsgLayerFusionData
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgLayerFusionData.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MsgLayerFusionData
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MsgLayerFusionData
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MsgLayerFusionData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MsgLayerFusionData";
                };

                return MsgLayerFusionData;
            })();

            ProtoBuf.MsgWorkStepFusionData = (function() {

                /**
                 * Properties of a MsgWorkStepFusionData.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMsgWorkStepFusionData
                 * @property {string} curStepName MsgWorkStepFusionData curStepName
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IMsgLayerFusionData>|null} [curLayerFusion] MsgWorkStepFusionData curLayerFusion
                 */

                /**
                 * Constructs a new MsgWorkStepFusionData.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MsgWorkStepFusionData.
                 * @implements IMsgWorkStepFusionData
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMsgWorkStepFusionData=} [properties] Properties to set
                 */
                function MsgWorkStepFusionData(properties) {
                    this.curLayerFusion = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MsgWorkStepFusionData curStepName.
                 * @member {string} curStepName
                 * @memberof UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData
                 * @instance
                 */
                MsgWorkStepFusionData.prototype.curStepName = "";

                /**
                 * MsgWorkStepFusionData curLayerFusion.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IMsgLayerFusionData>} curLayerFusion
                 * @memberof UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData
                 * @instance
                 */
                MsgWorkStepFusionData.prototype.curLayerFusion = $util.emptyArray;

                /**
                 * Creates a new MsgWorkStepFusionData instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgWorkStepFusionData=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData} MsgWorkStepFusionData instance
                 */
                MsgWorkStepFusionData.create = function create(properties) {
                    return new MsgWorkStepFusionData(properties);
                };

                /**
                 * Encodes the specified MsgWorkStepFusionData message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgWorkStepFusionData} message MsgWorkStepFusionData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWorkStepFusionData.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.curStepName);
                    if (message.curLayerFusion != null && message.curLayerFusion.length)
                        for (var i = 0; i < message.curLayerFusion.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.MsgLayerFusionData.encode(message.curLayerFusion[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MsgWorkStepFusionData message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMsgWorkStepFusionData} message MsgWorkStepFusionData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWorkStepFusionData.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MsgWorkStepFusionData message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData} MsgWorkStepFusionData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWorkStepFusionData.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.curStepName = reader.string();
                                break;
                            }
                        case 2: {
                                if (!(message.curLayerFusion && message.curLayerFusion.length))
                                    message.curLayerFusion = [];
                                message.curLayerFusion.push($root.UIBot.UHOR.ProtoBuf.MsgLayerFusionData.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("curStepName"))
                        throw $util.ProtocolError("missing required 'curStepName'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a MsgWorkStepFusionData message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData} MsgWorkStepFusionData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWorkStepFusionData.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MsgWorkStepFusionData message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgWorkStepFusionData.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.curStepName))
                        return "curStepName: string expected";
                    if (message.curLayerFusion != null && message.hasOwnProperty("curLayerFusion")) {
                        if (!Array.isArray(message.curLayerFusion))
                            return "curLayerFusion: array expected";
                        for (var i = 0; i < message.curLayerFusion.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.MsgLayerFusionData.verify(message.curLayerFusion[i]);
                            if (error)
                                return "curLayerFusion." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MsgWorkStepFusionData message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData} MsgWorkStepFusionData
                 */
                MsgWorkStepFusionData.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData();
                    if (object.curStepName != null)
                        message.curStepName = String(object.curStepName);
                    if (object.curLayerFusion) {
                        if (!Array.isArray(object.curLayerFusion))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData.curLayerFusion: array expected");
                        message.curLayerFusion = [];
                        for (var i = 0; i < object.curLayerFusion.length; ++i) {
                            if (typeof object.curLayerFusion[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData.curLayerFusion: object expected");
                            message.curLayerFusion[i] = $root.UIBot.UHOR.ProtoBuf.MsgLayerFusionData.fromObject(object.curLayerFusion[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MsgWorkStepFusionData message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData} message MsgWorkStepFusionData
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgWorkStepFusionData.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.curLayerFusion = [];
                    if (options.defaults)
                        object.curStepName = "";
                    if (message.curStepName != null && message.hasOwnProperty("curStepName"))
                        object.curStepName = message.curStepName;
                    if (message.curLayerFusion && message.curLayerFusion.length) {
                        object.curLayerFusion = [];
                        for (var j = 0; j < message.curLayerFusion.length; ++j)
                            object.curLayerFusion[j] = $root.UIBot.UHOR.ProtoBuf.MsgLayerFusionData.toObject(message.curLayerFusion[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MsgWorkStepFusionData to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgWorkStepFusionData.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MsgWorkStepFusionData
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MsgWorkStepFusionData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MsgWorkStepFusionData";
                };

                return MsgWorkStepFusionData;
            })();

            ProtoBuf.ThreeDMPRInfo = (function() {

                /**
                 * Properties of a ThreeDMPRInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IThreeDMPRInfo
                 * @property {boolean} AxisDisplay ThreeDMPRInfo AxisDisplay
                 * @property {boolean} SagittalDisplay ThreeDMPRInfo SagittalDisplay
                 * @property {boolean} CornonalDisplay ThreeDMPRInfo CornonalDisplay
                 */

                /**
                 * Constructs a new ThreeDMPRInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a ThreeDMPRInfo.
                 * @implements IThreeDMPRInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IThreeDMPRInfo=} [properties] Properties to set
                 */
                function ThreeDMPRInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ThreeDMPRInfo AxisDisplay.
                 * @member {boolean} AxisDisplay
                 * @memberof UIBot.UHOR.ProtoBuf.ThreeDMPRInfo
                 * @instance
                 */
                ThreeDMPRInfo.prototype.AxisDisplay = false;

                /**
                 * ThreeDMPRInfo SagittalDisplay.
                 * @member {boolean} SagittalDisplay
                 * @memberof UIBot.UHOR.ProtoBuf.ThreeDMPRInfo
                 * @instance
                 */
                ThreeDMPRInfo.prototype.SagittalDisplay = false;

                /**
                 * ThreeDMPRInfo CornonalDisplay.
                 * @member {boolean} CornonalDisplay
                 * @memberof UIBot.UHOR.ProtoBuf.ThreeDMPRInfo
                 * @instance
                 */
                ThreeDMPRInfo.prototype.CornonalDisplay = false;

                /**
                 * Creates a new ThreeDMPRInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.ThreeDMPRInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IThreeDMPRInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.ThreeDMPRInfo} ThreeDMPRInfo instance
                 */
                ThreeDMPRInfo.create = function create(properties) {
                    return new ThreeDMPRInfo(properties);
                };

                /**
                 * Encodes the specified ThreeDMPRInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ThreeDMPRInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.ThreeDMPRInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IThreeDMPRInfo} message ThreeDMPRInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ThreeDMPRInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.AxisDisplay);
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.SagittalDisplay);
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.CornonalDisplay);
                    return writer;
                };

                /**
                 * Encodes the specified ThreeDMPRInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ThreeDMPRInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ThreeDMPRInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IThreeDMPRInfo} message ThreeDMPRInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ThreeDMPRInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ThreeDMPRInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.ThreeDMPRInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.ThreeDMPRInfo} ThreeDMPRInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ThreeDMPRInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.ThreeDMPRInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.AxisDisplay = reader.bool();
                                break;
                            }
                        case 2: {
                                message.SagittalDisplay = reader.bool();
                                break;
                            }
                        case 3: {
                                message.CornonalDisplay = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("AxisDisplay"))
                        throw $util.ProtocolError("missing required 'AxisDisplay'", { instance: message });
                    if (!message.hasOwnProperty("SagittalDisplay"))
                        throw $util.ProtocolError("missing required 'SagittalDisplay'", { instance: message });
                    if (!message.hasOwnProperty("CornonalDisplay"))
                        throw $util.ProtocolError("missing required 'CornonalDisplay'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a ThreeDMPRInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ThreeDMPRInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.ThreeDMPRInfo} ThreeDMPRInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ThreeDMPRInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ThreeDMPRInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.ThreeDMPRInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ThreeDMPRInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (typeof message.AxisDisplay !== "boolean")
                        return "AxisDisplay: boolean expected";
                    if (typeof message.SagittalDisplay !== "boolean")
                        return "SagittalDisplay: boolean expected";
                    if (typeof message.CornonalDisplay !== "boolean")
                        return "CornonalDisplay: boolean expected";
                    return null;
                };

                /**
                 * Creates a ThreeDMPRInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.ThreeDMPRInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.ThreeDMPRInfo} ThreeDMPRInfo
                 */
                ThreeDMPRInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.ThreeDMPRInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.ThreeDMPRInfo();
                    if (object.AxisDisplay != null)
                        message.AxisDisplay = Boolean(object.AxisDisplay);
                    if (object.SagittalDisplay != null)
                        message.SagittalDisplay = Boolean(object.SagittalDisplay);
                    if (object.CornonalDisplay != null)
                        message.CornonalDisplay = Boolean(object.CornonalDisplay);
                    return message;
                };

                /**
                 * Creates a plain object from a ThreeDMPRInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.ThreeDMPRInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ThreeDMPRInfo} message ThreeDMPRInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ThreeDMPRInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.AxisDisplay = false;
                        object.SagittalDisplay = false;
                        object.CornonalDisplay = false;
                    }
                    if (message.AxisDisplay != null && message.hasOwnProperty("AxisDisplay"))
                        object.AxisDisplay = message.AxisDisplay;
                    if (message.SagittalDisplay != null && message.hasOwnProperty("SagittalDisplay"))
                        object.SagittalDisplay = message.SagittalDisplay;
                    if (message.CornonalDisplay != null && message.hasOwnProperty("CornonalDisplay"))
                        object.CornonalDisplay = message.CornonalDisplay;
                    return object;
                };

                /**
                 * Converts this ThreeDMPRInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.ThreeDMPRInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ThreeDMPRInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ThreeDMPRInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.ThreeDMPRInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ThreeDMPRInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.ThreeDMPRInfo";
                };

                return ThreeDMPRInfo;
            })();

            ProtoBuf.MessageSwitchTab = (function() {

                /**
                 * Properties of a MessageSwitchTab.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageSwitchTab
                 * @property {string|null} [CurrentTabName] MessageSwitchTab CurrentTabName
                 * @property {string|null} [NextTabName] MessageSwitchTab NextTabName
                 * @property {string|null} [Info] MessageSwitchTab Info
                 */

                /**
                 * Constructs a new MessageSwitchTab.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageSwitchTab.
                 * @implements IMessageSwitchTab
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageSwitchTab=} [properties] Properties to set
                 */
                function MessageSwitchTab(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageSwitchTab CurrentTabName.
                 * @member {string} CurrentTabName
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchTab
                 * @instance
                 */
                MessageSwitchTab.prototype.CurrentTabName = "";

                /**
                 * MessageSwitchTab NextTabName.
                 * @member {string} NextTabName
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchTab
                 * @instance
                 */
                MessageSwitchTab.prototype.NextTabName = "";

                /**
                 * MessageSwitchTab Info.
                 * @member {string} Info
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchTab
                 * @instance
                 */
                MessageSwitchTab.prototype.Info = "";

                /**
                 * Creates a new MessageSwitchTab instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchTab
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageSwitchTab=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageSwitchTab} MessageSwitchTab instance
                 */
                MessageSwitchTab.create = function create(properties) {
                    return new MessageSwitchTab(properties);
                };

                /**
                 * Encodes the specified MessageSwitchTab message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageSwitchTab.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchTab
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageSwitchTab} message MessageSwitchTab message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageSwitchTab.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.CurrentTabName != null && Object.hasOwnProperty.call(message, "CurrentTabName"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.CurrentTabName);
                    if (message.NextTabName != null && Object.hasOwnProperty.call(message, "NextTabName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.NextTabName);
                    if (message.Info != null && Object.hasOwnProperty.call(message, "Info"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.Info);
                    return writer;
                };

                /**
                 * Encodes the specified MessageSwitchTab message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageSwitchTab.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchTab
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageSwitchTab} message MessageSwitchTab message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageSwitchTab.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageSwitchTab message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchTab
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageSwitchTab} MessageSwitchTab
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageSwitchTab.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageSwitchTab();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.CurrentTabName = reader.string();
                                break;
                            }
                        case 2: {
                                message.NextTabName = reader.string();
                                break;
                            }
                        case 3: {
                                message.Info = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageSwitchTab message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchTab
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageSwitchTab} MessageSwitchTab
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageSwitchTab.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageSwitchTab message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchTab
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageSwitchTab.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.CurrentTabName != null && message.hasOwnProperty("CurrentTabName"))
                        if (!$util.isString(message.CurrentTabName))
                            return "CurrentTabName: string expected";
                    if (message.NextTabName != null && message.hasOwnProperty("NextTabName"))
                        if (!$util.isString(message.NextTabName))
                            return "NextTabName: string expected";
                    if (message.Info != null && message.hasOwnProperty("Info"))
                        if (!$util.isString(message.Info))
                            return "Info: string expected";
                    return null;
                };

                /**
                 * Creates a MessageSwitchTab message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchTab
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageSwitchTab} MessageSwitchTab
                 */
                MessageSwitchTab.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageSwitchTab)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageSwitchTab();
                    if (object.CurrentTabName != null)
                        message.CurrentTabName = String(object.CurrentTabName);
                    if (object.NextTabName != null)
                        message.NextTabName = String(object.NextTabName);
                    if (object.Info != null)
                        message.Info = String(object.Info);
                    return message;
                };

                /**
                 * Creates a plain object from a MessageSwitchTab message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchTab
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageSwitchTab} message MessageSwitchTab
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageSwitchTab.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.CurrentTabName = "";
                        object.NextTabName = "";
                        object.Info = "";
                    }
                    if (message.CurrentTabName != null && message.hasOwnProperty("CurrentTabName"))
                        object.CurrentTabName = message.CurrentTabName;
                    if (message.NextTabName != null && message.hasOwnProperty("NextTabName"))
                        object.NextTabName = message.NextTabName;
                    if (message.Info != null && message.hasOwnProperty("Info"))
                        object.Info = message.Info;
                    return object;
                };

                /**
                 * Converts this MessageSwitchTab to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchTab
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageSwitchTab.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageSwitchTab
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchTab
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageSwitchTab.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageSwitchTab";
                };

                return MessageSwitchTab;
            })();

            ProtoBuf.MessageSwitchPageOperation = (function() {

                /**
                 * Properties of a MessageSwitchPageOperation.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageSwitchPageOperation
                 * @property {UIBot.UHOR.ProtoBuf.EnumPage|null} [CurrentPage] MessageSwitchPageOperation CurrentPage
                 * @property {UIBot.UHOR.ProtoBuf.EnumPage|null} [NextPage] MessageSwitchPageOperation NextPage
                 * @property {string|null} [Info] MessageSwitchPageOperation Info
                 */

                /**
                 * Constructs a new MessageSwitchPageOperation.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageSwitchPageOperation.
                 * @implements IMessageSwitchPageOperation
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageSwitchPageOperation=} [properties] Properties to set
                 */
                function MessageSwitchPageOperation(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageSwitchPageOperation CurrentPage.
                 * @member {UIBot.UHOR.ProtoBuf.EnumPage} CurrentPage
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation
                 * @instance
                 */
                MessageSwitchPageOperation.prototype.CurrentPage = 0;

                /**
                 * MessageSwitchPageOperation NextPage.
                 * @member {UIBot.UHOR.ProtoBuf.EnumPage} NextPage
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation
                 * @instance
                 */
                MessageSwitchPageOperation.prototype.NextPage = 0;

                /**
                 * MessageSwitchPageOperation Info.
                 * @member {string} Info
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation
                 * @instance
                 */
                MessageSwitchPageOperation.prototype.Info = "";

                /**
                 * Creates a new MessageSwitchPageOperation instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageSwitchPageOperation=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation} MessageSwitchPageOperation instance
                 */
                MessageSwitchPageOperation.create = function create(properties) {
                    return new MessageSwitchPageOperation(properties);
                };

                /**
                 * Encodes the specified MessageSwitchPageOperation message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageSwitchPageOperation} message MessageSwitchPageOperation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageSwitchPageOperation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.CurrentPage != null && Object.hasOwnProperty.call(message, "CurrentPage"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CurrentPage);
                    if (message.NextPage != null && Object.hasOwnProperty.call(message, "NextPage"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.NextPage);
                    if (message.Info != null && Object.hasOwnProperty.call(message, "Info"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.Info);
                    return writer;
                };

                /**
                 * Encodes the specified MessageSwitchPageOperation message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageSwitchPageOperation} message MessageSwitchPageOperation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageSwitchPageOperation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageSwitchPageOperation message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation} MessageSwitchPageOperation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageSwitchPageOperation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.CurrentPage = reader.int32();
                                break;
                            }
                        case 2: {
                                message.NextPage = reader.int32();
                                break;
                            }
                        case 3: {
                                message.Info = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageSwitchPageOperation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation} MessageSwitchPageOperation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageSwitchPageOperation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageSwitchPageOperation message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageSwitchPageOperation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.CurrentPage != null && message.hasOwnProperty("CurrentPage"))
                        switch (message.CurrentPage) {
                        default:
                            return "CurrentPage: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.NextPage != null && message.hasOwnProperty("NextPage"))
                        switch (message.NextPage) {
                        default:
                            return "NextPage: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.Info != null && message.hasOwnProperty("Info"))
                        if (!$util.isString(message.Info))
                            return "Info: string expected";
                    return null;
                };

                /**
                 * Creates a MessageSwitchPageOperation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation} MessageSwitchPageOperation
                 */
                MessageSwitchPageOperation.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation();
                    switch (object.CurrentPage) {
                    default:
                        if (typeof object.CurrentPage === "number") {
                            message.CurrentPage = object.CurrentPage;
                            break;
                        }
                        break;
                    case "Registration":
                    case 0:
                        message.CurrentPage = 0;
                        break;
                    case "Segment":
                    case 1:
                        message.CurrentPage = 1;
                        break;
                    case "PlanningStep":
                    case 2:
                        message.CurrentPage = 2;
                        break;
                    case "DTI":
                    case 3:
                        message.CurrentPage = 3;
                        break;
                    }
                    switch (object.NextPage) {
                    default:
                        if (typeof object.NextPage === "number") {
                            message.NextPage = object.NextPage;
                            break;
                        }
                        break;
                    case "Registration":
                    case 0:
                        message.NextPage = 0;
                        break;
                    case "Segment":
                    case 1:
                        message.NextPage = 1;
                        break;
                    case "PlanningStep":
                    case 2:
                        message.NextPage = 2;
                        break;
                    case "DTI":
                    case 3:
                        message.NextPage = 3;
                        break;
                    }
                    if (object.Info != null)
                        message.Info = String(object.Info);
                    return message;
                };

                /**
                 * Creates a plain object from a MessageSwitchPageOperation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation} message MessageSwitchPageOperation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageSwitchPageOperation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.CurrentPage = options.enums === String ? "Registration" : 0;
                        object.NextPage = options.enums === String ? "Registration" : 0;
                        object.Info = "";
                    }
                    if (message.CurrentPage != null && message.hasOwnProperty("CurrentPage"))
                        object.CurrentPage = options.enums === String ? $root.UIBot.UHOR.ProtoBuf.EnumPage[message.CurrentPage] === undefined ? message.CurrentPage : $root.UIBot.UHOR.ProtoBuf.EnumPage[message.CurrentPage] : message.CurrentPage;
                    if (message.NextPage != null && message.hasOwnProperty("NextPage"))
                        object.NextPage = options.enums === String ? $root.UIBot.UHOR.ProtoBuf.EnumPage[message.NextPage] === undefined ? message.NextPage : $root.UIBot.UHOR.ProtoBuf.EnumPage[message.NextPage] : message.NextPage;
                    if (message.Info != null && message.hasOwnProperty("Info"))
                        object.Info = message.Info;
                    return object;
                };

                /**
                 * Converts this MessageSwitchPageOperation to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageSwitchPageOperation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageSwitchPageOperation
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageSwitchPageOperation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageSwitchPageOperation";
                };

                return MessageSwitchPageOperation;
            })();

            ProtoBuf.MessageDSACT = (function() {

                /**
                 * Properties of a MessageDSACT.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageDSACT
                 * @property {string|null} [CtUid] MessageDSACT CtUid
                 * @property {string|null} [CtaUid] MessageDSACT CtaUid
                 */

                /**
                 * Constructs a new MessageDSACT.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageDSACT.
                 * @implements IMessageDSACT
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageDSACT=} [properties] Properties to set
                 */
                function MessageDSACT(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageDSACT CtUid.
                 * @member {string} CtUid
                 * @memberof UIBot.UHOR.ProtoBuf.MessageDSACT
                 * @instance
                 */
                MessageDSACT.prototype.CtUid = "";

                /**
                 * MessageDSACT CtaUid.
                 * @member {string} CtaUid
                 * @memberof UIBot.UHOR.ProtoBuf.MessageDSACT
                 * @instance
                 */
                MessageDSACT.prototype.CtaUid = "";

                /**
                 * Creates a new MessageDSACT instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageDSACT
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageDSACT=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageDSACT} MessageDSACT instance
                 */
                MessageDSACT.create = function create(properties) {
                    return new MessageDSACT(properties);
                };

                /**
                 * Encodes the specified MessageDSACT message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageDSACT.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageDSACT
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageDSACT} message MessageDSACT message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageDSACT.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.CtUid != null && Object.hasOwnProperty.call(message, "CtUid"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.CtUid);
                    if (message.CtaUid != null && Object.hasOwnProperty.call(message, "CtaUid"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.CtaUid);
                    return writer;
                };

                /**
                 * Encodes the specified MessageDSACT message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageDSACT.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageDSACT
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageDSACT} message MessageDSACT message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageDSACT.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageDSACT message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageDSACT
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageDSACT} MessageDSACT
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageDSACT.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageDSACT();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.CtUid = reader.string();
                                break;
                            }
                        case 2: {
                                message.CtaUid = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageDSACT message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageDSACT
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageDSACT} MessageDSACT
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageDSACT.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageDSACT message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageDSACT
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageDSACT.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.CtUid != null && message.hasOwnProperty("CtUid"))
                        if (!$util.isString(message.CtUid))
                            return "CtUid: string expected";
                    if (message.CtaUid != null && message.hasOwnProperty("CtaUid"))
                        if (!$util.isString(message.CtaUid))
                            return "CtaUid: string expected";
                    return null;
                };

                /**
                 * Creates a MessageDSACT message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageDSACT
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageDSACT} MessageDSACT
                 */
                MessageDSACT.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageDSACT)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageDSACT();
                    if (object.CtUid != null)
                        message.CtUid = String(object.CtUid);
                    if (object.CtaUid != null)
                        message.CtaUid = String(object.CtaUid);
                    return message;
                };

                /**
                 * Creates a plain object from a MessageDSACT message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageDSACT
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageDSACT} message MessageDSACT
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageDSACT.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.CtUid = "";
                        object.CtaUid = "";
                    }
                    if (message.CtUid != null && message.hasOwnProperty("CtUid"))
                        object.CtUid = message.CtUid;
                    if (message.CtaUid != null && message.hasOwnProperty("CtaUid"))
                        object.CtaUid = message.CtaUid;
                    return object;
                };

                /**
                 * Converts this MessageDSACT to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageDSACT
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageDSACT.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageDSACT
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageDSACT
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageDSACT.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageDSACT";
                };

                return MessageDSACT;
            })();

            ProtoBuf.MessageTissueGrowTips = (function() {

                /**
                 * Properties of a MessageTissueGrowTips.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageTissueGrowTips
                 * @property {UIBot.UHOR.ProtoBuf.NeuroErrorCode|null} [TipsCode] MessageTissueGrowTips TipsCode
                 * @property {number|null} [TissueID] MessageTissueGrowTips TissueID
                 */

                /**
                 * Constructs a new MessageTissueGrowTips.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageTissueGrowTips.
                 * @implements IMessageTissueGrowTips
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueGrowTips=} [properties] Properties to set
                 */
                function MessageTissueGrowTips(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageTissueGrowTips TipsCode.
                 * @member {UIBot.UHOR.ProtoBuf.NeuroErrorCode} TipsCode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueGrowTips
                 * @instance
                 */
                MessageTissueGrowTips.prototype.TipsCode = 0;

                /**
                 * MessageTissueGrowTips TissueID.
                 * @member {number} TissueID
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueGrowTips
                 * @instance
                 */
                MessageTissueGrowTips.prototype.TissueID = 0;

                /**
                 * Creates a new MessageTissueGrowTips instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueGrowTips
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueGrowTips=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueGrowTips} MessageTissueGrowTips instance
                 */
                MessageTissueGrowTips.create = function create(properties) {
                    return new MessageTissueGrowTips(properties);
                };

                /**
                 * Encodes the specified MessageTissueGrowTips message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTissueGrowTips.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueGrowTips
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueGrowTips} message MessageTissueGrowTips message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTissueGrowTips.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.TipsCode != null && Object.hasOwnProperty.call(message, "TipsCode"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.TipsCode);
                    if (message.TissueID != null && Object.hasOwnProperty.call(message, "TissueID"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.TissueID);
                    return writer;
                };

                /**
                 * Encodes the specified MessageTissueGrowTips message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTissueGrowTips.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueGrowTips
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueGrowTips} message MessageTissueGrowTips message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTissueGrowTips.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageTissueGrowTips message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueGrowTips
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueGrowTips} MessageTissueGrowTips
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTissueGrowTips.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageTissueGrowTips();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.TipsCode = reader.int32();
                                break;
                            }
                        case 2: {
                                message.TissueID = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageTissueGrowTips message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueGrowTips
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueGrowTips} MessageTissueGrowTips
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTissueGrowTips.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageTissueGrowTips message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueGrowTips
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageTissueGrowTips.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.TipsCode != null && message.hasOwnProperty("TipsCode"))
                        switch (message.TipsCode) {
                        default:
                            return "TipsCode: enum value expected";
                        case 0:
                        case 257:
                        case 258:
                        case 259:
                        case 769:
                        case 770:
                        case 1281:
                        case 1282:
                        case 1283:
                        case 1284:
                        case 1285:
                        case 1793:
                        case 1794:
                        case 2305:
                        case 2306:
                        case 2307:
                        case 2308:
                        case 2309:
                        case 2817:
                        case 2818:
                        case 2819:
                        case 8193:
                        case 8194:
                        case 8195:
                        case 8196:
                        case 8197:
                        case 8198:
                        case 8199:
                        case 8200:
                        case 8201:
                        case 8202:
                        case 8203:
                        case 8204:
                        case 8205:
                        case 12289:
                        case 12290:
                        case 12291:
                        case 12292:
                        case 12293:
                        case 12294:
                        case 12295:
                        case 12296:
                        case 12297:
                        case 12301:
                        case 12302:
                        case 16385:
                        case 16386:
                        case 16387:
                        case 16388:
                        case 16389:
                            break;
                        }
                    if (message.TissueID != null && message.hasOwnProperty("TissueID"))
                        if (!$util.isInteger(message.TissueID))
                            return "TissueID: integer expected";
                    return null;
                };

                /**
                 * Creates a MessageTissueGrowTips message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueGrowTips
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueGrowTips} MessageTissueGrowTips
                 */
                MessageTissueGrowTips.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageTissueGrowTips)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageTissueGrowTips();
                    switch (object.TipsCode) {
                    default:
                        if (typeof object.TipsCode === "number") {
                            message.TipsCode = object.TipsCode;
                            break;
                        }
                        break;
                    case "Neuro_Success":
                    case 0:
                        message.TipsCode = 0;
                        break;
                    case "Neuro_Bold_Error":
                    case 257:
                        message.TipsCode = 257;
                        break;
                    case "Neuro_Bold_Missing_Active_Region_Error":
                    case 258:
                        message.TipsCode = 258;
                        break;
                    case "Neuro_Bold_Protocol_Info_Error":
                    case 259:
                        message.TipsCode = 259;
                        break;
                    case "Neuro_DTI_Error":
                    case 769:
                        message.TipsCode = 769;
                        break;
                    case "Neuro_DTI_Outside_Volume_Error":
                    case 770:
                        message.TipsCode = 770;
                        break;
                    case "Neuro_Hemorhage_Vessel_Segment_Error":
                    case 1281:
                        message.TipsCode = 1281;
                        break;
                    case "Neuro_Hemorhage_Hemorrhage_Segment_Error":
                    case 1282:
                        message.TipsCode = 1282;
                        break;
                    case "Neuro_Hemorhage_Hydroncus_Segment_Error":
                    case 1283:
                        message.TipsCode = 1283;
                        break;
                    case "Neuro_Hemorhage_Skull_Extraction_Error":
                    case 1284:
                        message.TipsCode = 1284;
                        break;
                    case "Neuro_Hemorhage_DrainageTube_Extraction_Error":
                    case 1285:
                        message.TipsCode = 1285;
                        break;
                    case "Neuro_TumorBiopsies_Vessel_Segment_Error":
                    case 1793:
                        message.TipsCode = 1793;
                        break;
                    case "Neuro_TumorBiopsies_TumorBiopsies_Segment_Error":
                    case 1794:
                        message.TipsCode = 1794;
                        break;
                    case "Neuro_DBS_Vessel_Segment_Error":
                    case 2305:
                        message.TipsCode = 2305;
                        break;
                    case "Neuro_DBS_BrainAltlases_Error":
                    case 2306:
                        message.TipsCode = 2306;
                        break;
                    case "Neuro_DBS_ACPCVolumeUIDMatchCurrentVolumeUID_Error":
                    case 2307:
                        message.TipsCode = 2307;
                        break;
                    case "Neuro_DBS_CorticalLandmarkCalculate_Error":
                    case 2308:
                        message.TipsCode = 2308;
                        break;
                    case "Neuro_DBS_EditBrainAtlases_Error":
                    case 2309:
                        message.TipsCode = 2309;
                        break;
                    case "Neuro_SEEG_Vessel_Segment_Error":
                    case 2817:
                        message.TipsCode = 2817;
                        break;
                    case "Neuro_SEEG_Cucoloris_Error":
                    case 2818:
                        message.TipsCode = 2818;
                        break;
                    case "Neuro_SEEG_Brain_Segmentation_Error":
                    case 2819:
                        message.TipsCode = 2819;
                        break;
                    case "Neuro_Common_Marker_Auto_Add_Nail_Error":
                    case 8193:
                        message.TipsCode = 8193;
                        break;
                    case "Neuro_Common_Marker_Auto_Add_Sphere_Error":
                    case 8194:
                        message.TipsCode = 8194;
                        break;
                    case "Neuro_Common_Marker_Add_Marker_Duplicate_Error":
                    case 8195:
                        message.TipsCode = 8195;
                        break;
                    case "Neuro_Common_Marker_Add_Marker_Limit_Exceeded_Error":
                    case 8196:
                        message.TipsCode = 8196;
                        break;
                    case "Neuro_Common_ParcellationDKT_Error":
                    case 8197:
                        message.TipsCode = 8197;
                        break;
                    case "Neuro_Common_BedboardRemovement_Error":
                    case 8198:
                        message.TipsCode = 8198;
                        break;
                    case "Neuro_Common_NucleiExtract_Error":
                    case 8199:
                        message.TipsCode = 8199;
                        break;
                    case "Neuro_Common_TissueGrow_Error":
                    case 8200:
                        message.TipsCode = 8200;
                        break;
                    case "Neuro_Common_MultiPointsConnection_Error":
                    case 8201:
                        message.TipsCode = 8201;
                        break;
                    case "Neuro_Common_Upload_Error":
                    case 8202:
                        message.TipsCode = 8202;
                        break;
                    case "Neuro_Common_Upload_Success":
                    case 8203:
                        message.TipsCode = 8203;
                        break;
                    case "Neuro_Common_No_Exit_User_Error":
                    case 8204:
                        message.TipsCode = 8204;
                        break;
                    case "Neuro_Common_Could_Not_Connect_Error":
                    case 8205:
                        message.TipsCode = 8205;
                        break;
                    case "Neuro_DataChecking_Validate_Error":
                    case 12289:
                        message.TipsCode = 12289;
                        break;
                    case "Neuro_DataChecking_Dicom_Empty_Error":
                    case 12290:
                        message.TipsCode = 12290;
                        break;
                    case "Neuro_DataChecking_Dicom_Absence_Error":
                    case 12291:
                        message.TipsCode = 12291;
                        break;
                    case "Neuro_DataChecking_Dicom_Ori_Error":
                    case 12292:
                        message.TipsCode = 12292;
                        break;
                    case "Neuro_DataChecking_Dicom_Space_Error":
                    case 12293:
                        message.TipsCode = 12293;
                        break;
                    case "Neuro_DataChecking_Serise_Number_Error":
                    case 12294:
                        message.TipsCode = 12294;
                        break;
                    case "Neuro_DataChecking_DTI_Missing_Ref_Sequence_Error":
                    case 12295:
                        message.TipsCode = 12295;
                        break;
                    case "Neuro_DataChecking_BOLD_Missing_Ref_Sequence_Error":
                    case 12296:
                        message.TipsCode = 12296;
                        break;
                    case "Neuro_DataChecking_Result_Not_Match_Error":
                    case 12297:
                        message.TipsCode = 12297;
                        break;
                    case "Neuro_DataChecking_Result_Sequence_Error":
                    case 12301:
                        message.TipsCode = 12301;
                        break;
                    case "Neuro_DataChecking_Load_Series_Error":
                    case 12302:
                        message.TipsCode = 12302;
                        break;
                    case "Neuro_LoadPlanningResult_OtherApp_Error":
                    case 16385:
                        message.TipsCode = 16385;
                        break;
                    case "Neuro_LoadPlanningResult_LoadData_Error":
                    case 16386:
                        message.TipsCode = 16386;
                        break;
                    case "Neuro_SavePlanningResult_SaveData_Success":
                    case 16387:
                        message.TipsCode = 16387;
                        break;
                    case "Neruo_SavePlanningResult_SaveData_Fail":
                    case 16388:
                        message.TipsCode = 16388;
                        break;
                    case "Neruo_SavePlanningResult_SaveFiber_TooMuch":
                    case 16389:
                        message.TipsCode = 16389;
                        break;
                    }
                    if (object.TissueID != null)
                        message.TissueID = object.TissueID | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a MessageTissueGrowTips message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueGrowTips
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageTissueGrowTips} message MessageTissueGrowTips
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageTissueGrowTips.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.TipsCode = options.enums === String ? "Neuro_Success" : 0;
                        object.TissueID = 0;
                    }
                    if (message.TipsCode != null && message.hasOwnProperty("TipsCode"))
                        object.TipsCode = options.enums === String ? $root.UIBot.UHOR.ProtoBuf.NeuroErrorCode[message.TipsCode] === undefined ? message.TipsCode : $root.UIBot.UHOR.ProtoBuf.NeuroErrorCode[message.TipsCode] : message.TipsCode;
                    if (message.TissueID != null && message.hasOwnProperty("TissueID"))
                        object.TissueID = message.TissueID;
                    return object;
                };

                /**
                 * Converts this MessageTissueGrowTips to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueGrowTips
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageTissueGrowTips.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageTissueGrowTips
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueGrowTips
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageTissueGrowTips.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageTissueGrowTips";
                };

                return MessageTissueGrowTips;
            })();

            ProtoBuf.MessageTumorExtractInfo = (function() {

                /**
                 * Properties of a MessageTumorExtractInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageTumorExtractInfo
                 * @property {string|null} [MeshData] MessageTumorExtractInfo MeshData
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IPoint3DDouble>|null} [Points] MessageTumorExtractInfo Points
                 * @property {string|null} [MaskComporessData] MessageTumorExtractInfo MaskComporessData
                 * @property {string|null} [VolumeUID] MessageTumorExtractInfo VolumeUID
                 * @property {UIBot.UHOR.ProtoBuf.IPoint3DDouble|null} [LongestStart] MessageTumorExtractInfo LongestStart
                 * @property {UIBot.UHOR.ProtoBuf.IPoint3DDouble|null} [LongestEnd] MessageTumorExtractInfo LongestEnd
                 * @property {UIBot.UHOR.ProtoBuf.IPoint3DDouble|null} [PerpendicularStart] MessageTumorExtractInfo PerpendicularStart
                 * @property {UIBot.UHOR.ProtoBuf.IPoint3DDouble|null} [PerpendicularEnd] MessageTumorExtractInfo PerpendicularEnd
                 * @property {number|null} [LongestDiameter] MessageTumorExtractInfo LongestDiameter
                 * @property {number|null} [PerpendicularDiameter] MessageTumorExtractInfo PerpendicularDiameter
                 * @property {number|null} [MaskLength] MessageTumorExtractInfo MaskLength
                 */

                /**
                 * Constructs a new MessageTumorExtractInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageTumorExtractInfo.
                 * @implements IMessageTumorExtractInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorExtractInfo=} [properties] Properties to set
                 */
                function MessageTumorExtractInfo(properties) {
                    this.Points = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageTumorExtractInfo MeshData.
                 * @member {string} MeshData
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @instance
                 */
                MessageTumorExtractInfo.prototype.MeshData = "";

                /**
                 * MessageTumorExtractInfo Points.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IPoint3DDouble>} Points
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @instance
                 */
                MessageTumorExtractInfo.prototype.Points = $util.emptyArray;

                /**
                 * MessageTumorExtractInfo MaskComporessData.
                 * @member {string} MaskComporessData
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @instance
                 */
                MessageTumorExtractInfo.prototype.MaskComporessData = "";

                /**
                 * MessageTumorExtractInfo VolumeUID.
                 * @member {string} VolumeUID
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @instance
                 */
                MessageTumorExtractInfo.prototype.VolumeUID = "";

                /**
                 * MessageTumorExtractInfo LongestStart.
                 * @member {UIBot.UHOR.ProtoBuf.IPoint3DDouble|null|undefined} LongestStart
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @instance
                 */
                MessageTumorExtractInfo.prototype.LongestStart = null;

                /**
                 * MessageTumorExtractInfo LongestEnd.
                 * @member {UIBot.UHOR.ProtoBuf.IPoint3DDouble|null|undefined} LongestEnd
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @instance
                 */
                MessageTumorExtractInfo.prototype.LongestEnd = null;

                /**
                 * MessageTumorExtractInfo PerpendicularStart.
                 * @member {UIBot.UHOR.ProtoBuf.IPoint3DDouble|null|undefined} PerpendicularStart
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @instance
                 */
                MessageTumorExtractInfo.prototype.PerpendicularStart = null;

                /**
                 * MessageTumorExtractInfo PerpendicularEnd.
                 * @member {UIBot.UHOR.ProtoBuf.IPoint3DDouble|null|undefined} PerpendicularEnd
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @instance
                 */
                MessageTumorExtractInfo.prototype.PerpendicularEnd = null;

                /**
                 * MessageTumorExtractInfo LongestDiameter.
                 * @member {number} LongestDiameter
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @instance
                 */
                MessageTumorExtractInfo.prototype.LongestDiameter = 0;

                /**
                 * MessageTumorExtractInfo PerpendicularDiameter.
                 * @member {number} PerpendicularDiameter
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @instance
                 */
                MessageTumorExtractInfo.prototype.PerpendicularDiameter = 0;

                /**
                 * MessageTumorExtractInfo MaskLength.
                 * @member {number} MaskLength
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @instance
                 */
                MessageTumorExtractInfo.prototype.MaskLength = 0;

                /**
                 * Creates a new MessageTumorExtractInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorExtractInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo} MessageTumorExtractInfo instance
                 */
                MessageTumorExtractInfo.create = function create(properties) {
                    return new MessageTumorExtractInfo(properties);
                };

                /**
                 * Encodes the specified MessageTumorExtractInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorExtractInfo} message MessageTumorExtractInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTumorExtractInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.MeshData != null && Object.hasOwnProperty.call(message, "MeshData"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.MeshData);
                    if (message.Points != null && message.Points.length)
                        for (var i = 0; i < message.Points.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.Point3DDouble.encode(message.Points[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.MaskComporessData != null && Object.hasOwnProperty.call(message, "MaskComporessData"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.MaskComporessData);
                    if (message.VolumeUID != null && Object.hasOwnProperty.call(message, "VolumeUID"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.VolumeUID);
                    if (message.LongestStart != null && Object.hasOwnProperty.call(message, "LongestStart"))
                        $root.UIBot.UHOR.ProtoBuf.Point3DDouble.encode(message.LongestStart, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.LongestEnd != null && Object.hasOwnProperty.call(message, "LongestEnd"))
                        $root.UIBot.UHOR.ProtoBuf.Point3DDouble.encode(message.LongestEnd, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.PerpendicularStart != null && Object.hasOwnProperty.call(message, "PerpendicularStart"))
                        $root.UIBot.UHOR.ProtoBuf.Point3DDouble.encode(message.PerpendicularStart, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.PerpendicularEnd != null && Object.hasOwnProperty.call(message, "PerpendicularEnd"))
                        $root.UIBot.UHOR.ProtoBuf.Point3DDouble.encode(message.PerpendicularEnd, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.LongestDiameter != null && Object.hasOwnProperty.call(message, "LongestDiameter"))
                        writer.uint32(/* id 9, wireType 1 =*/73).double(message.LongestDiameter);
                    if (message.PerpendicularDiameter != null && Object.hasOwnProperty.call(message, "PerpendicularDiameter"))
                        writer.uint32(/* id 10, wireType 1 =*/81).double(message.PerpendicularDiameter);
                    if (message.MaskLength != null && Object.hasOwnProperty.call(message, "MaskLength"))
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.MaskLength);
                    return writer;
                };

                /**
                 * Encodes the specified MessageTumorExtractInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorExtractInfo} message MessageTumorExtractInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTumorExtractInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageTumorExtractInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo} MessageTumorExtractInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTumorExtractInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.MeshData = reader.string();
                                break;
                            }
                        case 2: {
                                if (!(message.Points && message.Points.length))
                                    message.Points = [];
                                message.Points.push($root.UIBot.UHOR.ProtoBuf.Point3DDouble.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                message.MaskComporessData = reader.string();
                                break;
                            }
                        case 4: {
                                message.VolumeUID = reader.string();
                                break;
                            }
                        case 5: {
                                message.LongestStart = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.decode(reader, reader.uint32());
                                break;
                            }
                        case 6: {
                                message.LongestEnd = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.decode(reader, reader.uint32());
                                break;
                            }
                        case 7: {
                                message.PerpendicularStart = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.decode(reader, reader.uint32());
                                break;
                            }
                        case 8: {
                                message.PerpendicularEnd = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.decode(reader, reader.uint32());
                                break;
                            }
                        case 9: {
                                message.LongestDiameter = reader.double();
                                break;
                            }
                        case 10: {
                                message.PerpendicularDiameter = reader.double();
                                break;
                            }
                        case 11: {
                                message.MaskLength = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageTumorExtractInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo} MessageTumorExtractInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTumorExtractInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageTumorExtractInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageTumorExtractInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.MeshData != null && message.hasOwnProperty("MeshData"))
                        if (!$util.isString(message.MeshData))
                            return "MeshData: string expected";
                    if (message.Points != null && message.hasOwnProperty("Points")) {
                        if (!Array.isArray(message.Points))
                            return "Points: array expected";
                        for (var i = 0; i < message.Points.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.verify(message.Points[i]);
                            if (error)
                                return "Points." + error;
                        }
                    }
                    if (message.MaskComporessData != null && message.hasOwnProperty("MaskComporessData"))
                        if (!$util.isString(message.MaskComporessData))
                            return "MaskComporessData: string expected";
                    if (message.VolumeUID != null && message.hasOwnProperty("VolumeUID"))
                        if (!$util.isString(message.VolumeUID))
                            return "VolumeUID: string expected";
                    if (message.LongestStart != null && message.hasOwnProperty("LongestStart")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.verify(message.LongestStart);
                        if (error)
                            return "LongestStart." + error;
                    }
                    if (message.LongestEnd != null && message.hasOwnProperty("LongestEnd")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.verify(message.LongestEnd);
                        if (error)
                            return "LongestEnd." + error;
                    }
                    if (message.PerpendicularStart != null && message.hasOwnProperty("PerpendicularStart")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.verify(message.PerpendicularStart);
                        if (error)
                            return "PerpendicularStart." + error;
                    }
                    if (message.PerpendicularEnd != null && message.hasOwnProperty("PerpendicularEnd")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.verify(message.PerpendicularEnd);
                        if (error)
                            return "PerpendicularEnd." + error;
                    }
                    if (message.LongestDiameter != null && message.hasOwnProperty("LongestDiameter"))
                        if (typeof message.LongestDiameter !== "number")
                            return "LongestDiameter: number expected";
                    if (message.PerpendicularDiameter != null && message.hasOwnProperty("PerpendicularDiameter"))
                        if (typeof message.PerpendicularDiameter !== "number")
                            return "PerpendicularDiameter: number expected";
                    if (message.MaskLength != null && message.hasOwnProperty("MaskLength"))
                        if (!$util.isInteger(message.MaskLength))
                            return "MaskLength: integer expected";
                    return null;
                };

                /**
                 * Creates a MessageTumorExtractInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo} MessageTumorExtractInfo
                 */
                MessageTumorExtractInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo();
                    if (object.MeshData != null)
                        message.MeshData = String(object.MeshData);
                    if (object.Points) {
                        if (!Array.isArray(object.Points))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo.Points: array expected");
                        message.Points = [];
                        for (var i = 0; i < object.Points.length; ++i) {
                            if (typeof object.Points[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo.Points: object expected");
                            message.Points[i] = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.fromObject(object.Points[i]);
                        }
                    }
                    if (object.MaskComporessData != null)
                        message.MaskComporessData = String(object.MaskComporessData);
                    if (object.VolumeUID != null)
                        message.VolumeUID = String(object.VolumeUID);
                    if (object.LongestStart != null) {
                        if (typeof object.LongestStart !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo.LongestStart: object expected");
                        message.LongestStart = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.fromObject(object.LongestStart);
                    }
                    if (object.LongestEnd != null) {
                        if (typeof object.LongestEnd !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo.LongestEnd: object expected");
                        message.LongestEnd = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.fromObject(object.LongestEnd);
                    }
                    if (object.PerpendicularStart != null) {
                        if (typeof object.PerpendicularStart !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo.PerpendicularStart: object expected");
                        message.PerpendicularStart = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.fromObject(object.PerpendicularStart);
                    }
                    if (object.PerpendicularEnd != null) {
                        if (typeof object.PerpendicularEnd !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo.PerpendicularEnd: object expected");
                        message.PerpendicularEnd = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.fromObject(object.PerpendicularEnd);
                    }
                    if (object.LongestDiameter != null)
                        message.LongestDiameter = Number(object.LongestDiameter);
                    if (object.PerpendicularDiameter != null)
                        message.PerpendicularDiameter = Number(object.PerpendicularDiameter);
                    if (object.MaskLength != null)
                        message.MaskLength = object.MaskLength | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a MessageTumorExtractInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo} message MessageTumorExtractInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageTumorExtractInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.Points = [];
                    if (options.defaults) {
                        object.MeshData = "";
                        object.MaskComporessData = "";
                        object.VolumeUID = "";
                        object.LongestStart = null;
                        object.LongestEnd = null;
                        object.PerpendicularStart = null;
                        object.PerpendicularEnd = null;
                        object.LongestDiameter = 0;
                        object.PerpendicularDiameter = 0;
                        object.MaskLength = 0;
                    }
                    if (message.MeshData != null && message.hasOwnProperty("MeshData"))
                        object.MeshData = message.MeshData;
                    if (message.Points && message.Points.length) {
                        object.Points = [];
                        for (var j = 0; j < message.Points.length; ++j)
                            object.Points[j] = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.toObject(message.Points[j], options);
                    }
                    if (message.MaskComporessData != null && message.hasOwnProperty("MaskComporessData"))
                        object.MaskComporessData = message.MaskComporessData;
                    if (message.VolumeUID != null && message.hasOwnProperty("VolumeUID"))
                        object.VolumeUID = message.VolumeUID;
                    if (message.LongestStart != null && message.hasOwnProperty("LongestStart"))
                        object.LongestStart = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.toObject(message.LongestStart, options);
                    if (message.LongestEnd != null && message.hasOwnProperty("LongestEnd"))
                        object.LongestEnd = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.toObject(message.LongestEnd, options);
                    if (message.PerpendicularStart != null && message.hasOwnProperty("PerpendicularStart"))
                        object.PerpendicularStart = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.toObject(message.PerpendicularStart, options);
                    if (message.PerpendicularEnd != null && message.hasOwnProperty("PerpendicularEnd"))
                        object.PerpendicularEnd = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.toObject(message.PerpendicularEnd, options);
                    if (message.LongestDiameter != null && message.hasOwnProperty("LongestDiameter"))
                        object.LongestDiameter = options.json && !isFinite(message.LongestDiameter) ? String(message.LongestDiameter) : message.LongestDiameter;
                    if (message.PerpendicularDiameter != null && message.hasOwnProperty("PerpendicularDiameter"))
                        object.PerpendicularDiameter = options.json && !isFinite(message.PerpendicularDiameter) ? String(message.PerpendicularDiameter) : message.PerpendicularDiameter;
                    if (message.MaskLength != null && message.hasOwnProperty("MaskLength"))
                        object.MaskLength = message.MaskLength;
                    return object;
                };

                /**
                 * Converts this MessageTumorExtractInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageTumorExtractInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageTumorExtractInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageTumorExtractInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo";
                };

                return MessageTumorExtractInfo;
            })();

            ProtoBuf.MessageContourPoints = (function() {

                /**
                 * Properties of a MessageContourPoints.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageContourPoints
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IPoint3DDouble>|null} [Points] MessageContourPoints Points
                 */

                /**
                 * Constructs a new MessageContourPoints.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageContourPoints.
                 * @implements IMessageContourPoints
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageContourPoints=} [properties] Properties to set
                 */
                function MessageContourPoints(properties) {
                    this.Points = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageContourPoints Points.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IPoint3DDouble>} Points
                 * @memberof UIBot.UHOR.ProtoBuf.MessageContourPoints
                 * @instance
                 */
                MessageContourPoints.prototype.Points = $util.emptyArray;

                /**
                 * Creates a new MessageContourPoints instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageContourPoints
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageContourPoints=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageContourPoints} MessageContourPoints instance
                 */
                MessageContourPoints.create = function create(properties) {
                    return new MessageContourPoints(properties);
                };

                /**
                 * Encodes the specified MessageContourPoints message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageContourPoints.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageContourPoints
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageContourPoints} message MessageContourPoints message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageContourPoints.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Points != null && message.Points.length)
                        for (var i = 0; i < message.Points.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.Point3DDouble.encode(message.Points[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageContourPoints message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageContourPoints.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageContourPoints
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageContourPoints} message MessageContourPoints message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageContourPoints.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageContourPoints message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageContourPoints
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageContourPoints} MessageContourPoints
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageContourPoints.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageContourPoints();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.Points && message.Points.length))
                                    message.Points = [];
                                message.Points.push($root.UIBot.UHOR.ProtoBuf.Point3DDouble.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageContourPoints message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageContourPoints
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageContourPoints} MessageContourPoints
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageContourPoints.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageContourPoints message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageContourPoints
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageContourPoints.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Points != null && message.hasOwnProperty("Points")) {
                        if (!Array.isArray(message.Points))
                            return "Points: array expected";
                        for (var i = 0; i < message.Points.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.verify(message.Points[i]);
                            if (error)
                                return "Points." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MessageContourPoints message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageContourPoints
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageContourPoints} MessageContourPoints
                 */
                MessageContourPoints.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageContourPoints)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageContourPoints();
                    if (object.Points) {
                        if (!Array.isArray(object.Points))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageContourPoints.Points: array expected");
                        message.Points = [];
                        for (var i = 0; i < object.Points.length; ++i) {
                            if (typeof object.Points[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MessageContourPoints.Points: object expected");
                            message.Points[i] = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.fromObject(object.Points[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageContourPoints message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageContourPoints
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageContourPoints} message MessageContourPoints
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageContourPoints.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.Points = [];
                    if (message.Points && message.Points.length) {
                        object.Points = [];
                        for (var j = 0; j < message.Points.length; ++j)
                            object.Points[j] = $root.UIBot.UHOR.ProtoBuf.Point3DDouble.toObject(message.Points[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MessageContourPoints to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageContourPoints
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageContourPoints.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageContourPoints
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageContourPoints
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageContourPoints.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageContourPoints";
                };

                return MessageContourPoints;
            })();

            ProtoBuf.MessageTumorEditInfo = (function() {

                /**
                 * Properties of a MessageTumorEditInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageTumorEditInfo
                 * @property {number|null} [MaskId] MessageTumorEditInfo MaskId
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IMessageContourPoints>|null} [ContourInfos] MessageTumorEditInfo ContourInfos
                 */

                /**
                 * Constructs a new MessageTumorEditInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageTumorEditInfo.
                 * @implements IMessageTumorEditInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorEditInfo=} [properties] Properties to set
                 */
                function MessageTumorEditInfo(properties) {
                    this.ContourInfos = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageTumorEditInfo MaskId.
                 * @member {number} MaskId
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorEditInfo
                 * @instance
                 */
                MessageTumorEditInfo.prototype.MaskId = 0;

                /**
                 * MessageTumorEditInfo ContourInfos.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IMessageContourPoints>} ContourInfos
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorEditInfo
                 * @instance
                 */
                MessageTumorEditInfo.prototype.ContourInfos = $util.emptyArray;

                /**
                 * Creates a new MessageTumorEditInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorEditInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorEditInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorEditInfo} MessageTumorEditInfo instance
                 */
                MessageTumorEditInfo.create = function create(properties) {
                    return new MessageTumorEditInfo(properties);
                };

                /**
                 * Encodes the specified MessageTumorEditInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTumorEditInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorEditInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorEditInfo} message MessageTumorEditInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTumorEditInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.MaskId != null && Object.hasOwnProperty.call(message, "MaskId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.MaskId);
                    if (message.ContourInfos != null && message.ContourInfos.length)
                        for (var i = 0; i < message.ContourInfos.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.MessageContourPoints.encode(message.ContourInfos[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageTumorEditInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTumorEditInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorEditInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorEditInfo} message MessageTumorEditInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTumorEditInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageTumorEditInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorEditInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorEditInfo} MessageTumorEditInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTumorEditInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageTumorEditInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.MaskId = reader.int32();
                                break;
                            }
                        case 2: {
                                if (!(message.ContourInfos && message.ContourInfos.length))
                                    message.ContourInfos = [];
                                message.ContourInfos.push($root.UIBot.UHOR.ProtoBuf.MessageContourPoints.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageTumorEditInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorEditInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorEditInfo} MessageTumorEditInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTumorEditInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageTumorEditInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorEditInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageTumorEditInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.MaskId != null && message.hasOwnProperty("MaskId"))
                        if (!$util.isInteger(message.MaskId))
                            return "MaskId: integer expected";
                    if (message.ContourInfos != null && message.hasOwnProperty("ContourInfos")) {
                        if (!Array.isArray(message.ContourInfos))
                            return "ContourInfos: array expected";
                        for (var i = 0; i < message.ContourInfos.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.MessageContourPoints.verify(message.ContourInfos[i]);
                            if (error)
                                return "ContourInfos." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MessageTumorEditInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorEditInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorEditInfo} MessageTumorEditInfo
                 */
                MessageTumorEditInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageTumorEditInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageTumorEditInfo();
                    if (object.MaskId != null)
                        message.MaskId = object.MaskId | 0;
                    if (object.ContourInfos) {
                        if (!Array.isArray(object.ContourInfos))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTumorEditInfo.ContourInfos: array expected");
                        message.ContourInfos = [];
                        for (var i = 0; i < object.ContourInfos.length; ++i) {
                            if (typeof object.ContourInfos[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTumorEditInfo.ContourInfos: object expected");
                            message.ContourInfos[i] = $root.UIBot.UHOR.ProtoBuf.MessageContourPoints.fromObject(object.ContourInfos[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageTumorEditInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorEditInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageTumorEditInfo} message MessageTumorEditInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageTumorEditInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.ContourInfos = [];
                    if (options.defaults)
                        object.MaskId = 0;
                    if (message.MaskId != null && message.hasOwnProperty("MaskId"))
                        object.MaskId = message.MaskId;
                    if (message.ContourInfos && message.ContourInfos.length) {
                        object.ContourInfos = [];
                        for (var j = 0; j < message.ContourInfos.length; ++j)
                            object.ContourInfos[j] = $root.UIBot.UHOR.ProtoBuf.MessageContourPoints.toObject(message.ContourInfos[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MessageTumorEditInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorEditInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageTumorEditInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageTumorEditInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorEditInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageTumorEditInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageTumorEditInfo";
                };

                return MessageTumorEditInfo;
            })();

            ProtoBuf.MessageTumorExtractModelItem = (function() {

                /**
                 * Properties of a MessageTumorExtractModelItem.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageTumorExtractModelItem
                 * @property {number} MaskLabel MessageTumorExtractModelItem MaskLabel
                 * @property {UIBot.UHOR.ProtoBuf.IMessageTumorExtractInfo} info MessageTumorExtractModelItem info
                 */

                /**
                 * Constructs a new MessageTumorExtractModelItem.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageTumorExtractModelItem.
                 * @implements IMessageTumorExtractModelItem
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorExtractModelItem=} [properties] Properties to set
                 */
                function MessageTumorExtractModelItem(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageTumorExtractModelItem MaskLabel.
                 * @member {number} MaskLabel
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem
                 * @instance
                 */
                MessageTumorExtractModelItem.prototype.MaskLabel = 0;

                /**
                 * MessageTumorExtractModelItem info.
                 * @member {UIBot.UHOR.ProtoBuf.IMessageTumorExtractInfo} info
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem
                 * @instance
                 */
                MessageTumorExtractModelItem.prototype.info = null;

                /**
                 * Creates a new MessageTumorExtractModelItem instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorExtractModelItem=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem} MessageTumorExtractModelItem instance
                 */
                MessageTumorExtractModelItem.create = function create(properties) {
                    return new MessageTumorExtractModelItem(properties);
                };

                /**
                 * Encodes the specified MessageTumorExtractModelItem message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorExtractModelItem} message MessageTumorExtractModelItem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTumorExtractModelItem.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.MaskLabel);
                    $root.UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo.encode(message.info, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageTumorExtractModelItem message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorExtractModelItem} message MessageTumorExtractModelItem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTumorExtractModelItem.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageTumorExtractModelItem message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem} MessageTumorExtractModelItem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTumorExtractModelItem.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.MaskLabel = reader.int32();
                                break;
                            }
                        case 2: {
                                message.info = $root.UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("MaskLabel"))
                        throw $util.ProtocolError("missing required 'MaskLabel'", { instance: message });
                    if (!message.hasOwnProperty("info"))
                        throw $util.ProtocolError("missing required 'info'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a MessageTumorExtractModelItem message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem} MessageTumorExtractModelItem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTumorExtractModelItem.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageTumorExtractModelItem message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageTumorExtractModelItem.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isInteger(message.MaskLabel))
                        return "MaskLabel: integer expected";
                    {
                        var error = $root.UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo.verify(message.info);
                        if (error)
                            return "info." + error;
                    }
                    return null;
                };

                /**
                 * Creates a MessageTumorExtractModelItem message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem} MessageTumorExtractModelItem
                 */
                MessageTumorExtractModelItem.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem();
                    if (object.MaskLabel != null)
                        message.MaskLabel = object.MaskLabel | 0;
                    if (object.info != null) {
                        if (typeof object.info !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem.info: object expected");
                        message.info = $root.UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo.fromObject(object.info);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageTumorExtractModelItem message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem} message MessageTumorExtractModelItem
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageTumorExtractModelItem.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.MaskLabel = 0;
                        object.info = null;
                    }
                    if (message.MaskLabel != null && message.hasOwnProperty("MaskLabel"))
                        object.MaskLabel = message.MaskLabel;
                    if (message.info != null && message.hasOwnProperty("info"))
                        object.info = $root.UIBot.UHOR.ProtoBuf.MessageTumorExtractInfo.toObject(message.info, options);
                    return object;
                };

                /**
                 * Converts this MessageTumorExtractModelItem to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageTumorExtractModelItem.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageTumorExtractModelItem
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageTumorExtractModelItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem";
                };

                return MessageTumorExtractModelItem;
            })();

            ProtoBuf.MessageTumorExtractModel = (function() {

                /**
                 * Properties of a MessageTumorExtractModel.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageTumorExtractModel
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IMessageTumorExtractModelItem>|null} [item] MessageTumorExtractModel item
                 */

                /**
                 * Constructs a new MessageTumorExtractModel.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageTumorExtractModel.
                 * @implements IMessageTumorExtractModel
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorExtractModel=} [properties] Properties to set
                 */
                function MessageTumorExtractModel(properties) {
                    this.item = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageTumorExtractModel item.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IMessageTumorExtractModelItem>} item
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModel
                 * @instance
                 */
                MessageTumorExtractModel.prototype.item = $util.emptyArray;

                /**
                 * Creates a new MessageTumorExtractModel instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModel
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorExtractModel=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorExtractModel} MessageTumorExtractModel instance
                 */
                MessageTumorExtractModel.create = function create(properties) {
                    return new MessageTumorExtractModel(properties);
                };

                /**
                 * Encodes the specified MessageTumorExtractModel message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTumorExtractModel.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModel
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorExtractModel} message MessageTumorExtractModel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTumorExtractModel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.item != null && message.item.length)
                        for (var i = 0; i < message.item.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem.encode(message.item[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageTumorExtractModel message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTumorExtractModel.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModel
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorExtractModel} message MessageTumorExtractModel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTumorExtractModel.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageTumorExtractModel message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorExtractModel} MessageTumorExtractModel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTumorExtractModel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageTumorExtractModel();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.item && message.item.length))
                                    message.item = [];
                                message.item.push($root.UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageTumorExtractModel message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorExtractModel} MessageTumorExtractModel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTumorExtractModel.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageTumorExtractModel message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModel
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageTumorExtractModel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.item != null && message.hasOwnProperty("item")) {
                        if (!Array.isArray(message.item))
                            return "item: array expected";
                        for (var i = 0; i < message.item.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem.verify(message.item[i]);
                            if (error)
                                return "item." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MessageTumorExtractModel message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModel
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorExtractModel} MessageTumorExtractModel
                 */
                MessageTumorExtractModel.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageTumorExtractModel)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageTumorExtractModel();
                    if (object.item) {
                        if (!Array.isArray(object.item))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTumorExtractModel.item: array expected");
                        message.item = [];
                        for (var i = 0; i < object.item.length; ++i) {
                            if (typeof object.item[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTumorExtractModel.item: object expected");
                            message.item[i] = $root.UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem.fromObject(object.item[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageTumorExtractModel message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModel
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageTumorExtractModel} message MessageTumorExtractModel
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageTumorExtractModel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.item = [];
                    if (message.item && message.item.length) {
                        object.item = [];
                        for (var j = 0; j < message.item.length; ++j)
                            object.item[j] = $root.UIBot.UHOR.ProtoBuf.MessageTumorExtractModelItem.toObject(message.item[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MessageTumorExtractModel to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModel
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageTumorExtractModel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageTumorExtractModel
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExtractModel
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageTumorExtractModel.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageTumorExtractModel";
                };

                return MessageTumorExtractModel;
            })();

            ProtoBuf.MessageTumorExpandSimulation = (function() {

                /**
                 * Properties of a MessageTumorExpandSimulation.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageTumorExpandSimulation
                 * @property {UIBot.UHOR.ProtoBuf.EnumTumorExpandSimulationAction} action MessageTumorExpandSimulation action
                 * @property {number} iID MessageTumorExpandSimulation iID
                 * @property {number} dDistance MessageTumorExpandSimulation dDistance
                 */

                /**
                 * Constructs a new MessageTumorExpandSimulation.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageTumorExpandSimulation.
                 * @implements IMessageTumorExpandSimulation
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorExpandSimulation=} [properties] Properties to set
                 */
                function MessageTumorExpandSimulation(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageTumorExpandSimulation action.
                 * @member {UIBot.UHOR.ProtoBuf.EnumTumorExpandSimulationAction} action
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation
                 * @instance
                 */
                MessageTumorExpandSimulation.prototype.action = 0;

                /**
                 * MessageTumorExpandSimulation iID.
                 * @member {number} iID
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation
                 * @instance
                 */
                MessageTumorExpandSimulation.prototype.iID = 0;

                /**
                 * MessageTumorExpandSimulation dDistance.
                 * @member {number} dDistance
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation
                 * @instance
                 */
                MessageTumorExpandSimulation.prototype.dDistance = 0;

                /**
                 * Creates a new MessageTumorExpandSimulation instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorExpandSimulation=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation} MessageTumorExpandSimulation instance
                 */
                MessageTumorExpandSimulation.create = function create(properties) {
                    return new MessageTumorExpandSimulation(properties);
                };

                /**
                 * Encodes the specified MessageTumorExpandSimulation message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorExpandSimulation} message MessageTumorExpandSimulation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTumorExpandSimulation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.iID);
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.dDistance);
                    return writer;
                };

                /**
                 * Encodes the specified MessageTumorExpandSimulation message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTumorExpandSimulation} message MessageTumorExpandSimulation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTumorExpandSimulation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageTumorExpandSimulation message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation} MessageTumorExpandSimulation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTumorExpandSimulation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.action = reader.int32();
                                break;
                            }
                        case 2: {
                                message.iID = reader.int32();
                                break;
                            }
                        case 3: {
                                message.dDistance = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("action"))
                        throw $util.ProtocolError("missing required 'action'", { instance: message });
                    if (!message.hasOwnProperty("iID"))
                        throw $util.ProtocolError("missing required 'iID'", { instance: message });
                    if (!message.hasOwnProperty("dDistance"))
                        throw $util.ProtocolError("missing required 'dDistance'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a MessageTumorExpandSimulation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation} MessageTumorExpandSimulation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTumorExpandSimulation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageTumorExpandSimulation message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageTumorExpandSimulation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    switch (message.action) {
                    default:
                        return "action: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                    if (!$util.isInteger(message.iID))
                        return "iID: integer expected";
                    if (typeof message.dDistance !== "number")
                        return "dDistance: number expected";
                    return null;
                };

                /**
                 * Creates a MessageTumorExpandSimulation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation} MessageTumorExpandSimulation
                 */
                MessageTumorExpandSimulation.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation();
                    switch (object.action) {
                    default:
                        if (typeof object.action === "number") {
                            message.action = object.action;
                            break;
                        }
                        break;
                    case "Open":
                    case 0:
                        message.action = 0;
                        break;
                    case "Close":
                    case 1:
                        message.action = 1;
                        break;
                    }
                    if (object.iID != null)
                        message.iID = object.iID | 0;
                    if (object.dDistance != null)
                        message.dDistance = Number(object.dDistance);
                    return message;
                };

                /**
                 * Creates a plain object from a MessageTumorExpandSimulation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation} message MessageTumorExpandSimulation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageTumorExpandSimulation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.action = options.enums === String ? "Open" : 0;
                        object.iID = 0;
                        object.dDistance = 0;
                    }
                    if (message.action != null && message.hasOwnProperty("action"))
                        object.action = options.enums === String ? $root.UIBot.UHOR.ProtoBuf.EnumTumorExpandSimulationAction[message.action] === undefined ? message.action : $root.UIBot.UHOR.ProtoBuf.EnumTumorExpandSimulationAction[message.action] : message.action;
                    if (message.iID != null && message.hasOwnProperty("iID"))
                        object.iID = message.iID;
                    if (message.dDistance != null && message.hasOwnProperty("dDistance"))
                        object.dDistance = options.json && !isFinite(message.dDistance) ? String(message.dDistance) : message.dDistance;
                    return object;
                };

                /**
                 * Converts this MessageTumorExpandSimulation to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageTumorExpandSimulation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageTumorExpandSimulation
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageTumorExpandSimulation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageTumorExpandSimulation";
                };

                return MessageTumorExpandSimulation;
            })();

            ProtoBuf.MessageMultiPointConnect = (function() {

                /**
                 * Properties of a MessageMultiPointConnect.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageMultiPointConnect
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IPoint2DInt>|null} [PointsVector] MessageMultiPointConnect PointsVector
                 */

                /**
                 * Constructs a new MessageMultiPointConnect.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageMultiPointConnect.
                 * @implements IMessageMultiPointConnect
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageMultiPointConnect=} [properties] Properties to set
                 */
                function MessageMultiPointConnect(properties) {
                    this.PointsVector = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageMultiPointConnect PointsVector.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IPoint2DInt>} PointsVector
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMultiPointConnect
                 * @instance
                 */
                MessageMultiPointConnect.prototype.PointsVector = $util.emptyArray;

                /**
                 * Creates a new MessageMultiPointConnect instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMultiPointConnect
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageMultiPointConnect=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageMultiPointConnect} MessageMultiPointConnect instance
                 */
                MessageMultiPointConnect.create = function create(properties) {
                    return new MessageMultiPointConnect(properties);
                };

                /**
                 * Encodes the specified MessageMultiPointConnect message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageMultiPointConnect.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMultiPointConnect
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageMultiPointConnect} message MessageMultiPointConnect message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageMultiPointConnect.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.PointsVector != null && message.PointsVector.length)
                        for (var i = 0; i < message.PointsVector.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.Point2DInt.encode(message.PointsVector[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageMultiPointConnect message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageMultiPointConnect.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMultiPointConnect
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageMultiPointConnect} message MessageMultiPointConnect message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageMultiPointConnect.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageMultiPointConnect message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMultiPointConnect
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageMultiPointConnect} MessageMultiPointConnect
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageMultiPointConnect.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageMultiPointConnect();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.PointsVector && message.PointsVector.length))
                                    message.PointsVector = [];
                                message.PointsVector.push($root.UIBot.UHOR.ProtoBuf.Point2DInt.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageMultiPointConnect message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMultiPointConnect
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageMultiPointConnect} MessageMultiPointConnect
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageMultiPointConnect.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageMultiPointConnect message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMultiPointConnect
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageMultiPointConnect.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.PointsVector != null && message.hasOwnProperty("PointsVector")) {
                        if (!Array.isArray(message.PointsVector))
                            return "PointsVector: array expected";
                        for (var i = 0; i < message.PointsVector.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.Point2DInt.verify(message.PointsVector[i]);
                            if (error)
                                return "PointsVector." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MessageMultiPointConnect message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMultiPointConnect
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageMultiPointConnect} MessageMultiPointConnect
                 */
                MessageMultiPointConnect.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageMultiPointConnect)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageMultiPointConnect();
                    if (object.PointsVector) {
                        if (!Array.isArray(object.PointsVector))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageMultiPointConnect.PointsVector: array expected");
                        message.PointsVector = [];
                        for (var i = 0; i < object.PointsVector.length; ++i) {
                            if (typeof object.PointsVector[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MessageMultiPointConnect.PointsVector: object expected");
                            message.PointsVector[i] = $root.UIBot.UHOR.ProtoBuf.Point2DInt.fromObject(object.PointsVector[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageMultiPointConnect message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMultiPointConnect
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageMultiPointConnect} message MessageMultiPointConnect
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageMultiPointConnect.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.PointsVector = [];
                    if (message.PointsVector && message.PointsVector.length) {
                        object.PointsVector = [];
                        for (var j = 0; j < message.PointsVector.length; ++j)
                            object.PointsVector[j] = $root.UIBot.UHOR.ProtoBuf.Point2DInt.toObject(message.PointsVector[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MessageMultiPointConnect to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMultiPointConnect
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageMultiPointConnect.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageMultiPointConnect
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMultiPointConnect
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageMultiPointConnect.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageMultiPointConnect";
                };

                return MessageMultiPointConnect;
            })();

            ProtoBuf.BrainAltlasesInfo = (function() {

                /**
                 * Properties of a BrainAltlasesInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IBrainAltlasesInfo
                 * @property {string} BrainAltlasesType BrainAltlasesInfo BrainAltlasesType
                 */

                /**
                 * Constructs a new BrainAltlasesInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a BrainAltlasesInfo.
                 * @implements IBrainAltlasesInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IBrainAltlasesInfo=} [properties] Properties to set
                 */
                function BrainAltlasesInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BrainAltlasesInfo BrainAltlasesType.
                 * @member {string} BrainAltlasesType
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesInfo
                 * @instance
                 */
                BrainAltlasesInfo.prototype.BrainAltlasesType = "";

                /**
                 * Creates a new BrainAltlasesInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBrainAltlasesInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.BrainAltlasesInfo} BrainAltlasesInfo instance
                 */
                BrainAltlasesInfo.create = function create(properties) {
                    return new BrainAltlasesInfo(properties);
                };

                /**
                 * Encodes the specified BrainAltlasesInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.BrainAltlasesInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBrainAltlasesInfo} message BrainAltlasesInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BrainAltlasesInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.BrainAltlasesType);
                    return writer;
                };

                /**
                 * Encodes the specified BrainAltlasesInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.BrainAltlasesInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBrainAltlasesInfo} message BrainAltlasesInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BrainAltlasesInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BrainAltlasesInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.BrainAltlasesInfo} BrainAltlasesInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BrainAltlasesInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.BrainAltlasesInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.BrainAltlasesType = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("BrainAltlasesType"))
                        throw $util.ProtocolError("missing required 'BrainAltlasesType'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a BrainAltlasesInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.BrainAltlasesInfo} BrainAltlasesInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BrainAltlasesInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BrainAltlasesInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BrainAltlasesInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.BrainAltlasesType))
                        return "BrainAltlasesType: string expected";
                    return null;
                };

                /**
                 * Creates a BrainAltlasesInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.BrainAltlasesInfo} BrainAltlasesInfo
                 */
                BrainAltlasesInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.BrainAltlasesInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.BrainAltlasesInfo();
                    if (object.BrainAltlasesType != null)
                        message.BrainAltlasesType = String(object.BrainAltlasesType);
                    return message;
                };

                /**
                 * Creates a plain object from a BrainAltlasesInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.BrainAltlasesInfo} message BrainAltlasesInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BrainAltlasesInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.BrainAltlasesType = "";
                    if (message.BrainAltlasesType != null && message.hasOwnProperty("BrainAltlasesType"))
                        object.BrainAltlasesType = message.BrainAltlasesType;
                    return object;
                };

                /**
                 * Converts this BrainAltlasesInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BrainAltlasesInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for BrainAltlasesInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                BrainAltlasesInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.BrainAltlasesInfo";
                };

                return BrainAltlasesInfo;
            })();

            ProtoBuf.BrickMPRInfo = (function() {

                /**
                 * Properties of a BrickMPRInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IBrickMPRInfo
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IPoint2DInt>|null} [BrickMPRCornerPoints] BrickMPRInfo BrickMPRCornerPoints
                 */

                /**
                 * Constructs a new BrickMPRInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a BrickMPRInfo.
                 * @implements IBrickMPRInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IBrickMPRInfo=} [properties] Properties to set
                 */
                function BrickMPRInfo(properties) {
                    this.BrickMPRCornerPoints = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BrickMPRInfo BrickMPRCornerPoints.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IPoint2DInt>} BrickMPRCornerPoints
                 * @memberof UIBot.UHOR.ProtoBuf.BrickMPRInfo
                 * @instance
                 */
                BrickMPRInfo.prototype.BrickMPRCornerPoints = $util.emptyArray;

                /**
                 * Creates a new BrickMPRInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.BrickMPRInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBrickMPRInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.BrickMPRInfo} BrickMPRInfo instance
                 */
                BrickMPRInfo.create = function create(properties) {
                    return new BrickMPRInfo(properties);
                };

                /**
                 * Encodes the specified BrickMPRInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.BrickMPRInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.BrickMPRInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBrickMPRInfo} message BrickMPRInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BrickMPRInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.BrickMPRCornerPoints != null && message.BrickMPRCornerPoints.length)
                        for (var i = 0; i < message.BrickMPRCornerPoints.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.Point2DInt.encode(message.BrickMPRCornerPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified BrickMPRInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.BrickMPRInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.BrickMPRInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBrickMPRInfo} message BrickMPRInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BrickMPRInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BrickMPRInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.BrickMPRInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.BrickMPRInfo} BrickMPRInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BrickMPRInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.BrickMPRInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.BrickMPRCornerPoints && message.BrickMPRCornerPoints.length))
                                    message.BrickMPRCornerPoints = [];
                                message.BrickMPRCornerPoints.push($root.UIBot.UHOR.ProtoBuf.Point2DInt.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BrickMPRInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.BrickMPRInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.BrickMPRInfo} BrickMPRInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BrickMPRInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BrickMPRInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.BrickMPRInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BrickMPRInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.BrickMPRCornerPoints != null && message.hasOwnProperty("BrickMPRCornerPoints")) {
                        if (!Array.isArray(message.BrickMPRCornerPoints))
                            return "BrickMPRCornerPoints: array expected";
                        for (var i = 0; i < message.BrickMPRCornerPoints.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.Point2DInt.verify(message.BrickMPRCornerPoints[i]);
                            if (error)
                                return "BrickMPRCornerPoints." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a BrickMPRInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.BrickMPRInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.BrickMPRInfo} BrickMPRInfo
                 */
                BrickMPRInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.BrickMPRInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.BrickMPRInfo();
                    if (object.BrickMPRCornerPoints) {
                        if (!Array.isArray(object.BrickMPRCornerPoints))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.BrickMPRInfo.BrickMPRCornerPoints: array expected");
                        message.BrickMPRCornerPoints = [];
                        for (var i = 0; i < object.BrickMPRCornerPoints.length; ++i) {
                            if (typeof object.BrickMPRCornerPoints[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.BrickMPRInfo.BrickMPRCornerPoints: object expected");
                            message.BrickMPRCornerPoints[i] = $root.UIBot.UHOR.ProtoBuf.Point2DInt.fromObject(object.BrickMPRCornerPoints[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a BrickMPRInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.BrickMPRInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.BrickMPRInfo} message BrickMPRInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BrickMPRInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.BrickMPRCornerPoints = [];
                    if (message.BrickMPRCornerPoints && message.BrickMPRCornerPoints.length) {
                        object.BrickMPRCornerPoints = [];
                        for (var j = 0; j < message.BrickMPRCornerPoints.length; ++j)
                            object.BrickMPRCornerPoints[j] = $root.UIBot.UHOR.ProtoBuf.Point2DInt.toObject(message.BrickMPRCornerPoints[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this BrickMPRInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.BrickMPRInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BrickMPRInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for BrickMPRInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.BrickMPRInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                BrickMPRInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.BrickMPRInfo";
                };

                return BrickMPRInfo;
            })();

            ProtoBuf.BrainAltlasesVisibleInfo = (function() {

                /**
                 * Properties of a BrainAltlasesVisibleInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IBrainAltlasesVisibleInfo
                 * @property {string} BrainAltlasesType BrainAltlasesVisibleInfo BrainAltlasesType
                 * @property {boolean} BrainAltlasesVisible BrainAltlasesVisibleInfo BrainAltlasesVisible
                 */

                /**
                 * Constructs a new BrainAltlasesVisibleInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a BrainAltlasesVisibleInfo.
                 * @implements IBrainAltlasesVisibleInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IBrainAltlasesVisibleInfo=} [properties] Properties to set
                 */
                function BrainAltlasesVisibleInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BrainAltlasesVisibleInfo BrainAltlasesType.
                 * @member {string} BrainAltlasesType
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo
                 * @instance
                 */
                BrainAltlasesVisibleInfo.prototype.BrainAltlasesType = "";

                /**
                 * BrainAltlasesVisibleInfo BrainAltlasesVisible.
                 * @member {boolean} BrainAltlasesVisible
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo
                 * @instance
                 */
                BrainAltlasesVisibleInfo.prototype.BrainAltlasesVisible = false;

                /**
                 * Creates a new BrainAltlasesVisibleInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBrainAltlasesVisibleInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo} BrainAltlasesVisibleInfo instance
                 */
                BrainAltlasesVisibleInfo.create = function create(properties) {
                    return new BrainAltlasesVisibleInfo(properties);
                };

                /**
                 * Encodes the specified BrainAltlasesVisibleInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBrainAltlasesVisibleInfo} message BrainAltlasesVisibleInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BrainAltlasesVisibleInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.BrainAltlasesType);
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.BrainAltlasesVisible);
                    return writer;
                };

                /**
                 * Encodes the specified BrainAltlasesVisibleInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IBrainAltlasesVisibleInfo} message BrainAltlasesVisibleInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BrainAltlasesVisibleInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BrainAltlasesVisibleInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo} BrainAltlasesVisibleInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BrainAltlasesVisibleInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.BrainAltlasesType = reader.string();
                                break;
                            }
                        case 2: {
                                message.BrainAltlasesVisible = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("BrainAltlasesType"))
                        throw $util.ProtocolError("missing required 'BrainAltlasesType'", { instance: message });
                    if (!message.hasOwnProperty("BrainAltlasesVisible"))
                        throw $util.ProtocolError("missing required 'BrainAltlasesVisible'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a BrainAltlasesVisibleInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo} BrainAltlasesVisibleInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BrainAltlasesVisibleInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BrainAltlasesVisibleInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BrainAltlasesVisibleInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.BrainAltlasesType))
                        return "BrainAltlasesType: string expected";
                    if (typeof message.BrainAltlasesVisible !== "boolean")
                        return "BrainAltlasesVisible: boolean expected";
                    return null;
                };

                /**
                 * Creates a BrainAltlasesVisibleInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo} BrainAltlasesVisibleInfo
                 */
                BrainAltlasesVisibleInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo();
                    if (object.BrainAltlasesType != null)
                        message.BrainAltlasesType = String(object.BrainAltlasesType);
                    if (object.BrainAltlasesVisible != null)
                        message.BrainAltlasesVisible = Boolean(object.BrainAltlasesVisible);
                    return message;
                };

                /**
                 * Creates a plain object from a BrainAltlasesVisibleInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo} message BrainAltlasesVisibleInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BrainAltlasesVisibleInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.BrainAltlasesType = "";
                        object.BrainAltlasesVisible = false;
                    }
                    if (message.BrainAltlasesType != null && message.hasOwnProperty("BrainAltlasesType"))
                        object.BrainAltlasesType = message.BrainAltlasesType;
                    if (message.BrainAltlasesVisible != null && message.hasOwnProperty("BrainAltlasesVisible"))
                        object.BrainAltlasesVisible = message.BrainAltlasesVisible;
                    return object;
                };

                /**
                 * Converts this BrainAltlasesVisibleInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BrainAltlasesVisibleInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for BrainAltlasesVisibleInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                BrainAltlasesVisibleInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.BrainAltlasesVisibleInfo";
                };

                return BrainAltlasesVisibleInfo;
            })();

            ProtoBuf.ACPCIHPoints = (function() {

                /**
                 * Properties of a ACPCIHPoints.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IACPCIHPoints
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IPoint2DInt>|null} [ThreePairPoints] ACPCIHPoints ThreePairPoints
                 */

                /**
                 * Constructs a new ACPCIHPoints.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a ACPCIHPoints.
                 * @implements IACPCIHPoints
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IACPCIHPoints=} [properties] Properties to set
                 */
                function ACPCIHPoints(properties) {
                    this.ThreePairPoints = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ACPCIHPoints ThreePairPoints.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IPoint2DInt>} ThreePairPoints
                 * @memberof UIBot.UHOR.ProtoBuf.ACPCIHPoints
                 * @instance
                 */
                ACPCIHPoints.prototype.ThreePairPoints = $util.emptyArray;

                /**
                 * Creates a new ACPCIHPoints instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.ACPCIHPoints
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IACPCIHPoints=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.ACPCIHPoints} ACPCIHPoints instance
                 */
                ACPCIHPoints.create = function create(properties) {
                    return new ACPCIHPoints(properties);
                };

                /**
                 * Encodes the specified ACPCIHPoints message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ACPCIHPoints.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.ACPCIHPoints
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IACPCIHPoints} message ACPCIHPoints message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ACPCIHPoints.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ThreePairPoints != null && message.ThreePairPoints.length)
                        for (var i = 0; i < message.ThreePairPoints.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.Point2DInt.encode(message.ThreePairPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ACPCIHPoints message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.ACPCIHPoints.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ACPCIHPoints
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IACPCIHPoints} message ACPCIHPoints message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ACPCIHPoints.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ACPCIHPoints message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.ACPCIHPoints
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.ACPCIHPoints} ACPCIHPoints
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ACPCIHPoints.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.ACPCIHPoints();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.ThreePairPoints && message.ThreePairPoints.length))
                                    message.ThreePairPoints = [];
                                message.ThreePairPoints.push($root.UIBot.UHOR.ProtoBuf.Point2DInt.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ACPCIHPoints message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.ACPCIHPoints
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.ACPCIHPoints} ACPCIHPoints
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ACPCIHPoints.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ACPCIHPoints message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.ACPCIHPoints
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ACPCIHPoints.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ThreePairPoints != null && message.hasOwnProperty("ThreePairPoints")) {
                        if (!Array.isArray(message.ThreePairPoints))
                            return "ThreePairPoints: array expected";
                        for (var i = 0; i < message.ThreePairPoints.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.Point2DInt.verify(message.ThreePairPoints[i]);
                            if (error)
                                return "ThreePairPoints." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ACPCIHPoints message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.ACPCIHPoints
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.ACPCIHPoints} ACPCIHPoints
                 */
                ACPCIHPoints.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.ACPCIHPoints)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.ACPCIHPoints();
                    if (object.ThreePairPoints) {
                        if (!Array.isArray(object.ThreePairPoints))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.ACPCIHPoints.ThreePairPoints: array expected");
                        message.ThreePairPoints = [];
                        for (var i = 0; i < object.ThreePairPoints.length; ++i) {
                            if (typeof object.ThreePairPoints[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.ACPCIHPoints.ThreePairPoints: object expected");
                            message.ThreePairPoints[i] = $root.UIBot.UHOR.ProtoBuf.Point2DInt.fromObject(object.ThreePairPoints[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ACPCIHPoints message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.ACPCIHPoints
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.ACPCIHPoints} message ACPCIHPoints
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ACPCIHPoints.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.ThreePairPoints = [];
                    if (message.ThreePairPoints && message.ThreePairPoints.length) {
                        object.ThreePairPoints = [];
                        for (var j = 0; j < message.ThreePairPoints.length; ++j)
                            object.ThreePairPoints[j] = $root.UIBot.UHOR.ProtoBuf.Point2DInt.toObject(message.ThreePairPoints[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ACPCIHPoints to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.ACPCIHPoints
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ACPCIHPoints.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ACPCIHPoints
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.ACPCIHPoints
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ACPCIHPoints.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.ACPCIHPoints";
                };

                return ACPCIHPoints;
            })();

            ProtoBuf.MessagePlanningResult = (function() {

                /**
                 * Properties of a MessagePlanningResult.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessagePlanningResult
                 * @property {string} UserID MessagePlanningResult UserID
                 * @property {string} PlanningResultName MessagePlanningResult PlanningResultName
                 */

                /**
                 * Constructs a new MessagePlanningResult.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessagePlanningResult.
                 * @implements IMessagePlanningResult
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessagePlanningResult=} [properties] Properties to set
                 */
                function MessagePlanningResult(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessagePlanningResult UserID.
                 * @member {string} UserID
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePlanningResult
                 * @instance
                 */
                MessagePlanningResult.prototype.UserID = "";

                /**
                 * MessagePlanningResult PlanningResultName.
                 * @member {string} PlanningResultName
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePlanningResult
                 * @instance
                 */
                MessagePlanningResult.prototype.PlanningResultName = "";

                /**
                 * Creates a new MessagePlanningResult instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePlanningResult
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessagePlanningResult=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessagePlanningResult} MessagePlanningResult instance
                 */
                MessagePlanningResult.create = function create(properties) {
                    return new MessagePlanningResult(properties);
                };

                /**
                 * Encodes the specified MessagePlanningResult message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessagePlanningResult.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePlanningResult
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessagePlanningResult} message MessagePlanningResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessagePlanningResult.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.UserID);
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.PlanningResultName);
                    return writer;
                };

                /**
                 * Encodes the specified MessagePlanningResult message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessagePlanningResult.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePlanningResult
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessagePlanningResult} message MessagePlanningResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessagePlanningResult.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessagePlanningResult message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePlanningResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessagePlanningResult} MessagePlanningResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessagePlanningResult.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessagePlanningResult();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.UserID = reader.string();
                                break;
                            }
                        case 2: {
                                message.PlanningResultName = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("UserID"))
                        throw $util.ProtocolError("missing required 'UserID'", { instance: message });
                    if (!message.hasOwnProperty("PlanningResultName"))
                        throw $util.ProtocolError("missing required 'PlanningResultName'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a MessagePlanningResult message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePlanningResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessagePlanningResult} MessagePlanningResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessagePlanningResult.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessagePlanningResult message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePlanningResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessagePlanningResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.UserID))
                        return "UserID: string expected";
                    if (!$util.isString(message.PlanningResultName))
                        return "PlanningResultName: string expected";
                    return null;
                };

                /**
                 * Creates a MessagePlanningResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePlanningResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessagePlanningResult} MessagePlanningResult
                 */
                MessagePlanningResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessagePlanningResult)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessagePlanningResult();
                    if (object.UserID != null)
                        message.UserID = String(object.UserID);
                    if (object.PlanningResultName != null)
                        message.PlanningResultName = String(object.PlanningResultName);
                    return message;
                };

                /**
                 * Creates a plain object from a MessagePlanningResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePlanningResult
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessagePlanningResult} message MessagePlanningResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessagePlanningResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.UserID = "";
                        object.PlanningResultName = "";
                    }
                    if (message.UserID != null && message.hasOwnProperty("UserID"))
                        object.UserID = message.UserID;
                    if (message.PlanningResultName != null && message.hasOwnProperty("PlanningResultName"))
                        object.PlanningResultName = message.PlanningResultName;
                    return object;
                };

                /**
                 * Converts this MessagePlanningResult to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePlanningResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessagePlanningResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessagePlanningResult
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePlanningResult
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessagePlanningResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessagePlanningResult";
                };

                return MessagePlanningResult;
            })();

            ProtoBuf.MessageCommonStringPair = (function() {

                /**
                 * Properties of a MessageCommonStringPair.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageCommonStringPair
                 * @property {string} key MessageCommonStringPair key
                 * @property {string|null} [value] MessageCommonStringPair value
                 */

                /**
                 * Constructs a new MessageCommonStringPair.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageCommonStringPair.
                 * @implements IMessageCommonStringPair
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageCommonStringPair=} [properties] Properties to set
                 */
                function MessageCommonStringPair(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageCommonStringPair key.
                 * @member {string} key
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonStringPair
                 * @instance
                 */
                MessageCommonStringPair.prototype.key = "";

                /**
                 * MessageCommonStringPair value.
                 * @member {string} value
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonStringPair
                 * @instance
                 */
                MessageCommonStringPair.prototype.value = "";

                /**
                 * Creates a new MessageCommonStringPair instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonStringPair
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageCommonStringPair=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageCommonStringPair} MessageCommonStringPair instance
                 */
                MessageCommonStringPair.create = function create(properties) {
                    return new MessageCommonStringPair(properties);
                };

                /**
                 * Encodes the specified MessageCommonStringPair message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageCommonStringPair.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonStringPair
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageCommonStringPair} message MessageCommonStringPair message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageCommonStringPair.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                    return writer;
                };

                /**
                 * Encodes the specified MessageCommonStringPair message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageCommonStringPair.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonStringPair
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageCommonStringPair} message MessageCommonStringPair message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageCommonStringPair.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageCommonStringPair message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonStringPair
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageCommonStringPair} MessageCommonStringPair
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageCommonStringPair.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageCommonStringPair();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.key = reader.string();
                                break;
                            }
                        case 2: {
                                message.value = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("key"))
                        throw $util.ProtocolError("missing required 'key'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a MessageCommonStringPair message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonStringPair
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageCommonStringPair} MessageCommonStringPair
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageCommonStringPair.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageCommonStringPair message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonStringPair
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageCommonStringPair.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.key))
                        return "key: string expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isString(message.value))
                            return "value: string expected";
                    return null;
                };

                /**
                 * Creates a MessageCommonStringPair message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonStringPair
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageCommonStringPair} MessageCommonStringPair
                 */
                MessageCommonStringPair.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageCommonStringPair)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageCommonStringPair();
                    if (object.key != null)
                        message.key = String(object.key);
                    if (object.value != null)
                        message.value = String(object.value);
                    return message;
                };

                /**
                 * Creates a plain object from a MessageCommonStringPair message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonStringPair
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageCommonStringPair} message MessageCommonStringPair
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageCommonStringPair.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.key = "";
                        object.value = "";
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = message.key;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };

                /**
                 * Converts this MessageCommonStringPair to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonStringPair
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageCommonStringPair.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageCommonStringPair
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonStringPair
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageCommonStringPair.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageCommonStringPair";
                };

                return MessageCommonStringPair;
            })();

            ProtoBuf.MessageCommonInfo = (function() {

                /**
                 * Properties of a MessageCommonInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageCommonInfo
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IMessageCommonStringPair>|null} [StringPair] MessageCommonInfo StringPair
                 */

                /**
                 * Constructs a new MessageCommonInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageCommonInfo.
                 * @implements IMessageCommonInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageCommonInfo=} [properties] Properties to set
                 */
                function MessageCommonInfo(properties) {
                    this.StringPair = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageCommonInfo StringPair.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IMessageCommonStringPair>} StringPair
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonInfo
                 * @instance
                 */
                MessageCommonInfo.prototype.StringPair = $util.emptyArray;

                /**
                 * Creates a new MessageCommonInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageCommonInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageCommonInfo} MessageCommonInfo instance
                 */
                MessageCommonInfo.create = function create(properties) {
                    return new MessageCommonInfo(properties);
                };

                /**
                 * Encodes the specified MessageCommonInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageCommonInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageCommonInfo} message MessageCommonInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageCommonInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.StringPair != null && message.StringPair.length)
                        for (var i = 0; i < message.StringPair.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.MessageCommonStringPair.encode(message.StringPair[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageCommonInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageCommonInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageCommonInfo} message MessageCommonInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageCommonInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageCommonInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageCommonInfo} MessageCommonInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageCommonInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageCommonInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.StringPair && message.StringPair.length))
                                    message.StringPair = [];
                                message.StringPair.push($root.UIBot.UHOR.ProtoBuf.MessageCommonStringPair.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageCommonInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageCommonInfo} MessageCommonInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageCommonInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageCommonInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageCommonInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.StringPair != null && message.hasOwnProperty("StringPair")) {
                        if (!Array.isArray(message.StringPair))
                            return "StringPair: array expected";
                        for (var i = 0; i < message.StringPair.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.MessageCommonStringPair.verify(message.StringPair[i]);
                            if (error)
                                return "StringPair." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MessageCommonInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageCommonInfo} MessageCommonInfo
                 */
                MessageCommonInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageCommonInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageCommonInfo();
                    if (object.StringPair) {
                        if (!Array.isArray(object.StringPair))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageCommonInfo.StringPair: array expected");
                        message.StringPair = [];
                        for (var i = 0; i < object.StringPair.length; ++i) {
                            if (typeof object.StringPair[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MessageCommonInfo.StringPair: object expected");
                            message.StringPair[i] = $root.UIBot.UHOR.ProtoBuf.MessageCommonStringPair.fromObject(object.StringPair[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageCommonInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageCommonInfo} message MessageCommonInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageCommonInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.StringPair = [];
                    if (message.StringPair && message.StringPair.length) {
                        object.StringPair = [];
                        for (var j = 0; j < message.StringPair.length; ++j)
                            object.StringPair[j] = $root.UIBot.UHOR.ProtoBuf.MessageCommonStringPair.toObject(message.StringPair[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MessageCommonInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageCommonInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageCommonInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageCommonInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageCommonInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageCommonInfo";
                };

                return MessageCommonInfo;
            })();

            ProtoBuf.MessageRegistrationType = (function() {

                /**
                 * Properties of a MessageRegistrationType.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageRegistrationType
                 * @property {UIBot.UHOR.ProtoBuf.EnumRegistrationType} RegistrationType MessageRegistrationType RegistrationType
                 */

                /**
                 * Constructs a new MessageRegistrationType.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageRegistrationType.
                 * @implements IMessageRegistrationType
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageRegistrationType=} [properties] Properties to set
                 */
                function MessageRegistrationType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageRegistrationType RegistrationType.
                 * @member {UIBot.UHOR.ProtoBuf.EnumRegistrationType} RegistrationType
                 * @memberof UIBot.UHOR.ProtoBuf.MessageRegistrationType
                 * @instance
                 */
                MessageRegistrationType.prototype.RegistrationType = 0;

                /**
                 * Creates a new MessageRegistrationType instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageRegistrationType
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageRegistrationType=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageRegistrationType} MessageRegistrationType instance
                 */
                MessageRegistrationType.create = function create(properties) {
                    return new MessageRegistrationType(properties);
                };

                /**
                 * Encodes the specified MessageRegistrationType message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageRegistrationType.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageRegistrationType
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageRegistrationType} message MessageRegistrationType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageRegistrationType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.RegistrationType);
                    return writer;
                };

                /**
                 * Encodes the specified MessageRegistrationType message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageRegistrationType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageRegistrationType
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageRegistrationType} message MessageRegistrationType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageRegistrationType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageRegistrationType message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageRegistrationType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageRegistrationType} MessageRegistrationType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageRegistrationType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageRegistrationType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.RegistrationType = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("RegistrationType"))
                        throw $util.ProtocolError("missing required 'RegistrationType'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a MessageRegistrationType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageRegistrationType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageRegistrationType} MessageRegistrationType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageRegistrationType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageRegistrationType message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageRegistrationType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageRegistrationType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    switch (message.RegistrationType) {
                    default:
                        return "RegistrationType: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                    return null;
                };

                /**
                 * Creates a MessageRegistrationType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageRegistrationType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageRegistrationType} MessageRegistrationType
                 */
                MessageRegistrationType.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageRegistrationType)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageRegistrationType();
                    switch (object.RegistrationType) {
                    default:
                        if (typeof object.RegistrationType === "number") {
                            message.RegistrationType = object.RegistrationType;
                            break;
                        }
                        break;
                    case "RoughAndPrecis":
                    case 0:
                        message.RegistrationType = 0;
                        break;
                    case "OnlyRough":
                    case 1:
                        message.RegistrationType = 1;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageRegistrationType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageRegistrationType
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageRegistrationType} message MessageRegistrationType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageRegistrationType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.RegistrationType = options.enums === String ? "RoughAndPrecis" : 0;
                    if (message.RegistrationType != null && message.hasOwnProperty("RegistrationType"))
                        object.RegistrationType = options.enums === String ? $root.UIBot.UHOR.ProtoBuf.EnumRegistrationType[message.RegistrationType] === undefined ? message.RegistrationType : $root.UIBot.UHOR.ProtoBuf.EnumRegistrationType[message.RegistrationType] : message.RegistrationType;
                    return object;
                };

                /**
                 * Converts this MessageRegistrationType to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageRegistrationType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageRegistrationType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageRegistrationType
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageRegistrationType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageRegistrationType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageRegistrationType";
                };

                return MessageRegistrationType;
            })();

            ProtoBuf.MessageTissueSelectedInfo = (function() {

                /**
                 * Properties of a MessageTissueSelectedInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageTissueSelectedInfo
                 * @property {string} sVolumeUID MessageTissueSelectedInfo sVolumeUID
                 * @property {number} iTissueID MessageTissueSelectedInfo iTissueID
                 */

                /**
                 * Constructs a new MessageTissueSelectedInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageTissueSelectedInfo.
                 * @implements IMessageTissueSelectedInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueSelectedInfo=} [properties] Properties to set
                 */
                function MessageTissueSelectedInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageTissueSelectedInfo sVolumeUID.
                 * @member {string} sVolumeUID
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo
                 * @instance
                 */
                MessageTissueSelectedInfo.prototype.sVolumeUID = "";

                /**
                 * MessageTissueSelectedInfo iTissueID.
                 * @member {number} iTissueID
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo
                 * @instance
                 */
                MessageTissueSelectedInfo.prototype.iTissueID = 0;

                /**
                 * Creates a new MessageTissueSelectedInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueSelectedInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo} MessageTissueSelectedInfo instance
                 */
                MessageTissueSelectedInfo.create = function create(properties) {
                    return new MessageTissueSelectedInfo(properties);
                };

                /**
                 * Encodes the specified MessageTissueSelectedInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueSelectedInfo} message MessageTissueSelectedInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTissueSelectedInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sVolumeUID);
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.iTissueID);
                    return writer;
                };

                /**
                 * Encodes the specified MessageTissueSelectedInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueSelectedInfo} message MessageTissueSelectedInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTissueSelectedInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageTissueSelectedInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo} MessageTissueSelectedInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTissueSelectedInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.sVolumeUID = reader.string();
                                break;
                            }
                        case 2: {
                                message.iTissueID = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("sVolumeUID"))
                        throw $util.ProtocolError("missing required 'sVolumeUID'", { instance: message });
                    if (!message.hasOwnProperty("iTissueID"))
                        throw $util.ProtocolError("missing required 'iTissueID'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a MessageTissueSelectedInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo} MessageTissueSelectedInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTissueSelectedInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageTissueSelectedInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageTissueSelectedInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.sVolumeUID))
                        return "sVolumeUID: string expected";
                    if (!$util.isInteger(message.iTissueID))
                        return "iTissueID: integer expected";
                    return null;
                };

                /**
                 * Creates a MessageTissueSelectedInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo} MessageTissueSelectedInfo
                 */
                MessageTissueSelectedInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo();
                    if (object.sVolumeUID != null)
                        message.sVolumeUID = String(object.sVolumeUID);
                    if (object.iTissueID != null)
                        message.iTissueID = object.iTissueID | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a MessageTissueSelectedInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo} message MessageTissueSelectedInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageTissueSelectedInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sVolumeUID = "";
                        object.iTissueID = 0;
                    }
                    if (message.sVolumeUID != null && message.hasOwnProperty("sVolumeUID"))
                        object.sVolumeUID = message.sVolumeUID;
                    if (message.iTissueID != null && message.hasOwnProperty("iTissueID"))
                        object.iTissueID = message.iTissueID;
                    return object;
                };

                /**
                 * Converts this MessageTissueSelectedInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageTissueSelectedInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageTissueSelectedInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageTissueSelectedInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageTissueSelectedInfo";
                };

                return MessageTissueSelectedInfo;
            })();

            ProtoBuf.MessageTissueDefaultColorInfo = (function() {

                /**
                 * Properties of a MessageTissueDefaultColorInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageTissueDefaultColorInfo
                 * @property {number|null} [ID] MessageTissueDefaultColorInfo ID
                 * @property {UIBot.UHOR.ProtoBuf.IMsgColor|null} [Color] MessageTissueDefaultColorInfo Color
                 */

                /**
                 * Constructs a new MessageTissueDefaultColorInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageTissueDefaultColorInfo.
                 * @implements IMessageTissueDefaultColorInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueDefaultColorInfo=} [properties] Properties to set
                 */
                function MessageTissueDefaultColorInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageTissueDefaultColorInfo ID.
                 * @member {number} ID
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo
                 * @instance
                 */
                MessageTissueDefaultColorInfo.prototype.ID = 0;

                /**
                 * MessageTissueDefaultColorInfo Color.
                 * @member {UIBot.UHOR.ProtoBuf.IMsgColor|null|undefined} Color
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo
                 * @instance
                 */
                MessageTissueDefaultColorInfo.prototype.Color = null;

                /**
                 * Creates a new MessageTissueDefaultColorInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueDefaultColorInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo} MessageTissueDefaultColorInfo instance
                 */
                MessageTissueDefaultColorInfo.create = function create(properties) {
                    return new MessageTissueDefaultColorInfo(properties);
                };

                /**
                 * Encodes the specified MessageTissueDefaultColorInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueDefaultColorInfo} message MessageTissueDefaultColorInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTissueDefaultColorInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ID != null && Object.hasOwnProperty.call(message, "ID"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ID);
                    if (message.Color != null && Object.hasOwnProperty.call(message, "Color"))
                        $root.UIBot.UHOR.ProtoBuf.MsgColor.encode(message.Color, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageTissueDefaultColorInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueDefaultColorInfo} message MessageTissueDefaultColorInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTissueDefaultColorInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageTissueDefaultColorInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo} MessageTissueDefaultColorInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTissueDefaultColorInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.ID = reader.int32();
                                break;
                            }
                        case 2: {
                                message.Color = $root.UIBot.UHOR.ProtoBuf.MsgColor.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageTissueDefaultColorInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo} MessageTissueDefaultColorInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTissueDefaultColorInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageTissueDefaultColorInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageTissueDefaultColorInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ID != null && message.hasOwnProperty("ID"))
                        if (!$util.isInteger(message.ID))
                            return "ID: integer expected";
                    if (message.Color != null && message.hasOwnProperty("Color")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.MsgColor.verify(message.Color);
                        if (error)
                            return "Color." + error;
                    }
                    return null;
                };

                /**
                 * Creates a MessageTissueDefaultColorInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo} MessageTissueDefaultColorInfo
                 */
                MessageTissueDefaultColorInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo();
                    if (object.ID != null)
                        message.ID = object.ID | 0;
                    if (object.Color != null) {
                        if (typeof object.Color !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo.Color: object expected");
                        message.Color = $root.UIBot.UHOR.ProtoBuf.MsgColor.fromObject(object.Color);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageTissueDefaultColorInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo} message MessageTissueDefaultColorInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageTissueDefaultColorInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.ID = 0;
                        object.Color = null;
                    }
                    if (message.ID != null && message.hasOwnProperty("ID"))
                        object.ID = message.ID;
                    if (message.Color != null && message.hasOwnProperty("Color"))
                        object.Color = $root.UIBot.UHOR.ProtoBuf.MsgColor.toObject(message.Color, options);
                    return object;
                };

                /**
                 * Converts this MessageTissueDefaultColorInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageTissueDefaultColorInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageTissueDefaultColorInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageTissueDefaultColorInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo";
                };

                return MessageTissueDefaultColorInfo;
            })();

            ProtoBuf.MessageTissueDefaultColorInfoPair = (function() {

                /**
                 * Properties of a MessageTissueDefaultColorInfoPair.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageTissueDefaultColorInfoPair
                 * @property {string|null} [VolumeUID] MessageTissueDefaultColorInfoPair VolumeUID
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IMessageTissueDefaultColorInfo>|null} [TissueDefaultInfo] MessageTissueDefaultColorInfoPair TissueDefaultInfo
                 */

                /**
                 * Constructs a new MessageTissueDefaultColorInfoPair.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageTissueDefaultColorInfoPair.
                 * @implements IMessageTissueDefaultColorInfoPair
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueDefaultColorInfoPair=} [properties] Properties to set
                 */
                function MessageTissueDefaultColorInfoPair(properties) {
                    this.TissueDefaultInfo = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageTissueDefaultColorInfoPair VolumeUID.
                 * @member {string} VolumeUID
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair
                 * @instance
                 */
                MessageTissueDefaultColorInfoPair.prototype.VolumeUID = "";

                /**
                 * MessageTissueDefaultColorInfoPair TissueDefaultInfo.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IMessageTissueDefaultColorInfo>} TissueDefaultInfo
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair
                 * @instance
                 */
                MessageTissueDefaultColorInfoPair.prototype.TissueDefaultInfo = $util.emptyArray;

                /**
                 * Creates a new MessageTissueDefaultColorInfoPair instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueDefaultColorInfoPair=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair} MessageTissueDefaultColorInfoPair instance
                 */
                MessageTissueDefaultColorInfoPair.create = function create(properties) {
                    return new MessageTissueDefaultColorInfoPair(properties);
                };

                /**
                 * Encodes the specified MessageTissueDefaultColorInfoPair message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueDefaultColorInfoPair} message MessageTissueDefaultColorInfoPair message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTissueDefaultColorInfoPair.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.VolumeUID != null && Object.hasOwnProperty.call(message, "VolumeUID"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.VolumeUID);
                    if (message.TissueDefaultInfo != null && message.TissueDefaultInfo.length)
                        for (var i = 0; i < message.TissueDefaultInfo.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo.encode(message.TissueDefaultInfo[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageTissueDefaultColorInfoPair message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueDefaultColorInfoPair} message MessageTissueDefaultColorInfoPair message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTissueDefaultColorInfoPair.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageTissueDefaultColorInfoPair message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair} MessageTissueDefaultColorInfoPair
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTissueDefaultColorInfoPair.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.VolumeUID = reader.string();
                                break;
                            }
                        case 2: {
                                if (!(message.TissueDefaultInfo && message.TissueDefaultInfo.length))
                                    message.TissueDefaultInfo = [];
                                message.TissueDefaultInfo.push($root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageTissueDefaultColorInfoPair message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair} MessageTissueDefaultColorInfoPair
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTissueDefaultColorInfoPair.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageTissueDefaultColorInfoPair message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageTissueDefaultColorInfoPair.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.VolumeUID != null && message.hasOwnProperty("VolumeUID"))
                        if (!$util.isString(message.VolumeUID))
                            return "VolumeUID: string expected";
                    if (message.TissueDefaultInfo != null && message.hasOwnProperty("TissueDefaultInfo")) {
                        if (!Array.isArray(message.TissueDefaultInfo))
                            return "TissueDefaultInfo: array expected";
                        for (var i = 0; i < message.TissueDefaultInfo.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo.verify(message.TissueDefaultInfo[i]);
                            if (error)
                                return "TissueDefaultInfo." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MessageTissueDefaultColorInfoPair message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair} MessageTissueDefaultColorInfoPair
                 */
                MessageTissueDefaultColorInfoPair.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair();
                    if (object.VolumeUID != null)
                        message.VolumeUID = String(object.VolumeUID);
                    if (object.TissueDefaultInfo) {
                        if (!Array.isArray(object.TissueDefaultInfo))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair.TissueDefaultInfo: array expected");
                        message.TissueDefaultInfo = [];
                        for (var i = 0; i < object.TissueDefaultInfo.length; ++i) {
                            if (typeof object.TissueDefaultInfo[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair.TissueDefaultInfo: object expected");
                            message.TissueDefaultInfo[i] = $root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo.fromObject(object.TissueDefaultInfo[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageTissueDefaultColorInfoPair message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair} message MessageTissueDefaultColorInfoPair
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageTissueDefaultColorInfoPair.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.TissueDefaultInfo = [];
                    if (options.defaults)
                        object.VolumeUID = "";
                    if (message.VolumeUID != null && message.hasOwnProperty("VolumeUID"))
                        object.VolumeUID = message.VolumeUID;
                    if (message.TissueDefaultInfo && message.TissueDefaultInfo.length) {
                        object.TissueDefaultInfo = [];
                        for (var j = 0; j < message.TissueDefaultInfo.length; ++j)
                            object.TissueDefaultInfo[j] = $root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfo.toObject(message.TissueDefaultInfo[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MessageTissueDefaultColorInfoPair to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageTissueDefaultColorInfoPair.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageTissueDefaultColorInfoPair
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageTissueDefaultColorInfoPair.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair";
                };

                return MessageTissueDefaultColorInfoPair;
            })();

            ProtoBuf.MessageTissueDefaultColorInfoPairList = (function() {

                /**
                 * Properties of a MessageTissueDefaultColorInfoPairList.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageTissueDefaultColorInfoPairList
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IMessageTissueDefaultColorInfoPair>|null} [TissueDefaultInfoPair] MessageTissueDefaultColorInfoPairList TissueDefaultInfoPair
                 */

                /**
                 * Constructs a new MessageTissueDefaultColorInfoPairList.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageTissueDefaultColorInfoPairList.
                 * @implements IMessageTissueDefaultColorInfoPairList
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueDefaultColorInfoPairList=} [properties] Properties to set
                 */
                function MessageTissueDefaultColorInfoPairList(properties) {
                    this.TissueDefaultInfoPair = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageTissueDefaultColorInfoPairList TissueDefaultInfoPair.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IMessageTissueDefaultColorInfoPair>} TissueDefaultInfoPair
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList
                 * @instance
                 */
                MessageTissueDefaultColorInfoPairList.prototype.TissueDefaultInfoPair = $util.emptyArray;

                /**
                 * Creates a new MessageTissueDefaultColorInfoPairList instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueDefaultColorInfoPairList=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList} MessageTissueDefaultColorInfoPairList instance
                 */
                MessageTissueDefaultColorInfoPairList.create = function create(properties) {
                    return new MessageTissueDefaultColorInfoPairList(properties);
                };

                /**
                 * Encodes the specified MessageTissueDefaultColorInfoPairList message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueDefaultColorInfoPairList} message MessageTissueDefaultColorInfoPairList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTissueDefaultColorInfoPairList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.TissueDefaultInfoPair != null && message.TissueDefaultInfoPair.length)
                        for (var i = 0; i < message.TissueDefaultInfoPair.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair.encode(message.TissueDefaultInfoPair[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageTissueDefaultColorInfoPairList message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageTissueDefaultColorInfoPairList} message MessageTissueDefaultColorInfoPairList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageTissueDefaultColorInfoPairList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageTissueDefaultColorInfoPairList message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList} MessageTissueDefaultColorInfoPairList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTissueDefaultColorInfoPairList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.TissueDefaultInfoPair && message.TissueDefaultInfoPair.length))
                                    message.TissueDefaultInfoPair = [];
                                message.TissueDefaultInfoPair.push($root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageTissueDefaultColorInfoPairList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList} MessageTissueDefaultColorInfoPairList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageTissueDefaultColorInfoPairList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageTissueDefaultColorInfoPairList message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageTissueDefaultColorInfoPairList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.TissueDefaultInfoPair != null && message.hasOwnProperty("TissueDefaultInfoPair")) {
                        if (!Array.isArray(message.TissueDefaultInfoPair))
                            return "TissueDefaultInfoPair: array expected";
                        for (var i = 0; i < message.TissueDefaultInfoPair.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair.verify(message.TissueDefaultInfoPair[i]);
                            if (error)
                                return "TissueDefaultInfoPair." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MessageTissueDefaultColorInfoPairList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList} MessageTissueDefaultColorInfoPairList
                 */
                MessageTissueDefaultColorInfoPairList.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList();
                    if (object.TissueDefaultInfoPair) {
                        if (!Array.isArray(object.TissueDefaultInfoPair))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList.TissueDefaultInfoPair: array expected");
                        message.TissueDefaultInfoPair = [];
                        for (var i = 0; i < object.TissueDefaultInfoPair.length; ++i) {
                            if (typeof object.TissueDefaultInfoPair[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList.TissueDefaultInfoPair: object expected");
                            message.TissueDefaultInfoPair[i] = $root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair.fromObject(object.TissueDefaultInfoPair[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageTissueDefaultColorInfoPairList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList} message MessageTissueDefaultColorInfoPairList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageTissueDefaultColorInfoPairList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.TissueDefaultInfoPair = [];
                    if (message.TissueDefaultInfoPair && message.TissueDefaultInfoPair.length) {
                        object.TissueDefaultInfoPair = [];
                        for (var j = 0; j < message.TissueDefaultInfoPair.length; ++j)
                            object.TissueDefaultInfoPair[j] = $root.UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPair.toObject(message.TissueDefaultInfoPair[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MessageTissueDefaultColorInfoPairList to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageTissueDefaultColorInfoPairList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageTissueDefaultColorInfoPairList
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageTissueDefaultColorInfoPairList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageTissueDefaultColorInfoPairList";
                };

                return MessageTissueDefaultColorInfoPairList;
            })();

            ProtoBuf.MessageMeasureLineInfo = (function() {

                /**
                 * Properties of a MessageMeasureLineInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageMeasureLineInfo
                 * @property {number} ID MessageMeasureLineInfo ID
                 * @property {string} MeasureLineInfo MessageMeasureLineInfo MeasureLineInfo
                 */

                /**
                 * Constructs a new MessageMeasureLineInfo.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageMeasureLineInfo.
                 * @implements IMessageMeasureLineInfo
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageMeasureLineInfo=} [properties] Properties to set
                 */
                function MessageMeasureLineInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageMeasureLineInfo ID.
                 * @member {number} ID
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo
                 * @instance
                 */
                MessageMeasureLineInfo.prototype.ID = 0;

                /**
                 * MessageMeasureLineInfo MeasureLineInfo.
                 * @member {string} MeasureLineInfo
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo
                 * @instance
                 */
                MessageMeasureLineInfo.prototype.MeasureLineInfo = "";

                /**
                 * Creates a new MessageMeasureLineInfo instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageMeasureLineInfo=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo} MessageMeasureLineInfo instance
                 */
                MessageMeasureLineInfo.create = function create(properties) {
                    return new MessageMeasureLineInfo(properties);
                };

                /**
                 * Encodes the specified MessageMeasureLineInfo message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageMeasureLineInfo} message MessageMeasureLineInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageMeasureLineInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ID);
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.MeasureLineInfo);
                    return writer;
                };

                /**
                 * Encodes the specified MessageMeasureLineInfo message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageMeasureLineInfo} message MessageMeasureLineInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageMeasureLineInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageMeasureLineInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo} MessageMeasureLineInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageMeasureLineInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.ID = reader.int32();
                                break;
                            }
                        case 2: {
                                message.MeasureLineInfo = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("ID"))
                        throw $util.ProtocolError("missing required 'ID'", { instance: message });
                    if (!message.hasOwnProperty("MeasureLineInfo"))
                        throw $util.ProtocolError("missing required 'MeasureLineInfo'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a MessageMeasureLineInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo} MessageMeasureLineInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageMeasureLineInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageMeasureLineInfo message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageMeasureLineInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isInteger(message.ID))
                        return "ID: integer expected";
                    if (!$util.isString(message.MeasureLineInfo))
                        return "MeasureLineInfo: string expected";
                    return null;
                };

                /**
                 * Creates a MessageMeasureLineInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo} MessageMeasureLineInfo
                 */
                MessageMeasureLineInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo();
                    if (object.ID != null)
                        message.ID = object.ID | 0;
                    if (object.MeasureLineInfo != null)
                        message.MeasureLineInfo = String(object.MeasureLineInfo);
                    return message;
                };

                /**
                 * Creates a plain object from a MessageMeasureLineInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo} message MessageMeasureLineInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageMeasureLineInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.ID = 0;
                        object.MeasureLineInfo = "";
                    }
                    if (message.ID != null && message.hasOwnProperty("ID"))
                        object.ID = message.ID;
                    if (message.MeasureLineInfo != null && message.hasOwnProperty("MeasureLineInfo"))
                        object.MeasureLineInfo = message.MeasureLineInfo;
                    return object;
                };

                /**
                 * Converts this MessageMeasureLineInfo to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageMeasureLineInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageMeasureLineInfo
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageMeasureLineInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo";
                };

                return MessageMeasureLineInfo;
            })();

            ProtoBuf.MessageMeasureLineList = (function() {

                /**
                 * Properties of a MessageMeasureLineList.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessageMeasureLineList
                 * @property {Array.<UIBot.UHOR.ProtoBuf.IMessageMeasureLineInfo>|null} [MeasureLineList] MessageMeasureLineList MeasureLineList
                 */

                /**
                 * Constructs a new MessageMeasureLineList.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessageMeasureLineList.
                 * @implements IMessageMeasureLineList
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessageMeasureLineList=} [properties] Properties to set
                 */
                function MessageMeasureLineList(properties) {
                    this.MeasureLineList = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageMeasureLineList MeasureLineList.
                 * @member {Array.<UIBot.UHOR.ProtoBuf.IMessageMeasureLineInfo>} MeasureLineList
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineList
                 * @instance
                 */
                MessageMeasureLineList.prototype.MeasureLineList = $util.emptyArray;

                /**
                 * Creates a new MessageMeasureLineList instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageMeasureLineList=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessageMeasureLineList} MessageMeasureLineList instance
                 */
                MessageMeasureLineList.create = function create(properties) {
                    return new MessageMeasureLineList(properties);
                };

                /**
                 * Encodes the specified MessageMeasureLineList message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageMeasureLineList.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageMeasureLineList} message MessageMeasureLineList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageMeasureLineList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.MeasureLineList != null && message.MeasureLineList.length)
                        for (var i = 0; i < message.MeasureLineList.length; ++i)
                            $root.UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo.encode(message.MeasureLineList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageMeasureLineList message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessageMeasureLineList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessageMeasureLineList} message MessageMeasureLineList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageMeasureLineList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageMeasureLineList message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessageMeasureLineList} MessageMeasureLineList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageMeasureLineList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessageMeasureLineList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.MeasureLineList && message.MeasureLineList.length))
                                    message.MeasureLineList = [];
                                message.MeasureLineList.push($root.UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageMeasureLineList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessageMeasureLineList} MessageMeasureLineList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageMeasureLineList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageMeasureLineList message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageMeasureLineList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.MeasureLineList != null && message.hasOwnProperty("MeasureLineList")) {
                        if (!Array.isArray(message.MeasureLineList))
                            return "MeasureLineList: array expected";
                        for (var i = 0; i < message.MeasureLineList.length; ++i) {
                            var error = $root.UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo.verify(message.MeasureLineList[i]);
                            if (error)
                                return "MeasureLineList." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MessageMeasureLineList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessageMeasureLineList} MessageMeasureLineList
                 */
                MessageMeasureLineList.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessageMeasureLineList)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessageMeasureLineList();
                    if (object.MeasureLineList) {
                        if (!Array.isArray(object.MeasureLineList))
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessageMeasureLineList.MeasureLineList: array expected");
                        message.MeasureLineList = [];
                        for (var i = 0; i < object.MeasureLineList.length; ++i) {
                            if (typeof object.MeasureLineList[i] !== "object")
                                throw TypeError(".UIBot.UHOR.ProtoBuf.MessageMeasureLineList.MeasureLineList: object expected");
                            message.MeasureLineList[i] = $root.UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo.fromObject(object.MeasureLineList[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageMeasureLineList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineList
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessageMeasureLineList} message MessageMeasureLineList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageMeasureLineList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.MeasureLineList = [];
                    if (message.MeasureLineList && message.MeasureLineList.length) {
                        object.MeasureLineList = [];
                        for (var j = 0; j < message.MeasureLineList.length; ++j)
                            object.MeasureLineList[j] = $root.UIBot.UHOR.ProtoBuf.MessageMeasureLineInfo.toObject(message.MeasureLineList[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MessageMeasureLineList to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageMeasureLineList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageMeasureLineList
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessageMeasureLineList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageMeasureLineList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessageMeasureLineList";
                };

                return MessageMeasureLineList;
            })();

            ProtoBuf.Message2DPoint = (function() {

                /**
                 * Properties of a Message2DPoint.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessage2DPoint
                 * @property {number} x Message2DPoint x
                 * @property {number} y Message2DPoint y
                 */

                /**
                 * Constructs a new Message2DPoint.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a Message2DPoint.
                 * @implements IMessage2DPoint
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessage2DPoint=} [properties] Properties to set
                 */
                function Message2DPoint(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Message2DPoint x.
                 * @member {number} x
                 * @memberof UIBot.UHOR.ProtoBuf.Message2DPoint
                 * @instance
                 */
                Message2DPoint.prototype.x = 0;

                /**
                 * Message2DPoint y.
                 * @member {number} y
                 * @memberof UIBot.UHOR.ProtoBuf.Message2DPoint
                 * @instance
                 */
                Message2DPoint.prototype.y = 0;

                /**
                 * Creates a new Message2DPoint instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.Message2DPoint
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessage2DPoint=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.Message2DPoint} Message2DPoint instance
                 */
                Message2DPoint.create = function create(properties) {
                    return new Message2DPoint(properties);
                };

                /**
                 * Encodes the specified Message2DPoint message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.Message2DPoint.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.Message2DPoint
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessage2DPoint} message Message2DPoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message2DPoint.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.x);
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.y);
                    return writer;
                };

                /**
                 * Encodes the specified Message2DPoint message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.Message2DPoint.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.Message2DPoint
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessage2DPoint} message Message2DPoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message2DPoint.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Message2DPoint message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.Message2DPoint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.Message2DPoint} Message2DPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message2DPoint.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.Message2DPoint();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.x = reader.double();
                                break;
                            }
                        case 2: {
                                message.y = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("x"))
                        throw $util.ProtocolError("missing required 'x'", { instance: message });
                    if (!message.hasOwnProperty("y"))
                        throw $util.ProtocolError("missing required 'y'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Message2DPoint message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.Message2DPoint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.Message2DPoint} Message2DPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message2DPoint.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Message2DPoint message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.Message2DPoint
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Message2DPoint.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (typeof message.x !== "number")
                        return "x: number expected";
                    if (typeof message.y !== "number")
                        return "y: number expected";
                    return null;
                };

                /**
                 * Creates a Message2DPoint message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.Message2DPoint
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.Message2DPoint} Message2DPoint
                 */
                Message2DPoint.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.Message2DPoint)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.Message2DPoint();
                    if (object.x != null)
                        message.x = Number(object.x);
                    if (object.y != null)
                        message.y = Number(object.y);
                    return message;
                };

                /**
                 * Creates a plain object from a Message2DPoint message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.Message2DPoint
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.Message2DPoint} message Message2DPoint
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Message2DPoint.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.x = 0;
                        object.y = 0;
                    }
                    if (message.x != null && message.hasOwnProperty("x"))
                        object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
                    if (message.y != null && message.hasOwnProperty("y"))
                        object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
                    return object;
                };

                /**
                 * Converts this Message2DPoint to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.Message2DPoint
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Message2DPoint.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Message2DPoint
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.Message2DPoint
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Message2DPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.Message2DPoint";
                };

                return Message2DPoint;
            })();

            ProtoBuf.MessagePointInfoAndMosueState = (function() {

                /**
                 * Properties of a MessagePointInfoAndMosueState.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @interface IMessagePointInfoAndMosueState
                 * @property {UIBot.UHOR.ProtoBuf.IMessage2DPoint|null} [DistanceLabelPos] MessagePointInfoAndMosueState DistanceLabelPos
                 * @property {string} MouseState MessagePointInfoAndMosueState MouseState
                 */

                /**
                 * Constructs a new MessagePointInfoAndMosueState.
                 * @memberof UIBot.UHOR.ProtoBuf
                 * @classdesc Represents a MessagePointInfoAndMosueState.
                 * @implements IMessagePointInfoAndMosueState
                 * @constructor
                 * @param {UIBot.UHOR.ProtoBuf.IMessagePointInfoAndMosueState=} [properties] Properties to set
                 */
                function MessagePointInfoAndMosueState(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessagePointInfoAndMosueState DistanceLabelPos.
                 * @member {UIBot.UHOR.ProtoBuf.IMessage2DPoint|null|undefined} DistanceLabelPos
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState
                 * @instance
                 */
                MessagePointInfoAndMosueState.prototype.DistanceLabelPos = null;

                /**
                 * MessagePointInfoAndMosueState MouseState.
                 * @member {string} MouseState
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState
                 * @instance
                 */
                MessagePointInfoAndMosueState.prototype.MouseState = "";

                /**
                 * Creates a new MessagePointInfoAndMosueState instance using the specified properties.
                 * @function create
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessagePointInfoAndMosueState=} [properties] Properties to set
                 * @returns {UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState} MessagePointInfoAndMosueState instance
                 */
                MessagePointInfoAndMosueState.create = function create(properties) {
                    return new MessagePointInfoAndMosueState(properties);
                };

                /**
                 * Encodes the specified MessagePointInfoAndMosueState message. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState.verify|verify} messages.
                 * @function encode
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessagePointInfoAndMosueState} message MessagePointInfoAndMosueState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessagePointInfoAndMosueState.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.DistanceLabelPos != null && Object.hasOwnProperty.call(message, "DistanceLabelPos"))
                        $root.UIBot.UHOR.ProtoBuf.Message2DPoint.encode(message.DistanceLabelPos, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.MouseState);
                    return writer;
                };

                /**
                 * Encodes the specified MessagePointInfoAndMosueState message, length delimited. Does not implicitly {@link UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.IMessagePointInfoAndMosueState} message MessagePointInfoAndMosueState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessagePointInfoAndMosueState.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessagePointInfoAndMosueState message from the specified reader or buffer.
                 * @function decode
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState} MessagePointInfoAndMosueState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessagePointInfoAndMosueState.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.DistanceLabelPos = $root.UIBot.UHOR.ProtoBuf.Message2DPoint.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.MouseState = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("MouseState"))
                        throw $util.ProtocolError("missing required 'MouseState'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a MessagePointInfoAndMosueState message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState} MessagePointInfoAndMosueState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessagePointInfoAndMosueState.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessagePointInfoAndMosueState message.
                 * @function verify
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessagePointInfoAndMosueState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.DistanceLabelPos != null && message.hasOwnProperty("DistanceLabelPos")) {
                        var error = $root.UIBot.UHOR.ProtoBuf.Message2DPoint.verify(message.DistanceLabelPos);
                        if (error)
                            return "DistanceLabelPos." + error;
                    }
                    if (!$util.isString(message.MouseState))
                        return "MouseState: string expected";
                    return null;
                };

                /**
                 * Creates a MessagePointInfoAndMosueState message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState} MessagePointInfoAndMosueState
                 */
                MessagePointInfoAndMosueState.fromObject = function fromObject(object) {
                    if (object instanceof $root.UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState)
                        return object;
                    var message = new $root.UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState();
                    if (object.DistanceLabelPos != null) {
                        if (typeof object.DistanceLabelPos !== "object")
                            throw TypeError(".UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState.DistanceLabelPos: object expected");
                        message.DistanceLabelPos = $root.UIBot.UHOR.ProtoBuf.Message2DPoint.fromObject(object.DistanceLabelPos);
                    }
                    if (object.MouseState != null)
                        message.MouseState = String(object.MouseState);
                    return message;
                };

                /**
                 * Creates a plain object from a MessagePointInfoAndMosueState message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState
                 * @static
                 * @param {UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState} message MessagePointInfoAndMosueState
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessagePointInfoAndMosueState.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.DistanceLabelPos = null;
                        object.MouseState = "";
                    }
                    if (message.DistanceLabelPos != null && message.hasOwnProperty("DistanceLabelPos"))
                        object.DistanceLabelPos = $root.UIBot.UHOR.ProtoBuf.Message2DPoint.toObject(message.DistanceLabelPos, options);
                    if (message.MouseState != null && message.hasOwnProperty("MouseState"))
                        object.MouseState = message.MouseState;
                    return object;
                };

                /**
                 * Converts this MessagePointInfoAndMosueState to JSON.
                 * @function toJSON
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessagePointInfoAndMosueState.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessagePointInfoAndMosueState
                 * @function getTypeUrl
                 * @memberof UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessagePointInfoAndMosueState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/UIBot.UHOR.ProtoBuf.MessagePointInfoAndMosueState";
                };

                return MessagePointInfoAndMosueState;
            })();

            return ProtoBuf;
        })();

        return UHOR;
    })();

    return UIBot;
})();

module.exports = $root;
